<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhisheng的博客</title>
  
  <subtitle>坑要一个个填，路要一步步走！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-21T10:29:55.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhisheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot Kafka 整合使用</title>
    <link href="http://yoursite.com/2018/01/21/SpringBoot-Kafka/"/>
    <id>http://yoursite.com/2018/01/21/SpringBoot-Kafka/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/DKcBEKHimB.jpg-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>假设你了解过 SpringBoot 和 Kafka。<br><a id="more"></a><br>1、SpringBoot</p><p>如果对 SpringBoot 不了解的话，建议去看看 <a href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">DD 大佬</a> 和 <a href="http://www.ityouknow.com/spring-boot.html" target="_blank" rel="noopener">纯洁的微笑</a> 的系列博客。</p><p>2、Kafka</p><p>Kafka 的话可以看看我前两天写的博客 ： <a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a>   学习的话自己开台虚拟机自己手动搭建环境吧，有条件的买服务器。</p><p>注意：<strong>一定要亲自自己安装实践</strong>，接下来我们将这两个进行整合。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h4 id="项目整体架构："><a href="#项目整体架构：" class="headerlink" title="项目整体架构："></a>项目整体架构：</h4><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/c6jC85Bbk4.png-1" alt="mark"></p><p>使用 IDEA 创建 SpringBoot 项目，这个很简单了，这里不做过多的讲解。</p><p>1、pom 文件代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-learning<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>kafka-learning<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot + kafka<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要引入了  spring-kafka 、lombok 、 gson 依赖。</p><p>2、消息实体类 Message.java  如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">//id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date sendTime;  <span class="comment">//时间戳</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、消息发送类 KafkaSender.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Gson gson = <span class="keyword">new</span> GsonBuilder().create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        message.setId(System.currentTimeMillis());</span><br><span class="line">        message.setMsg(UUID.randomUUID().toString());</span><br><span class="line">        message.setSendTime(<span class="keyword">new</span> Date());</span><br><span class="line">        log.info(<span class="string">"+++++++++++++++++++++  message = &#123;&#125;"</span>, gson.toJson(message));</span><br><span class="line">        kafkaTemplate.send(<span class="string">"zhisheng"</span>, gson.toJson(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，发送消息代码就实现了。</p><p>这里关键的代码为 <code>kafkaTemplate.send()</code>  方法，<code>zhisheng</code> 是 Kafka 里的 topic ，这个 topic 在 Java 程序中是不需要提前在 Kafka 中设置的，因为它会在发送的时候自动创建你设置的 topic， <code>gson.toJson(message)</code>   是消息内容，这里暂时先说这么多了，不详解了，后面有机会继续把里面源码解读写篇博客出来（因为中途碰到坑，老子跟了几遍源码）。</p><p>4、消息接收类  KafkaReceiver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123;<span class="string">"zhisheng"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kafkaMessage.isPresent()) &#123;</span><br><span class="line"></span><br><span class="line">            Object message = kafkaMessage.get();</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"----------------- record ="</span> + record);</span><br><span class="line">            log.info(<span class="string">"------------------ message ="</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端 consumer 接收消息特别简单，直接用 <code>@KafkaListener</code> 注解即可，并在监听中设置监听的 <code>topic</code> ，<code>topics</code> 是一个数组所以是可以绑定多个主题的，上面的代码中修改为 <code>@KafkaListener(topics = {&quot;zhisheng&quot;,&quot;tian&quot;})</code>  就可以同时监听两个 <code>topic</code> 的消息了。需要注意的是：这里的 topic 需要和消息发送类 KafkaSender.java 中设置的 topic 一致。</p><p>5、启动类 KafkaApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(KafkaApplication.class, args);</span><br><span class="line"></span><br><span class="line">        KafkaSender sender = context.getBean(KafkaSender.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//调用消息发送类中的消息发送方法</span></span><br><span class="line">            sender.send();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、配置文件 application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#============== kafka ===================</span><br><span class="line"># 指定kafka 代理地址，可以多个</span><br><span class="line">spring.kafka.bootstrap-servers=192.168.153.135:9092</span><br><span class="line"></span><br><span class="line">#=============== provider  =======================</span><br><span class="line"></span><br><span class="line">spring.kafka.producer.retries=0</span><br><span class="line"># 每次批量发送消息的数量</span><br><span class="line">spring.kafka.producer.batch-size=16384</span><br><span class="line">spring.kafka.producer.buffer-memory=33554432</span><br><span class="line"></span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line"></span><br><span class="line">#=============== consumer  =======================</span><br><span class="line"># 指定默认消费者group id</span><br><span class="line">spring.kafka.consumer.group-id=test-consumer-group</span><br><span class="line"></span><br><span class="line">spring.kafka.consumer.auto-offset-reset=earliest</span><br><span class="line">spring.kafka.consumer.enable-auto-commit=true</span><br><span class="line">spring.kafka.consumer.auto-commit-interval=100</span><br><span class="line"></span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br></pre></td></tr></table></figure><p>spring.kafka.bootstrap-servers 后面设置你安装的 Kafka 的机器 IP 地址和端口号 9092。</p><p>如果你只是简单整合下，其他的几个默认就好了。</p><h3 id="Kafka-设置"><a href="#Kafka-设置" class="headerlink" title="Kafka 设置"></a>Kafka 设置</h3><p>在你安装的 Kafka 目录文件下：</p><h4 id="启动-zk"><a href="#启动-zk" class="headerlink" title="启动 zk"></a>启动 zk</h4><p>使用安装包中的脚本启动单节点 Zookeeper 实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><h4 id="启动-Kafka-服务"><a href="#启动-Kafka-服务" class="headerlink" title="启动 Kafka 服务"></a>启动 Kafka 服务</h4><p>使用 <code>kafka-server-start.sh</code> 启动 kafka 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh  config/server.properties</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/Lc2CiKfIee.png-1" alt="mark"></p><p>启动成功后！</p><p><strong>千万注意</strong>： 记得将你的虚拟机或者服务器关闭防火墙或者开启 Kafka 的端口 9092。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/HBB0LCDdj8.png-1" alt="mark"></p><p>出现这就代表整合成功了！</p><hr><p>我们看下 Kafka 中的 topic 列表就</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/DI6cmll4BC.png-1" alt="mark"></p><p>就会发现刚才我们程序中的 <code>zhisheng</code> 已经自己创建了。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180105/DKcBEKHimB.jpg-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;假设你了解过 SpringBoot 和 Kafka。&lt;br&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>《疯狂 Java 突破程序员基本功的 16 课》读书笔记</title>
    <link href="http://yoursite.com/2018/01/21/Java-16-lession/"/>
    <id>http://yoursite.com/2018/01/21/Java-16-lession/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第-1-课-——-数组与内存控制"><a href="#第-1-课-——-数组与内存控制" class="headerlink" title="第 1 课 —— 数组与内存控制"></a>第 1 课 —— 数组与内存控制</h2><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>数组初始化之后，该数组的长度是不可变的（可通过数组的 length 属性访问数组的长度）。Java 中的数组必须经过初始化（为数组对象的元素分配内存空间，并为每个数组元素指定初始值）才可使用。</p><p>数组初始化的形式：</p><ul><li>静态初始化：初始化时由程序员显示的指定每个数组的初始值，系统决定数组长度。</li><li>动态初始化：初始化时程序员只指定数组的长度，系统为数组元素分配初始值。</li></ul><a id="more"></a><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>数组元素就是变量：例如 int[] 数组元素相当于 int 类型的变量</p><p>当通过索引来使用数组元素时（访问数组元素的值、为数组元素赋值），将该数组元素当成普通变量使用即可。</p><h2 id="第-2-课-——-对象与内存的控制"><a href="#第-2-课-——-对象与内存的控制" class="headerlink" title="第 2 课 —— 对象与内存的控制"></a>第 2 课 —— 对象与内存的控制</h2><p>Java 内存管理分为：内存分配和内存回收。</p><blockquote><ul><li>内存分配：创建 Java 对象时 JVM 为该对象在堆内存中所分配的内存空间。</li><li>内存回收：当 Java 对象失去引用，变成垃圾，JVM 的垃圾回收机制自动清理该对象，并回收内存</li></ul></blockquote><h3 id="实例变量-和-类变量"><a href="#实例变量-和-类变量" class="headerlink" title="实例变量 和 类变量"></a>实例变量 和 类变量</h3><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>特点：作用时间短，存储在方法的栈内存中</p><p>种类：</p><ul><li>形参：方法签名中定义的局部变量，由方法调用者负责为其赋值，随方法结束而消亡</li><li>方法内的局部变量：方法内定义的局部变量，必须在方法内对其进行显示初始化，从初始化后开始生效，随方法结束而消亡</li><li>代码块内的局部变量：在代码块中定义的局部变量，必须在代码块中进行显示初始化，从初始化后开始生效，随代码块结束而消亡</li></ul><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>类体内定义的变量，如果该成员变量没有使用 static 修饰，那该成员变量又被称为非静态变量或实例变量，如果使用 static 修饰，则该成员变量又可被称为静态变量或类变量。</p><h4 id="实例变量和类变量的属性"><a href="#实例变量和类变量的属性" class="headerlink" title="实例变量和类变量的属性"></a>实例变量和类变量的属性</h4><p>使用 static 修饰的成员变量是类变量，属于该类本身，没有使用 static 修饰的成员变量是实例变量，属于该类的实例，在同一个类中，每一个类只对应一个 Class 对象，但每个类可以创建多个对象。</p><p>由于同一个 JVM 内的每个类只对应一个 CLass 对象，因此同一个 JVM 内的一个类的类变量只需要一块内存空间；但对于实例变量而言，该类每创建一次实例，就需要为该实例变量分配一块内存空间。也就是说，程序中创建了几个实例，实例变量就需要几块内存空间。</p><p>这里我想到一道面试题目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"我是代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是静态代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是静态代码块</span><br><span class="line">我是代码块</span><br><span class="line">我是代码块</span><br></pre></td></tr></table></figure><p>静态代码块只执行一次，而代码块每创建一个实例，就会打印一次。</p><h4 id="实例变量的初始化时机"><a href="#实例变量的初始化时机" class="headerlink" title="实例变量的初始化时机"></a>实例变量的初始化时机</h4><p>程序可在3个地方对实例变量执行初始化：</p><ul><li>定义实例变量时指定初始值</li><li>非静态初始化块中对实例变量指定初始值</li><li>构造器中对实例变量指定初始值</li></ul><p>上面第一种和第二种方式比第三种方式更早执行，但第一、二种方式的执行顺序与他们在源程序中的排列顺序相同。</p><p>同样在上面那个代码上加上一个变量 weight 的成员变量，我们来验证下上面的初始化顺序：</p><p>1、<code>定义实例变量指定初始值</code> 在 <code>非静态初始化块对实例变量指定初始值</code> 之后:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        weight = <span class="number">2.1</span>;</span><br><span class="line">        System.out.println(<span class="string">"我是代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(a.weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是静态代码块</span><br><span class="line">我是代码块</span><br><span class="line">我是代码块</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure><p>2、<code>定义实例变量指定初始值</code> 在 <code>非静态初始化块对实例变量指定初始值</code> 之前:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> weight = <span class="number">2.0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        weight = <span class="number">2.1</span>;</span><br><span class="line">        System.out.println(<span class="string">"我是代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(a.weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是静态代码块</span><br><span class="line">我是代码块</span><br><span class="line">我是代码块</span><br><span class="line">2.1</span><br></pre></td></tr></table></figure><p>大家有没有觉得很奇怪？</p><p>我来好好说清楚下：</p><blockquote><p>定义实例变量时指定的初始值、初始代码块中为实例变量指定初始值的语句的地位是平等的，当经过编译器处理后，他们都将会被提取到构造器中。也就是说，这条语句 <code>double weight = 2.0;</code> 实际上会被分成如下 2 次执行：</p><ul><li><code>double weight;</code> : 创建 Java 对象时系统根据该语句为该对象分配内存。</li><li><code>weight = 2.1;</code> : 这条语句将会被提取到 Java 类的构造器中执行。</li></ul></blockquote><p>只说原理，大家肯定不怎么信，那么还有拿出源码来，这样才有信服能力的吗？是不？</p><p>这里我直接使用软件将代码的字节码文件反编译过来，看看里面是怎样的组成？</p><p>第一个代码的反编译源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">2.1</span>D;</span><br><span class="line">    System.out.println(<span class="string">"我是代码块"</span>);</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">2.0</span>D;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"我是静态代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    A a1 = <span class="keyword">new</span> A();</span><br><span class="line">    System.out.println(a.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个代码反编译源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">2.0</span>D;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">2.1</span>D;</span><br><span class="line">    System.out.println(<span class="string">"我是代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"我是静态代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    A a1 = <span class="keyword">new</span> A();</span><br><span class="line">    System.out.println(a.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下子满意了吧！</p><p>通过反编译的源码可以看到该类定义的 weight 实例变量时不再有初始值，为 weight 指定初始值的代码也被提到了构造器中去了，但是我们也可以发现之前规则也是满足的。</p><p>他们的赋值语句都被合并到构造器中，在合并过程中，定义的变量语句转换得到的赋值语句，初始代码块中的语句都转换得到的赋值语句，总是位于构造器的所有语句之前，合并后，两种赋值语句的顺序也保持了它们在 Java 源代码中的顺序。</p><p>大致过程应该了解了吧？如果还不怎么清楚的，建议还是自己将怎个过程在自己的电脑上操作一遍，毕竟光看不练假把式。</p><h4 id="类变量的初始化时机"><a href="#类变量的初始化时机" class="headerlink" title="类变量的初始化时机"></a>类变量的初始化时机</h4><p>JVM 对每一个 Java 类只初始化一次，因此 Java 程序每运行一次，系统只为类变量分配一次内存空间，执行一次初始化。程序可在两个地方对类变量执行初始化：</p><ul><li>定义类变量时指定初始值</li><li>静态初始化代码块中对类变量指定初始值</li></ul><p>这两种方式的执行顺序与它们在源代码中的排列顺序相同。</p><p>还是用上面那个示例，我们在其基础上加个被 static 修饰的变量 height：</p><p>1、<code>定义类变量时指定初始值</code> 在 <code>静态初始化代码块中对类变量指定初始值</code> 之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">2.0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        weight = <span class="number">2.1</span>;</span><br><span class="line">        System.out.println(<span class="string">"我是代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        height = <span class="number">10.1</span>;</span><br><span class="line">        System.out.println(<span class="string">"我是静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> height = <span class="number">10.0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(a.weight);</span><br><span class="line">        System.out.println(height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是静态代码块</span><br><span class="line">我是代码块</span><br><span class="line">我是代码块</span><br><span class="line">2.1</span><br><span class="line">10.0</span><br></pre></td></tr></table></figure><p>2、<code>定义类变量时指定初始值</code> 在 <code>静态初始化代码块中对类变量指定初始值</code> 之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> height = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">2.0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        weight = <span class="number">2.1</span>;</span><br><span class="line">        System.out.println(<span class="string">"我是代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        height = <span class="number">10.1</span>;</span><br><span class="line">        System.out.println(<span class="string">"我是静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(a.weight);</span><br><span class="line">        System.out.println(height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是静态代码块</span><br><span class="line">我是代码块</span><br><span class="line">我是代码块</span><br><span class="line">2.1</span><br><span class="line">10.1</span><br></pre></td></tr></table></figure><p>其运行结果正如我们预料，但是我们还是看看反编译后的代码吧！</p><p>第一种情况下反编译的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">2.0</span>D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">2.1</span>D;</span><br><span class="line">    System.out.println(<span class="string">"我是代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"我是静态代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> height = <span class="number">10.0</span>D;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    A a1 = <span class="keyword">new</span> A();</span><br><span class="line">    System.out.println(a.weight);</span><br><span class="line">    System.out.println(height);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种情况下反编译的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> height = <span class="number">10.0</span>D;</span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">2.0</span>D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">2.1</span>D;</span><br><span class="line">    System.out.println(<span class="string">"我是代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    height = <span class="number">10.1</span>D;</span><br><span class="line">    System.out.println(<span class="string">"我是静态代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    A a1 = <span class="keyword">new</span> A();</span><br><span class="line">    System.out.println(a.weight);</span><br><span class="line">    System.out.println(height);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反编译源码，可以看到第一种情况下(<code>定义类变量时指定初始值</code> 在 <code>静态初始化代码块中对类变量指定初始值</code> 之后):</p><p>我们在 <strong>静态初始化代码块中对类变量指定初始值</strong> 已经不存在了，只有一个类变量指定的初始值 <code>static double height = 10.0D;</code> , 而在第二种情况下（<code>定义类变量时指定初始值</code> 在 <code>静态初始化代码块中对类变量指定初始值</code> 之前）和之前的源代码顺序是一样的，没啥区别。</p><p>上面的代码中充分的展示了类变量的两种初始化方式 ：每次运行该程序时，系统会为 A 类执行初始化，先为所有类变量分配内存空间，再按照源代码中的排列顺序执行静态初始代码块中所指定的初始值和定义类变量时所指定的初始值。</p><h3 id="父类构造器"><a href="#父类构造器" class="headerlink" title="父类构造器"></a>父类构造器</h3><p>当创建任何 Java 对象时，程序总会先依次调用每个父类非静态初始化代码块、父类构造器（总是从 Object 开始）执行初始化，最后才调用本类的非静态初始化代码块、构造器执行初始化。</p><h4 id="隐式调用和显示调用"><a href="#隐式调用和显示调用" class="headerlink" title="隐式调用和显示调用"></a>隐式调用和显示调用</h4><p>当调用某个类的构造器来创建 Java 对象时，系统总会先调用父类的非静态初始化代码块进行初始化。这个调用是隐式执行的，而且父类的静态初始化代码块总是会被执行。接着会调用父类的一个或多个构造器执行初始化，这个调用既可以是通过 super 进行显示调用，也可以是隐式调用。</p><p>当所有父类的非静态初始代码块、构造器依次调用完成后，系统调用本类的非静态代码块、构造器执行初始化，最后返回本类的实例。至于调用父类的哪个构造器执行初始化，分以下几种情况：</p><ul><li>子类构造器执行体的第一行代码使用 super 显式调用父类构造器，系统将根据 super 调用里传入的实参列表来确定调用父类的哪个构造器；</li><li>子类构造器执行体的第一行代码使用 this 显式调用本类中的重载构造器，系统将根据 this 调用里传入的实参列表来确定奔雷的另一个构造器（执行本类中另一个构造器时即进入第一种情况）；</li><li>子类构造器中既没有 super 调用，也没有 this 调用，系统将会在执行子类构造器之前，隐式调用父类无参构造器。</li></ul><p>注：super 和 this 必须在构造器的第一行，且不能同时存在。</p><p>推荐一篇博客：<a href="http://www.cnblogs.com/miniwiki/archive/2011/03/25/1995615.html" target="_blank" rel="noopener">Java初始化顺序</a> 文章从无继承和继承两种情况下分析了 Java 初始化的顺序。</p><p><strong>Java初始化顺序如图：</strong></p><p><img src="data:image/png;base64,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NriW1VDAwKvGcXAtrIAVGEaBTZs2zZo168Ybb1y5ciXA43v58uVXXHHFIYccwi7LZgXGroCBN3atnNIKWIHBKHDppZeCukK49tprB1Mbl1pbBQy82h46V9wKtEaBNWvWFGh34IEHpkudrVHCDZ2QAgbehORzZitgBcpR4LzzzkuZt3Tp0nLKdSlNUsDAa9LRdFusQGMVePjhhwN4M2fObGw73bCcChh4OdW1bStgBfqnAJwT84Bf/6zaUosUMPBadLDdVCtQawWWLVsG7c4444xat8KVH6ACBt4AxXfRVsAK7IQCXKXCtSpcwLITeZzUCiQKGHjuDlagvQpwHxu3tREOOuig7uv+HTMRBViAlbbt7V7Va7mBV71j4hpZgZwKADnWBlkYZDafMmXKoUNhwYIFv3DonwI333zzMcccI22lM7cS+tRjzn49JtsG3phkciIr0AAF1q1bB+f23nvv448/HsLd6lCWAtddd9255547ffr0vfbaC6r6DsJBjSYDb1DKu1wrUJ4CeHV4GFOnTjXnymJc73JuuOGGU0899Tvf+Q5OdnmH3yV9pICB575gBRquAKeRQB0exmDnepceCuDw4WRzRPzw65LHnoFXsuAuzgqUqgBPJOE00vXXX3+LQ8UUuPDCC4899ljWmUvtEO0uzMBr9/F36xutAMuYJ510UsXmeVfnYwWWLFly8MEHP/PMM43uhhVqnIFXoYPhqliBPirAWaLjjjvOeKm4AldddRXMe+WVV/p46G1qOAUMPPcNK9BABVavXs1KJu+Q4/p4h4orcMkll5xwwglvvfVWAztixZpk4FXsgLg6VmDCCnDV+7777nvNNddUfKJ39UKBOXPmXHbZZTt27JjwwbeBkRQw8Nw/rEDTFOBt4GeeeaZxUi8FeGraE0888f777zetO1apPQZelY6G62IFJqwAt9zh3nG/188daqXAvHnz8PPeeOONCXcBGxhWAQPPncMKNEoBrsw8++yzazXVu7IfKoCTt2LFCi9s5huQBl4+bW3ZCpStAGfveHIY9zWbIXVUgH8q3Jy3efPmsvtNa8oz8FpzqN3QFijw+OOPH3bYYTc51FMBblHgmTgvvvjitm3bWtBbB9BEA28AortIK5BJAa1n1nO2d607CkybNu2hhx7ymbxMA8TAyySszVqBAShwxBFHcHW70VFfBU4++eSrr756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" alt=""></p><h4 id="访问子类对象的实例变量"><a href="#访问子类对象的实例变量" class="headerlink" title="访问子类对象的实例变量"></a>访问子类对象的实例变量</h4><h4 id="调用被子类重写的方法"><a href="#调用被子类重写的方法" class="headerlink" title="调用被子类重写的方法"></a>调用被子类重写的方法</h4><h3 id="父子实例的内存控制"><a href="#父子实例的内存控制" class="headerlink" title="父子实例的内存控制"></a>父子实例的内存控制</h3><h4 id="继承成员变量和继承方法的区别"><a href="#继承成员变量和继承方法的区别" class="headerlink" title="继承成员变量和继承方法的区别"></a>继承成员变量和继承方法的区别</h4><p>方法的行为总是表现出它们实际类型的行为；实例变量的值总是表现出声明这些变量所用类型的行为。</p><h4 id="内存中的子类实例"><a href="#内存中的子类实例" class="headerlink" title="内存中的子类实例"></a>内存中的子类实例</h4><h4 id="父、子类的类变量"><a href="#父、子类的类变量" class="headerlink" title="父、子类的类变量"></a>父、子类的类变量</h4><h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><p>final 可以修饰变量、方法、类。</p><ul><li>修饰变量，变量被赋初始值之后，不能够对他在进行修改</li><li>修饰方法，不能够被重写</li><li>修饰类，不能够被继承</li></ul><p>final 修饰的实例变量只能在如下位置指定初始值：</p><ul><li>定义 final 实例变量时指定初始值</li><li>在非静态代码块中为 final 实例变量指定初始值</li><li>在构造器中为 final 实例变量指定初始值</li></ul><p>final 修饰的类变量只能在如下位置指定初始值：</p><ul><li>定义 final 类变量时指定初始值</li><li>在静态代码块中为 final 类变量指定初始值</li></ul><h2 id="第-3-课-——-常见-Java-集合的实现细节"><a href="#第-3-课-——-常见-Java-集合的实现细节" class="headerlink" title="第 3 课 —— 常见 Java 集合的实现细节"></a>第 3 课 —— 常见 Java 集合的实现细节</h2><p>Java 集合框架类图：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%9B%BE.jpg" alt=""></p><h3 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h3><p>Set 代表一种集合元素无序、集合元素不可重复的集合，Map 则代表一种由多个 key-value 对组合的集合，Map 集合类似于传统的关联数组。</p><h4 id="Set-和-Map-的关系"><a href="#Set-和-Map-的关系" class="headerlink" title="Set 和 Map 的关系"></a>Set 和 Map 的关系</h4><p>1、Map 集合中的 key 不能重复且没有顺序。将这些 key 组合起来就是一个 Set 集合。所以有一个 <code>Set&lt;k&gt; keySet()</code> 方法来返回所有 key 组成的 Set 集合。</p><p>2、Set 也可以转换成 Map。（在 Set 中将 每一对 key 和 value 存放在一起）</p><h4 id="HashMap-和-HashSet"><a href="#HashMap-和-HashSet" class="headerlink" title="HashMap 和 HashSet"></a>HashMap 和 HashSet</h4><p>HashSet：系统采用 Hash 算法决定集合元素的存储位置。（基于 HashMap 实现的）</p><p>HashMap：系统将 value 当成 key 的附属，系统根据 Hash 算法决定 key 的存储位置。</p><p>HashSet 的绝大部分方法都是通过调用 HashMap 的方法实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的。</p><h4 id="TreeMap-和-TreeSet"><a href="#TreeMap-和-TreeSet" class="headerlink" title="TreeMap 和 TreeSet"></a>TreeMap 和 TreeSet</h4><p>TreeSet 底层使用 TreeMap 来包含 Set 集合中的所有元素。</p><p>TreeMap 采用的是一种“红黑树”的排序二叉树来保存 Map 中每个 Entry —— 每个 Entry 都被当成 “红黑树” 的一个节点对待。</p><h3 id="Map-和-List"><a href="#Map-和-List" class="headerlink" title="Map 和 List"></a>Map 和 List</h3><h4 id="Map-的-values-方法"><a href="#Map-的-values-方法" class="headerlink" title="Map 的 values() 方法"></a>Map 的 values() 方法</h4><p>不管是 HashMap 还是 TreeMap ，它们的 values() 方法都可以返回其所有 value 组成的 Collection 集合，其实是一个不存储元素的 Collection 集合，当程序遍历 Collection 集合时，实际上就是遍历 Map 对象的 value。</p><p>HashMap 和 TreeMap 的 values() 方法并未把 Map 中的 values 重新组合成一个包含元素的集合对象，这样就可以降低系统内存开销。</p><h4 id="Map-和-List-的关系"><a href="#Map-和-List-的关系" class="headerlink" title="Map 和 List 的关系"></a>Map 和 List 的关系</h4><p>底层实现很相似；用法上很相似。</p><ul><li>Map 接口提供 get(K key) 方法允许 Map 对象根据 key 来取得 value；</li><li>List 接口提供了 get(int index) 方法允许 List 对象根据元素索引来取得 value；</li></ul><h3 id="ArrayList-和-LinkedList"><a href="#ArrayList-和-LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h3><p>List 集合的实现类，主要有 ArrayList 、Vector 和 LinkedList。</p><ul><li><strong>ArrayList </strong>是一个可改变大小的数组.当更多的元素加入到 ArrayList 中时, 其大小将会动态地增长.  内部的元素可以直接通过 get 与 set 方法进行访问, 因为 ArrayList 本质上就是一个数组.</li><li><strong>LinkedList </strong>是一个双链表, 在添加和删除元素时具有比 ArrayList 更好的性能. 但在 get 与 set 方面弱于ArrayList. 当然, 这些对比都是指数据量很大或者操作很频繁的情况下的对比, 如果数据和运算量很小,那么对比将失去意义.</li><li><strong>Vector </strong>和 ArrayList 类似, 但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用 ArrayList 是更好的选择。</li></ul><p>Vector 和 ArrayList 在更多元素添加进来时会请求更大的空间。Vector 每次请求其大小的双倍空间，而 ArrayList每次对 size 增长 50%.</p><p>而 LinkedList 还实现了 Queue 接口, 该接口比 List 提供了更多的方法,包括 offer(), peek(), poll()等.</p><p>注意: 默认情况下 ArrayList 的初始容量非常小, 所以如果可以预估数据量的话, 分配一个较大的初始值属于最佳实践, 这样可以减少调整大小的开销。</p><p>ArrayList与LinkedList性能对比</p><p>时间复杂度对比如下:</p><p><img src="http://www.programcreek.com/wp-content/uploads/2013/03/arraylist-vs-linkedlist-complexity.png" alt=""></p><p>LinkedList 更适用于:</p><ul><li>没有大规模的随机读取</li><li>大量的增加/删除操作</li></ul><h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h3><p>是一个迭代器接口，专门用于迭代各种 Collection 集合，包括 Set  集合和 List 集合。</p><h2 id="第-4-课-——-Java-的内存回收"><a href="#第-4-课-——-Java-的内存回收" class="headerlink" title="第 4 课 —— Java 的内存回收"></a>第 4 课 —— Java 的内存回收</h2><h3 id="Java-引用的种类"><a href="#Java-引用的种类" class="headerlink" title="Java 引用的种类"></a>Java 引用的种类</h3><h4 id="对象在内存中的状态"><a href="#对象在内存中的状态" class="headerlink" title="对象在内存中的状态"></a>对象在内存中的状态</h4><p>JVM 垃圾回收机制，是否回收一个对象的标准在于：是否还有引用变量引用该对象？只要有引用变量引用该对象，垃圾回收机制就不会回收它。</p><p>Java 语言对对象的引用有：</p><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ul><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>程序创建一个对象，并把这个对象赋给一个引用变量，这个引用变量就是强引用。当一个对象被一个或者一个以上的强引用变量所引用时，它处于可达状态，它是不会被系统的垃圾回收机制回收。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用需要通过 SoftReference 类来实现，当一个对象只具有软引用时，它有可能会被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象；当系统内存空间不足时，系统将会回收它。</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用和软引用有点相似，区别在于弱引用所引用对象的生存期更短。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。</p><h3 id="Java-的内存泄漏"><a href="#Java-的内存泄漏" class="headerlink" title="Java 的内存泄漏"></a>Java 的内存泄漏</h3><p>ArrayList.java 中的 remove 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 <code>elementData[--size] = null; // clear to let GC do its work</code> 语句是清除数组元素的引用，避免内存的泄漏，如果没有这句的话，那么就是只有两个作用：</p><ul><li>修饰 Stack 的属性，也就是将值减 1；</li><li>返回索引为 size -1 的值。</li></ul><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><ul><li>跟踪并监控每个 Java 对象，当某个对象处于不可达状态时，回收该对象所占用的内存。</li><li>清理内存分配，回收过程中产生的内存碎片。</li></ul><h4 id="垃圾回收的基本算法"><a href="#垃圾回收的基本算法" class="headerlink" title="垃圾回收的基本算法"></a>垃圾回收的基本算法</h4><p>对于一个垃圾回收器的设计算法来说，大概有如下几个设计：</p><ul><li><p>串行回收 和 并行回收</p><blockquote><p>串行回收：不管系统有多少个 CPU，始终使用一个 CPU 来执行垃圾回收操作</p><p>并行回收：把整个回收工作拆分成多部分，每个部分由一个 CPU 负责，从而让多个 CPU 并行回收</p></blockquote></li><li><p>并发执行 和 应用程序停止</p></li><li><p>压缩 和 不压缩 和 复制</p><blockquote><ul><li>复制：将堆内分成两个相同的空间，从根开始访问每一个关联的可达对象，将空间A的可达对象全部复制到空间B，然后一次性回收整个空间A。</li><li>标记清除：也就是 不压缩 的回收方式。垃圾回收器先从根开始访问所有可达对象，将它们标记为可达状态，然后再遍历一次整个内存区域，把所有没有标记为可达的对象进行回收处理。</li><li>标记压缩：这是压缩方式，这种方式充分利用上述两种算法的优点，垃圾回收器先从根开始访问所有可达对象，将他们标记为可达状态，接下来垃圾回收器会将这些活动对象搬迁在一起，这个过程叫做内存压缩，然后垃圾回收机制再次回收那些不可达对象所占用的内存空间，这样就避免了回收产生的内存碎片。</li></ul></blockquote></li></ul><h4 id="堆内存的分代回收"><a href="#堆内存的分代回收" class="headerlink" title="堆内存的分代回收"></a>堆内存的分代回收</h4><p>1、Young 代</p><p>2、Old 代</p><p>3、Permanent 代</p><h3 id="内存管理小技巧"><a href="#内存管理小技巧" class="headerlink" title="内存管理小技巧"></a>内存管理小技巧</h3><ul><li>尽量使用直接量</li><li>使用 StringBuilder 和 StringBuffer 进行字符串拼接</li><li>尽早释放无用对象的引用</li><li>尽量少用静态变量</li><li>避免在经常调用的方法、循环中创建 Java 对象</li><li>缓存经常使用的对象</li><li>尽量不要使用 finalize 方法</li><li>考虑使用 SoftReference</li></ul><h2 id="第-5-课-——-表达式中的陷阱"><a href="#第-5-课-——-表达式中的陷阱" class="headerlink" title="第 5 课 —— 表达式中的陷阱"></a>第 5 课 —— 表达式中的陷阱</h2><h3 id="关于字符串的陷阱"><a href="#关于字符串的陷阱" class="headerlink" title="关于字符串的陷阱"></a>关于字符串的陷阱</h3><h4 id="JVM-对字符串的处理"><a href="#JVM-对字符串的处理" class="headerlink" title="JVM 对字符串的处理"></a>JVM 对字符串的处理</h4><p><code>String java = new String(&quot;Java&quot;)</code> 这句创建了两个字符串对象，一个是 “Java” 这个直接量对应的字符串对象，另外一个是 new String() 构造器返回的字符串对象。</p><p>Java 程序中创建对象的方法：</p><ul><li>通过 new 调用构造器创建 Java 对象</li><li>通过 Class 对象的 newInstance() 方法调用构造器创建 Java 对象</li><li>通过 Java 的反序列化机制从 IO 流中恢复 Java 对象</li><li>通过 Java 对象提供的 clone() 方法复制一个新的 Java 对象</li><li>对于字符串以及 Byte、Short、Int、Long、Character、Float、Double 和 Boolean 这些基本类型的包装类</li><li>直接量的方式来创建 Java 对象  Integer in = 5；</li><li>通过简单的算法表达式，连接运算来创建 Java 对象 String str = “a” + “b”; （如果这个字符串表达式的值在编译时确定下来，那么 JVM 会在编译时计算该字符串变量的值，并让它指向字符串池中对应的字符串。如果这些算法表达式都是字符串直接量、整数直接量，没有变量和方法参与，那么就可以在编译期就可以确定字符串的值；如果使用了变量、调用了方法，那么只有等到运行时才能确定字符串表达式的值；如果字符串连接运算所有的变量都可执行 “宏替换”（使用 final 修饰的变量），那在编译时期也能确定字符串连接表达式的值）</li></ul><p>对于 Java 程序的字符直接量，JVM 会使用一个字符串池来保护它们；当第一次使用某个字符串直接量时，JVM 会将它放入字符串池进行缓存。在一般的情况下，字符串池中的字符串对象不会被垃圾回收器回收，当程序再次需要使用该字符串时，无需重新创建一个新的字符串，而是直接让引用变量指向字符串池中已有的字符串。</p><h4 id="不可变的字符串"><a href="#不可变的字符串" class="headerlink" title="不可变的字符串"></a>不可变的字符串</h4><p>String 类是一个不可变类，当一个 String 对象创建完成后，该 String 类里包含的字符序列就被固定下来，以后永远不能修改。</p><p>如果程序需要一个字符序列会发生改变的字符串，那么建议使用 StringBuilder （效率比 StringBuffer 高）</p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>如果要比较两个字符串是否相同，用 == 进行判断就行，但如果要判断两个字符串所包含的字符序列是否相同，则应该用 String 重写过的 equals() 方法进行比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果两个字符串相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果anObject是String类型</span></span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="comment">//n代表字符串的长度</span></span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="comment">//如果两个字符串长度相等</span></span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="comment">//获取当前字符串、anotherString底层封装的字符数组</span></span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//逐一比较v1 和 v2数组中的每个字符</span></span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还可以使用 String 提供的 compareTo() 方法返回两个字符串的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">        <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">        <span class="keyword">char</span> v1[] = value;</span><br><span class="line">        <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">            <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                <span class="keyword">return</span> c1 - c2;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len1 - len2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="表达式类型的陷阱"><a href="#表达式类型的陷阱" class="headerlink" title="表达式类型的陷阱"></a>表达式类型的陷阱</h3><h4 id="表达式类型的自动提升"><a href="#表达式类型的自动提升" class="headerlink" title="表达式类型的自动提升"></a>表达式类型的自动提升</h4><ul><li><p>所有 byte、short、char类型将被提升到 int 类型参与运算</p></li><li><p>整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型，操作数的等级排列如下：char -&gt; int -&gt; long -&gt;float -&gt; double</p><p>byte -&gt; short -&gt; int -&gt; long -&gt;float -&gt; double</p></li></ul><h4 id="复合赋值运算符的陷阱"><a href="#复合赋值运算符的陷阱" class="headerlink" title="复合赋值运算符的陷阱"></a>复合赋值运算符的陷阱</h4><p>Java 语言允许所有的双目运算符和 = 一起结合组成复合赋值运算符，如 +=、-=、*=、/=、%= 、&amp;= 等，复合赋值运算符包含了一个隐式的类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这两条语句不等价</span></span><br><span class="line">a = a + <span class="number">5</span>;<span class="comment">//</span></span><br><span class="line">a += <span class="number">5</span>;<span class="comment">//实际上等价于 a = (a的类型) (a + 5);</span></span><br></pre></td></tr></table></figure><p>复合赋值运算符会自动的将它计算的结果值强制转换为其左侧变量的类型。</p><h3 id="输入法导致的陷阱"><a href="#输入法导致的陷阱" class="headerlink" title="输入法导致的陷阱"></a>输入法导致的陷阱</h3><h3 id="注释的字符必须合法"><a href="#注释的字符必须合法" class="headerlink" title="注释的字符必须合法"></a>注释的字符必须合法</h3><h3 id="转义字符的陷阱"><a href="#转义字符的陷阱" class="headerlink" title="转义字符的陷阱"></a>转义字符的陷阱</h3><ul><li>慎用字符的 Unicode 转义形式</li><li>中止行注释的转义字符</li></ul><h3 id="泛型可能引起的错误"><a href="#泛型可能引起的错误" class="headerlink" title="泛型可能引起的错误"></a>泛型可能引起的错误</h3><h4 id="原始类型变量的赋值"><a href="#原始类型变量的赋值" class="headerlink" title="原始类型变量的赋值"></a>原始类型变量的赋值</h4><ul><li>当程序把一个原始类型的变量赋给一个带有泛型信息的变量时，总是可以通过编译（只是会提示警告信息）</li><li>当程序试图访问带泛型声明的集合的集合元素时，编译器总是把集合元素当成泛型类型处理（它并不关心集合里集合元素的实际类型）</li><li>当程序试图访问带泛型声明的集合的集合元素时，JVM会遍历每个集合元素自动执行强制转型，如果集合元素的实际类型与集合所带的泛型信息不匹配，运行时将引发 ClassCastException</li></ul><h4 id="原始类型带来的擦除"><a href="#原始类型带来的擦除" class="headerlink" title="原始类型带来的擦除"></a>原始类型带来的擦除</h4><p>当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都会丢弃。</p><h4 id="创建泛型数组的陷阱"><a href="#创建泛型数组的陷阱" class="headerlink" title="创建泛型数组的陷阱"></a>创建泛型数组的陷阱</h4><p>Java 中不允许创建泛型数组</p><h3 id="正则表达式的陷阱"><a href="#正则表达式的陷阱" class="headerlink" title="正则表达式的陷阱"></a>正则表达式的陷阱</h3><p>有些符号本身就是正则表达式，我们需要对符号做转义运算。</p><h3 id="多线程的陷阱"><a href="#多线程的陷阱" class="headerlink" title="多线程的陷阱"></a>多线程的陷阱</h3><h4 id="不要调用-run-方法"><a href="#不要调用-run-方法" class="headerlink" title="不要调用 run 方法"></a>不要调用 run 方法</h4><p>开启线程是用 start() 方法，而不是 run() 方法。</p><h4 id="静态的同步方法"><a href="#静态的同步方法" class="headerlink" title="静态的同步方法"></a>静态的同步方法</h4><p>对于同步代码块而言，程序必须显式为它指定同步监视器；对于同步非静态方法而言，该方法的同步监视器是 this —— 即调用该方法的 Java 对象；对于静态的同步方法而言，该方法的同步监视器不是 this，而是该类本身。</p><h2 id="第-6-课-——-流程控制的陷阱"><a href="#第-6-课-——-流程控制的陷阱" class="headerlink" title="第 6 课 —— 流程控制的陷阱"></a>第 6 课 —— 流程控制的陷阱</h2><h3 id="switch-语句陷阱"><a href="#switch-语句陷阱" class="headerlink" title="switch 语句陷阱"></a>switch 语句陷阱</h3><p>break 语句不要忘记写</p><p>switch 的表达式类型：</p><ul><li>byte</li><li>short</li><li>int</li><li>char</li><li>enum</li><li>String （Jdk 1.7 以后有 String）</li></ul><h3 id="标签引起的陷阱"><a href="#标签引起的陷阱" class="headerlink" title="标签引起的陷阱"></a>标签引起的陷阱</h3><p>Java 中的标签通常是和循环中的 break 和 continue 结合使用，让 break 直接终止标签所标识的循环，让 continue 语句忽略标签所标识的循环的剩下语句。</p><p>。。</p><h2 id="第-7-课-——-面向对象的陷阱"><a href="#第-7-课-——-面向对象的陷阱" class="headerlink" title="第 7 课 —— 面向对象的陷阱"></a>第 7 课 —— 面向对象的陷阱</h2><h3 id="instanceof-运算符的陷阱"><a href="#instanceof-运算符的陷阱" class="headerlink" title="instanceof  运算符的陷阱"></a>instanceof  运算符的陷阱</h3><p>instanceof 它用于判断前面的对象是否是后面的类或其子类、实现类的实例。如果是返回 true，否则返回 false。</p><p>instanceof 运算符前面操作数的编译时类型必须是：</p><ul><li>要么与后面的类相同</li><li>要么是后面类的父类</li><li>要么是后面类型的子类</li></ul><h3 id="构造器陷阱"><a href="#构造器陷阱" class="headerlink" title="构造器陷阱"></a>构造器陷阱</h3><p>构造器是 Java 中每个类都会提供的一个“特殊方法”。构造器负责对 Java 对象执行初始化操作，不管是定义实例变量时指定的初始值，还是在非静态初始化代码块中所做的操作，实际上都会被提取到构造器中执行。</p><p>构造器不能声明返回值类型，也不能使用void声明构造器没有返回值。</p><h4 id="构造器创建对象吗"><a href="#构造器创建对象吗" class="headerlink" title="构造器创建对象吗"></a>构造器创建对象吗</h4><p>构造器并不会创建 Java 对象，构造器只是负责执行初始化，在构造器执行之前，Java 对象所需要的内存空间，是由 new 关键字申请出来的。绝大部分时候，程序使用 new 关键字为一个 Java 对象申请空间之后，都需要使用构造器为这个对象执行初始化，但在某些时候，程序创建 Java 对象无需调用构造器，如下：</p><ul><li>使用反序列化的方式恢复 Java 对象</li><li>使用 clone 方法复制 Java 对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 10412 on 2017/5/31.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wolf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用了有参构造方法"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Wolf wolf = (Wolf) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(wolf.name) : wolf.name == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wolf w = <span class="keyword">new</span> Wolf(<span class="string">"灰太狼"</span>);</span><br><span class="line">        System.out.println(<span class="string">"对象创建完成"</span>);</span><br><span class="line">        Wolf w2 = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建输出对象流</span></span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"a.bin"</span>));</span><br><span class="line">            <span class="comment">//创建输入对象流</span></span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"a.bin"</span>));</span><br><span class="line">            <span class="comment">//序列输出java 对象</span></span><br><span class="line">            oos.writeObject(w);</span><br><span class="line">            oos.flush();</span><br><span class="line">            <span class="comment">//反序列化恢复java对象</span></span><br><span class="line">            w2 = (Wolf) ois.readObject();</span><br><span class="line">            System.out.println(w);</span><br><span class="line">            System.out.println(w2);</span><br><span class="line">            <span class="comment">//两个对象的实例变量值完全相等，输出true</span></span><br><span class="line">            System.out.println(w.equals(w2));</span><br><span class="line">            <span class="comment">//两个对象不同，输出false</span></span><br><span class="line">            System.out.println(w == w2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ois!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (oos!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">调用了有参构造方法</span><br><span class="line">对象创建完成</span><br><span class="line">com.zhisheng.test.Wolf@<span class="number">1</span>b15382</span><br><span class="line">com.zhisheng.test.Wolf@<span class="number">1</span>b15382</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>正如结果所示：创建 Wolf 对象时，程序调用了相应的构造器来对该对象执行初始化；当程序通过反序列化机制恢复 Java 对象时，系统无需在调用构造器来进行初始化。通过反序列化恢复出来的 Wolf 对象和原来的 Wolf 对象具有完全相同的实例变量值，但系统会产生两个对象。</p><h4 id="无限递归构造器"><a href="#无限递归构造器" class="headerlink" title="无限递归构造器"></a>无限递归构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstrutionTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ConstrutionTest ct;</span><br><span class="line">    &#123;</span><br><span class="line">        ct = <span class="keyword">new</span> ConstrutionTest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstrutionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConstrutionTest ct = <span class="keyword">new</span> ConstrutionTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果抛出异常 <code>java.lang.StackOverflowError</code></p><p>因为不管定义实例变量时指定的初始值，还是在非静态初始化代码块中执行的初始化操作，最终都将提取到构造器中执行，因为代码中递归调用了类的构造器，最终导致出现 <code>java.lang.StackOverflowError</code> 异常。</p><h3 id="到底调用哪个重载方法"><a href="#到底调用哪个重载方法" class="headerlink" title="到底调用哪个重载方法"></a>到底调用哪个重载方法</h3><p>1、第一阶段 JVM 将会选取所有可获得并匹配调用的方法或者构造器</p><p>2、第二个阶段决定到底要调用哪个方法，此时 JVM 会在第一阶段所选取的方法或者构造器中再次选取最精确匹配的那一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(Object obj, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"obj 参数"</span> + obj);</span><br><span class="line">        System.out.println(<span class="string">"整型参数 "</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(Object[] obj, <span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"obj 参数"</span> + obj);</span><br><span class="line">        System.out.println(<span class="string">"整型参数 "</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverrideTest o = <span class="keyword">new</span> OverrideTest();</span><br><span class="line">        o.info(<span class="keyword">null</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error:(20, 10) java: 对info的引用不明确</span><br><span class="line">  com.zhisheng.test.OverrideTest 中的方法 info(java.lang.Object,int) 和 com.zhisheng.test.OverrideTest 中的方法 info(java.lang.Object[],double) 都匹配</span><br></pre></td></tr></table></figure><p>在这种复杂的条件下，JVM 无法判断哪个方法更匹配实际调用，将会导致程序编译错误。</p><h3 id="方法重写的陷阱"><a href="#方法重写的陷阱" class="headerlink" title="方法重写的陷阱"></a>方法重写的陷阱</h3><p>无法重写父类 private 方法。如果子类有一个与父类 private 方法具有相同方法名、相同形参列表、相同返回值类型的方法，依然不是重写，只是子类定义了一个与父类相同的方法。</p><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>static 可以修饰类中定义的成员：field、方法、内部类、初始化代码块、内部枚举类</p><h4 id="静态方法属于类"><a href="#静态方法属于类" class="headerlink" title="静态方法属于类"></a>静态方法属于类</h4><p>被 static 修饰的成员（field、方法、内部类、初始化块、内部枚举类）属于类本身，而不是单个的 Java 对象。静态方法也是属于类。</p><h2 id="第-8-课-——-异常捕捉的陷阱"><a href="#第-8-课-——-异常捕捉的陷阱" class="headerlink" title="第 8 课 —— 异常捕捉的陷阱"></a>第 8 课 —— 异常捕捉的陷阱</h2><h3 id="正确关闭资源的方式"><a href="#正确关闭资源的方式" class="headerlink" title="正确关闭资源的方式"></a>正确关闭资源的方式</h3><ul><li>使用 finally 块来保证回收，保证关闭操作总是会被执行</li><li>关闭每个资源之前首先保证引用该资源的引用变量不为 null</li><li>为每个物理资源单独使用 try .. catch 块关闭资源，保证关闭资源时引发的异常不会影响其他资源的关闭。</li></ul><h3 id="finally-块陷阱"><a href="#finally-块陷阱" class="headerlink" title="finally 块陷阱"></a>finally 块陷阱</h3><p>finally 执行顺序，看我以前写的一篇文章<a href="http://www.54tianzhisheng.cn/2017/03/28/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%A9%B6Java%20%E4%B8%AD%20finally%20%E8%AF%AD%E5%8F%A5%E5%9D%97/" target="_blank" rel="noopener">《深度探究Java 中 finally 语句块》</a>。</p><h3 id="catch-块用法"><a href="#catch-块用法" class="headerlink" title="catch 块用法"></a>catch 块用法</h3><p>在 try 块后使用 catch 块来捕获多个异常时，程序应该小心多个 catch 块之间的顺序：捕获父类异常的 catch 块都应该排在捕获子类异常的 catch 块之后（先处理小异常，再处理大异常），否则出现编译错误。</p><h3 id="继承得到的异常"><a href="#继承得到的异常" class="headerlink" title="继承得到的异常"></a>继承得到的异常</h3><p>子类重写父类方法时，不能声明抛出比父类方法类型更多、范围更大的异常。</p><p>二叉树性质：</p><ul><li><p>二叉树第 i 层上的节点数目至多为 2 ^(i - 1)   (i &gt;= 1)</p></li><li><p>深度为 k 的二叉树至多有 2 ^ k - 1 个节点</p></li><li><p>在任何一颗二叉树中，如果其叶子结点的数量为 n0，度为 2 的子节点数量为 n2，则 n0 = n2 + 1</p></li><li><p>具有 n 个节点的完全二叉树的深度为 log n   +  1   (log 的底为 2)</p></li><li><p>对于一棵有 n 个节点的完全二叉树的节点按层自左向右编号，则对任一编号为 i 的节点有如下性质：</p><p>当 i == 1 时，节点 i 是二叉树的根；若 i &gt; 1 时，则节点的父节点是 i/2</p><p>当 2i &lt;= n，则节点 i 有左孩子，左孩子的编号是 2i，否则，节点无左孩子，并且是叶子结点</p><p>若 2i + 1 &lt;= n ，则节点 i 有右孩子，右孩子的编号是 2i + 1；否则，节点无右孩子。</p></li><li><p>对于一颗 n 个节点的完全二叉树的节点按层自左向右编号，1 ~ n/2 范围的节点都是有孩子节点的非叶子结点，其余的节点全部都是叶子结点。编号为 n/2 的节点有可能只有左节点，也可能既有左节点，又有右节点。</p></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h4><p>需要经过 n - 1 趟比较</p><p>第一趟比较：程序将记录定位在第一个数据上，拿第一个数据依次和它后面的每个数据进行比较，如果第一个数据大于后面某个数据，交换它们。。依此类推，经过第一趟比较，这组数据中最小的数据被选出来，它被排在第一位。</p><p>第二趟比较：程序将记录定位在第二个数据上，拿第二个数据依次和它后面每个数据进行比较，如果第二个数据大于后面某个数据，交换它们。。依次类推，经过第二趟比较，这组数据中第二小的数据被选出，它排在第二位</p><p>。。</p><p>按此规则一共进行 n-1 趟比较，这组数据中第 n - 1小（第二大）的数据被选出，被排在第 n -1 位（倒数第一位）；剩下的就是最大的数据，它排在最后。</p><p>直接选择排序的优点就是算法简单，容易实现，缺点就是每趟只能确定一个元素，n个数组需要进行 n-1 趟比较。</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li>建堆</li><li>拿堆的根节点和最后一个节点交换</li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>第一趟：依次比较0和1，1和2，2和3 … n-2 和 n - 1 索引的元素，如果发现第一个数据大于后一个数据，交换它们，经过第一趟，最大的元素排到了最后。</p><p>第二趟：依次比较0和1，1和2，2和3 … n-3 和 n - 2 索引的元素，如果发现第一个数据大于后一个数据，交换它们，经过第二趟，第二大的元素排到了倒数第二位</p><p>。。</p><p>第 n -1 趟：依次比较0和1元素，如果发现第一个数据大于后一个数据，交换它们，经过第 n - 1 趟，第二小的元素排到了第二位。</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>从待排的数据序列中任取一个数据作为分界值，所有比它小的数据元素一律放在左边，所有比他大的元素一律放在右边，这样一趟下来，该序列就分成了两个子序列，接下来对两个子序列进行递归，直到每个子序列只剩一个，排序完成。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>依次将待排序的数据元素按其关键字值的大小插入前面的有序序列。</p><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>当第 i - 1 趟需要将第 i 个元素插入前面的 0 ~ i -1 个元素序列中时：</p><ul><li>计算 0 ~ i - 1 索引的中间点，也就是用 i 索引处的元素和 （0 + i - 1）/2 索引处的元素进行比较，如果 i 索引处的元素大，就直接在 （（0 + i - 1）/2 ） ~ （i - 1）后半个范围内进行搜索，反之在前半个范围搜索。</li><li>重复上面步骤</li><li>确定第 i 个元素的插入位置，就将该位置的后面所有元素整体后移一位，然后将第 i 个元素放入该位置。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第-1-课-——-数组与内存控制&quot;&gt;&lt;a href=&quot;#第-1-课-——-数组与内存控制&quot; class=&quot;headerlink&quot; title=&quot;第 1 课 —— 数组与内存控制&quot;&gt;&lt;/a&gt;第 1 课 —— 数组与内存控制&lt;/h2&gt;&lt;h3 id=&quot;数组初始化&quot;&gt;&lt;a href=&quot;#数组初始化&quot; class=&quot;headerlink&quot; title=&quot;数组初始化&quot;&gt;&lt;/a&gt;数组初始化&lt;/h3&gt;&lt;p&gt;数组初始化之后，该数组的长度是不可变的（可通过数组的 length 属性访问数组的长度）。Java 中的数组必须经过初始化（为数组对象的元素分配内存空间，并为每个数组元素指定初始值）才可使用。&lt;/p&gt;
&lt;p&gt;数组初始化的形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化：初始化时由程序员显示的指定每个数组的初始值，系统决定数组长度。&lt;/li&gt;
&lt;li&gt;动态初始化：初始化时程序员只指定数组的长度，系统为数组元素分配初始值。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>秋招第一站 —— 亚信科技</title>
    <link href="http://yoursite.com/2018/01/21/yaxin/"/>
    <id>http://yoursite.com/2018/01/21/yaxin/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第-1-站、亚信科技-Java-开发"><a href="#第-1-站、亚信科技-Java-开发" class="headerlink" title="第 1 站、亚信科技    Java 开发"></a>第 1 站、亚信科技    Java 开发</h3><p>1）自我介绍（说到一个亮点：长期坚持写博客，面试官觉得这个习惯很好，算加分项吧）</p><p>2）看到简历项目中用到 Solr，详细的问了下 Solr（自己介绍了下 Solr 的使用场景和建立索引等东西）<br><a id="more"></a><br>3）项目里面写了一个 “ 敏感词和 JS 标签过滤防 XSS 攻击”，面试官让我讲了下这个 XSS 攻击，并且是怎样实现的</p><p>4）项目里写了支持 Markdown，问是不是自己写的解析代码，（回答不是，自己引用的是 GitHub上的一个开源项目解析的）</p><p>5）想问我前端的知识，我回复到：自己偏后端开发，前端只是了解，然后面试官就不问了</p><p>6）问我考不考研？</p><p>7）觉得杭州怎么样？是打算就呆在杭州还是把杭州作为一个跳板？</p><p>8）有啥小目标？以后是打算继续技术方向，还是先技术后管理（还开玩笑的说：是不是赚他几个亿，当时我笑了笑）</p><p>9）有啥兴趣爱好？</p><p>大概就记得这么多了，目前已经拿到 Offer 了。</p><p><strong>总结</strong>：面试问的问题不算多，主要是通过简历上项目所涉及的东西提问的，如果自己不太会的切记不要写上去。面试主要考察你回答问题来判断你的逻辑是否很清楚。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第-1-站、亚信科技-Java-开发&quot;&gt;&lt;a href=&quot;#第-1-站、亚信科技-Java-开发&quot; class=&quot;headerlink&quot; title=&quot;第 1 站、亚信科技    Java 开发&quot;&gt;&lt;/a&gt;第 1 站、亚信科技    Java 开发&lt;/h3&gt;&lt;p&gt;1）自我介绍（说到一个亮点：长期坚持写博客，面试官觉得这个习惯很好，算加分项吧）&lt;/p&gt;
&lt;p&gt;2）看到简历项目中用到 Solr，详细的问了下 Solr（自己介绍了下 Solr 的使用场景和建立索引等东西）&lt;br&gt;
    
    </summary>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>实习圈群里提问小记</title>
    <link href="http://yoursite.com/2018/01/21/wx-01/"/>
    <id>http://yoursite.com/2018/01/21/wx-01/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/p2.jpeg-1" alt=""></p><a id="more"></a><p><img src="http://ohfk1r827.bkt.clouddn.com/wx-01.png-1" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/p2.jpeg-1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="实习圈" scheme="http://yoursite.com/tags/%E5%AE%9E%E4%B9%A0%E5%9C%88/"/>
    
  </entry>
  
  <entry>
    <title>为什么要重新运营以前的公众号呢？</title>
    <link href="http://yoursite.com/2018/01/21/weixin/"/>
    <id>http://yoursite.com/2018/01/21/weixin/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/mL5G5acdd4.png-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>老读者可能会发现现在我的公众号已经改名了。（由 “猿blog”  变成  “zhisheng” 了，细心的童鞋会发现不仅名字变了， ID 也变了，但是图片还没改，暂时还没想到好的 logo 图片），下面说说为啥吧！<br><a id="more"></a></p><h3 id="听我瞎-BB"><a href="#听我瞎-BB" class="headerlink" title="听我瞎 BB"></a>听我瞎 BB</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/k1a984Emlc.png-1" alt="mark"></p><p>上图是两年前公众号群发的第一条信息，那时自己还是在学校，如今已经进入了社会，在公司实习了。记得当初开这个公众号的原因是因为几个年轻人有着梦想，打算一起做点东西，当时一腔热血的自己立马就先申请了个公众号，后来 “东西” 倒是没做，反倒是我自己慢慢的在微信公众号分享一些文章，然后那时自己也写博客（算算自己写博客应该快三年了，坚持真不易啊），所以偶尔也把自己的博客分享在微信公众号上。</p><p>但是好景不长，那时的微信公众号排版真尼玛难用的一批，作为一个理工科的男生，本来自己做事一般细心和耐心，无奈，把这么好的一个童鞋都给逼坏了。我现在还是得吐槽下，如今的微信公众号后台排版还是那么差。但是可能因为需求比较多了，所以就有人做出了工具（将 markdown 排版后在将整个样式复制粘贴到微信公众号后台），这样一篇排版还算不错的博客就出来了。</p><p>自己早就知道了这么个工具，以前看 DD 的博客的时候就发现了这个工具，但是很久没更新的微信公众号，自己也不怎么想再管理。</p><p>有人就要问了？那为啥现在又要开始跟新了呢？</p><p>我只想说：“贱人就是矫情！！！又想瞎折腾下。”，反正自己的博客也在不断的更新，偶尔顺带把文章同步到微信公众号其实也是可以的。在学校的时候时间比较多，那时真的是时间比较多，后悔没好好坚持运营下来。现在工作了，自己工作之外的时间较少，除了学习，偶尔写写博客，娱乐时间比较少，都是大学时宅的。</p><p>前段时间被人 “忽悠” 说继续更新公众号，那时刚好也快 2018 年了，自己也想给自己定几个目标，在元旦的那天，想想还是继续更新微信公众号吧，所以你也看得到最近我的更新了，可能最近的更新比较有规律，因为这些文章大部分是之前就已经写好了的，已经发过在我的博客里了。估计把这些文章更新完后，就不会每天都更新我自己的文章了。</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>说下微信公众号的定位吧：</p><p>1、我的技术博客应该都会同步在这里的。</p><p>2、分享自己平时的随笔文章。（比如这篇。。。）</p><p>3、除了技术文章，当然还有平时自己的 奇淫技巧 （包括但不限于写作方式、推荐好用的软件等）</p><p>4、分享自己觉得不错的文章（别人的，尽量征得同意，一定会备注原创地址的）</p><p>5、如果你也写博客，但是阅读量很小的话，可以考虑自荐。（注：文章我可能会审批，必须要觉得不错的文章）</p><p>6、分享一些学习视频和书籍</p><p>7、后期可能会搞工作内推</p><p>。。。</p><p>暂时只想到这些了</p><h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h3><p>因为工作了，所以时间少，运营这微信公众号可能需要花费我不少工作之外的时间。</p><p>如果可以的话，我希望能找到一个能帮我分担点的朋友。</p><p>注：<strong>无偿的，如果介意的话，下面就不用再看了。</strong></p><hr><p>说点简单的要求吧：</p><p>1、细心、耐心的 boy  or  girl 都行</p><p>2、起码要知道点编程方面的知识</p><p>3、能坚持下来</p><p>4、对新技术有敏感的嗅觉</p><p>5、最后一点就是你要有点时间了，希望不耽误你学习</p><p>再说下能给你带来的 <strong>好处</strong> 吧：</p><p>1、肯定能增加你的运营能力（再去互联网公司投运营岗位会有优势的）</p><p>2、本人一开始会亲自教授该怎么做，所以没经验的朋友不用担心</p><p>3、可以增加和大牛勾搭的机会，你们懂的。。</p><p>4、本人可以亲自传授经验（编程和生活点滴经验）</p><p><strong>如果你有意愿的话，请加我 QQ ： 1041218129  聊聊吧</strong></p><hr><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180103/mL5G5acdd4.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;老读者可能会发现现在我的公众号已经改名了。（由 “猿blog”  变成  “zhisheng” 了，细心的童鞋会发现不仅名字变了， ID 也变了，但是图片还没改，暂时还没想到好的 logo 图片），下面说说为啥吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>基于 Harbor 搭建 Docker 私有镜像仓库</title>
    <link href="http://yoursite.com/2018/01/21/Docker-harbor/"/>
    <id>http://yoursite.com/2018/01/21/Docker-harbor/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171126/j9de1Jf6m0.png-1" alt="mark"></p><h3 id="什么是-Harbor？"><a href="#什么是-Harbor？" class="headerlink" title="什么是 Harbor？"></a>什么是 Harbor？</h3><p>第一次使用这个的时候是刚进公司处理的第一个任务的时候，发现 Harbor 就是一个用于存储和分发 Docker 镜像的企业级Registry 服务器。<br><a id="more"></a><br>网上找到一个 Harbor 的架构图：</p><p><img src="http://img.blog.csdn.net/20170912121921883?/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDI3ODkyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>Harbor 是 VMware 公司开源的企业级 DockerRegistry 项目，项目地址为 <a href="https://github.com/vmware/harbor。其目标是帮助用户迅速搭建一个企业级的" target="_blank" rel="noopener">https://github.com/vmware/harbor。其目标是帮助用户迅速搭建一个企业级的</a> Docker registry 服务。它以 Docker 公司开源的 registry 为基础，提供了管理UI，基于角色的访问控制(Role Based Access Control)，AD/LDAP集成、以及审计日志(Auditlogging) 等企业用户需求的功能，同时还原生支持中文。Harbor 的每个组件都是以 Docker 容器的形式构建的，使用 Docker Compose 来对它进行部署。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1、自己在腾讯云买的服务器（CentOS7.3）</p><p>2、Docker 版本：17.05.0-ce</p><p>3、Docker-compose：1.17.1</p><p>4、Harbor：1.1.2</p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>因为系统是 CentOS 7.3 ，内核啥的都已经是 3.10，所以不用担心内核升级的问题，一些操作啥的在 7.x 上操作也很方便。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">yum  update                             //系统版本更新</span><br><span class="line"></span><br><span class="line">vim /etc/yum.repos.d/docker.repo        //添加以下内容</span><br><span class="line"></span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/7/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line"></span><br><span class="line">//下面安装 Docker 引擎</span><br><span class="line">yum install docker-engine  -y</span><br><span class="line"></span><br><span class="line">//安装docker引擎，此步也可作为更新docker版本的操作：先#systemctl stop docker 停止docker服务，再#yum install docker-engine 更新docker版本</span><br><span class="line"></span><br><span class="line">systemctl  enable  docker.service</span><br><span class="line"></span><br><span class="line">systemctl  start   docker              //启动docker守护进程</span><br><span class="line"></span><br><span class="line">docker info                            //查看docker运行情况</span><br><span class="line"></span><br><span class="line">docker -v//查看版本信息</span><br></pre></td></tr></table></figure><p>修改 Docker 配置文件 /etc/default/docker 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS="--registry-mirror=http://aad0405c.m.daocloud.io"//换成国内的镜像加速源，不然拉取镜像简直龟速，不想在吐槽了</span><br></pre></td></tr></table></figure><p>使用 <code>service docker restart</code> 重启 Docker 服务即可。</p><p>或者用官方提供的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://ef017c13.m.daocloud.io</span><br></pre></td></tr></table></figure><h3 id="安装-Docker-compose"><a href="#安装-Docker-compose" class="headerlink" title="安装 Docker-compose"></a>安装 Docker-compose</h3><p>如果是想直接命令安装也行，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">下载指定版本的docker-compose</span><br><span class="line"></span><br><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">对二进制文件赋可执行权限</span><br><span class="line"></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">测试下docker-compose是否安装成功</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br><span class="line"></span><br><span class="line">出现如下</span><br><span class="line">docker-compose version 1.17.1, build 6d101fb</span><br></pre></td></tr></table></figure><p>但是，这种方法简直龟速，幸好还有种方法，</p><p>见这里：<a href="https://docs.docker.com/compose/install/#install-compose" target="_blank" rel="noopener">https://docs.docker.com/compose/install/#install-compose</a></p><p>这种需要通过 Python 的 pip 安装</p><h4 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-1.4.2.tar.gz</span><br><span class="line"></span><br><span class="line">tar -vxf setuptools-1.4.2.tar.gz</span><br><span class="line"></span><br><span class="line">cd setuptools-1.4.2</span><br><span class="line"></span><br><span class="line">python2.7 setup.py install//因为服务器自带 Python 2.7</span><br><span class="line"></span><br><span class="line">easy_install-2.7 pip</span><br></pre></td></tr></table></figure><h4 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker compose"></a>安装 docker compose</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose --version//测试安装是否成功</span><br></pre></td></tr></table></figure><h3 id="安装-Harbor"><a href="#安装-Harbor" class="headerlink" title="安装 Harbor"></a>安装 Harbor</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/vmware/harbor/releases/download/v1.1.2/harbor-offline-installer-v1.1.2.tgz</span><br><span class="line"></span><br><span class="line">离线安装包,也是龟速，把这个下载链接用迅雷下载，速度却贼快，嘿嘿，然后再传到服务器上去，整个过程快很多！</span><br><span class="line"></span><br><span class="line">tar -zxvf harbor-offline-installer-v1.1.2.tgz</span><br></pre></td></tr></table></figure><p>解压缩之后，进入目录下会看到 harbor.cfg 文件，该文件就是 Harbor 的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">## Configuration file of Harbor</span><br><span class="line"></span><br><span class="line"># hostname设置访问地址，可以使用ip、域名，不可以设置为127.0.0.1或localhost</span><br><span class="line">hostname = 115.159.227.249   #这里我先配置我的服务器IP地址</span><br><span class="line"></span><br><span class="line"># 访问协议，默认是http，也可以设置https，如果设置https，则nginx ssl需要设置on</span><br><span class="line">ui_url_protocol = http</span><br><span class="line"></span><br><span class="line"># mysql数据库root用户默认密码root123，实际使用时修改下</span><br><span class="line">db_password = root123</span><br><span class="line"></span><br><span class="line">#Maximum number of job workers in job service</span><br><span class="line">max_job_workers = 3</span><br><span class="line"></span><br><span class="line">#Determine whether or not to generate certificate for the registry&apos;s token.</span><br><span class="line">#If the value is on, the prepare script creates new root cert and private key</span><br><span class="line">#for generating token to access the registry. If the value is off the default key/cert will be used.</span><br><span class="line">#This flag also controls the creation of the notary signer&apos;s cert.</span><br><span class="line">customize_crt = on</span><br><span class="line"></span><br><span class="line">#The path of cert and key files for nginx, they are applied only the protocol is set to https</span><br><span class="line">ssl_cert = /data/cert/server.crt</span><br><span class="line">ssl_cert_key = /data/cert/server.key</span><br><span class="line"></span><br><span class="line">#The path of secretkey storage</span><br><span class="line">secretkey_path = /data</span><br><span class="line"></span><br><span class="line">#Admiral&apos;s url, comment this attribute, or set its value to NA when Harbor is standalone</span><br><span class="line">admiral_url = NA</span><br><span class="line"></span><br><span class="line">#NOTES: The properties between BEGIN INITIAL PROPERTIES and END INITIAL PROPERTIES</span><br><span class="line">#only take effect in the first boot, the subsequent changes of these properties</span><br><span class="line">#should be performed on web ui</span><br><span class="line"></span><br><span class="line">#************************BEGIN INITIAL PROPERTIES************************</span><br><span class="line"></span><br><span class="line">#Email account settings for sending out password resetting emails.</span><br><span class="line"></span><br><span class="line">#Email server uses the given username and password to authenticate on TLS connections to host and act as identity.</span><br><span class="line">#Identity left blank to act as username.</span><br><span class="line">email_identity =</span><br><span class="line"></span><br><span class="line">email_server = smtp.mydomain.com</span><br><span class="line">email_server_port = 25</span><br><span class="line">email_username = sample_admin@mydomain.com</span><br><span class="line">email_password = abc</span><br><span class="line">email_from = admin &lt;sample_admin@mydomain.com&gt;</span><br><span class="line">email_ssl = false</span><br><span class="line"></span><br><span class="line">##The initial password of Harbor admin, only works for the first time when Harbor starts.</span><br><span class="line">#It has no effect after the first launch of Harbor.</span><br><span class="line"># 启动Harbor后，管理员UI登录的密码，默认是Harbor12345</span><br><span class="line">harbor_admin_password = Harbor12345</span><br><span class="line"></span><br><span class="line"># 认证方式，这里支持多种认证方式，如LADP、本次存储、数据库认证。默认是db_auth，mysql数据库认证</span><br><span class="line">auth_mode = db_auth</span><br><span class="line"></span><br><span class="line">#The url for an ldap endpoint.</span><br><span class="line">ldap_url = ldaps://ldap.mydomain.com</span><br><span class="line"></span><br><span class="line">#A user&apos;s DN who has the permission to search the LDAP/AD server.</span><br><span class="line">#If your LDAP/AD server does not support anonymous search, you should configure this DN and ldap_search_pwd.</span><br><span class="line">#ldap_searchdn = uid=searchuser,ou=people,dc=mydomain,dc=com</span><br><span class="line"></span><br><span class="line">#the password of the ldap_searchdn</span><br><span class="line">#ldap_search_pwd = password</span><br><span class="line"></span><br><span class="line">#The base DN from which to look up a user in LDAP/AD</span><br><span class="line">ldap_basedn = ou=people,dc=mydomain,dc=com</span><br><span class="line"></span><br><span class="line">#Search filter for LDAP/AD, make sure the syntax of the filter is correct.</span><br><span class="line">#ldap_filter = (objectClass=person)</span><br><span class="line"></span><br><span class="line"># The attribute used in a search to match a user, it could be uid, cn, email, sAMAccountName or other attributes de</span><br><span class="line">pending on your LDAP/AD  ldap_uid = uid</span><br><span class="line"></span><br><span class="line">#the scope to search for users, 1-LDAP_SCOPE_BASE, 2-LDAP_SCOPE_ONELEVEL, 3-LDAP_SCOPE_SUBTREE</span><br><span class="line">ldap_scope = 3</span><br><span class="line"></span><br><span class="line">#Timeout (in seconds)  when connecting to an LDAP Server. The default value (and most reasonable) is 5 seconds.</span><br><span class="line">ldap_timeout = 5</span><br><span class="line"></span><br><span class="line"># 是否开启自注册</span><br><span class="line">self_registration = on</span><br><span class="line"></span><br><span class="line"># Token有效时间，默认30分钟</span><br><span class="line">token_expiration = 30</span><br><span class="line"></span><br><span class="line"># 用户创建项目权限控制，默认是everyone（所有人），也可以设置为adminonly（只能管理员）</span><br><span class="line">project_creation_restriction = everyone</span><br><span class="line"></span><br><span class="line">#Determine whether the job service should verify the ssl cert when it connects to a remote registry.</span><br><span class="line">#Set this flag to off when the remote registry uses a self-signed or untrusted certificate.</span><br><span class="line">verify_remote_cert = on</span><br><span class="line">#************************END INITIAL PROPERTIES************************</span><br></pre></td></tr></table></figure><p>启动 harbor，修改完配置文件后，在的当前目录执行<code>./install.sh</code>，Harbor服务就会根据当期目录下的<code>docker-compose.yml</code>开始下载依赖的镜像，检测并按照顺序依次启动各个服务。</p><p>启动完成后，我们访问刚设置的 hostname 即可，<a href="http://115.159.227.249/，默认是80端口，如果端口占用，我们可以去修改docker-compose.yml文件中，对应服务的端口映射。" target="_blank" rel="noopener">http://115.159.227.249/，默认是80端口，如果端口占用，我们可以去修改docker-compose.yml文件中，对应服务的端口映射。</a></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171126/JgL96AjdEc.jpg-1" alt="mark"></p><p>登录 Web Harbor , 输入用户名 admin，默认密码（或已修改密码）登录系统。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171126/b98k9d2jcE.png-1" alt="mark"></p><p>我们可以看到系统各个模块如下：</p><ul><li>项目：新增/删除项目，查看镜像仓库，给项目添加成员、查看操作日志、复制项目等</li><li>日志：仓库各个镜像create、push、pull等操作日志</li><li>系统管理<ul><li>用户管理：新增/删除用户、设置管理员等</li><li>复制管理：新增/删除从库目标、新建/删除/启停复制规则等</li><li>配置管理：认证模式、复制、邮箱设置、系统设置等</li></ul></li><li>其他设置<ul><li>用户设置：修改用户名、邮箱、名称信息</li><li>修改密码：修改用户密码</li></ul></li></ul><p>注意：非系统管理员用户登录，只能看到有权限的项目和日志，其他模块不可见。</p><p>我们要尝试下能不能把自己 Docker 里面的镜像 push 到 Harbor 的 library 里来（默认这个 library 项目是公开的，所有人都可以有读的权限，都不需要 docker login 进来，就可以拉取里面的镜像）。</p><p><strong>注意：</strong></p><p>为了后面留坑，我这里先 在自己的 docker.service 中添加仓库：（这是个坑，建议你先按照我说的做，不然下面可能会一直登录不上）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">里面的这行修改为：（其实就是添加 --insecure-registry 115.159.227.249 ）</span><br><span class="line">ExecStart=/usr/bin/dockerd --insecure-registry 115.159.227.249</span><br></pre></td></tr></table></figure><p>添加完了后重新启动 docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload &amp;&amp; systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure><p>启动 docker 服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><p>登录：（为了测试下能否登录成功）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">admin登录</span><br><span class="line">$ docker login 115.159.227.249</span><br><span class="line">Username: admin</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><p>打 tag 并 push</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu:15.10  115.159.227.249/library/ubuntu:15.10//给我的镜像打个 tag</span><br><span class="line"></span><br><span class="line">docker push  115.159.227.249/library/ubuntu</span><br><span class="line"></span><br><span class="line">The push refers to a repository [115.159.227.249/library/ubuntu]</span><br><span class="line">98d59071f692: Pushed</span><br><span class="line">af288f00b8a7: Pushed</span><br><span class="line">4b955941a4d0: Pushed</span><br><span class="line">f121afdbbd5d: Pushed</span><br><span class="line">15.10: digest: sha256:ec89c4a90f45f5e103860191890f48d8379e0504a2881ff706aef0768dc0321b size: 1150</span><br></pre></td></tr></table></figure><p>上传完毕后，登录Web Harbor，选择项目 library，就可以看到我刚 push 的镜像了。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171126/0d82GLa1Cb.png-1" alt="mark"></p><p>同理，你也可以测试下从 Harbor pull 镜像到你的 Docker 中去，这里就不继续演示了。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明地址为：<a href="http://www.54tianzhisheng.cn/2017/11/26/Docker-harbor/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/11/26/Docker-harbor/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/171126/j9de1Jf6m0.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是-Harbor？&quot;&gt;&lt;a href=&quot;#什么是-Harbor？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Harbor？&quot;&gt;&lt;/a&gt;什么是 Harbor？&lt;/h3&gt;&lt;p&gt;第一次使用这个的时候是刚进公司处理的第一个任务的时候，发现 Harbor 就是一个用于存储和分发 Docker 镜像的企业级Registry 服务器。&lt;br&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>ELK 实时日志分析平台环境搭建</title>
    <link href="http://yoursite.com/2018/01/21/ELK/"/>
    <id>http://yoursite.com/2018/01/21/ELK/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171225/82lhH8E4Hk.jpg-1" alt="mark"></p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>ELK（ElasticSearch, Logstash, Kibana），三者组合在一起搭建实时的日志分析平台，目前好多公司都是这套！<br><a id="more"></a></p><ul><li>Elasticsearch 是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful 风格接口，多数据源，自动搜索负载等。</li><li>Logstash 是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</li><li>Kibana 也是一个开源和免费的工具，它 Kibana 可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</li></ul><h3 id="安装-ES"><a href="#安装-ES" class="headerlink" title="安装 ES"></a>安装 ES</h3><p>。。。这个省略，不 bb 了，以前写过。。。传送门：<a href="http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/</a></p><h3 id="安装-Logstash"><a href="#安装-Logstash" class="headerlink" title="安装 Logstash"></a>安装 Logstash</h3><p>ELK 整套环境搭建版本很关键，最好全统一一个版本，否则出啥问题就不太好找了。这是我见过版本统一最严格的了。而已 ES 版本升了后，其他的都要都要升级，包括其插件。升级代价挺大的，最好一开始就定位好要安装哪个版本！</p><p>在官网下好安装包后传到 Linux 上，这是速度最快的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">在 /usr/local 目录下解压：</span><br><span class="line"></span><br><span class="line">tar -zxvf  logstash-5.5.2.tar.gz</span><br><span class="line"></span><br><span class="line">进入解压后的目录：</span><br><span class="line"></span><br><span class="line">cd /usr/local/logstash-5.5.2/bin</span><br><span class="line"></span><br><span class="line">新增配置文件：</span><br><span class="line"></span><br><span class="line">vim logstash.conf</span><br><span class="line"></span><br><span class="line">增加：</span><br><span class="line"></span><br><span class="line">input&#123;</span><br><span class="line">    file&#123;</span><br><span class="line">      path =&gt; [&quot;/var/log/*.log&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">   elasticsearch&#123;</span><br><span class="line">       hosts =&gt; [&quot;192.168.153.135:9200&quot;]</span><br><span class="line">       index =&gt; &quot;logstash__log&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Logstash 的启动方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 /usr/local/logstash-5.5.2/bin 目录下运行：</span><br><span class="line"></span><br><span class="line">./logstash -f logstash.conf</span><br></pre></td></tr></table></figure><h3 id="安装-Kibana"><a href="#安装-Kibana" class="headerlink" title="安装 Kibana"></a>安装 Kibana</h3><p>同样，官网下好安装包，上传到 Linux。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解压：</span><br><span class="line"></span><br><span class="line">tar -zxvf kibana-5.5.2-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">修改配置文件 kibana-5.5.2/config/kibana.yml 如下：</span><br><span class="line"></span><br><span class="line">Server.host  //配置机器ip/hostname</span><br><span class="line"></span><br><span class="line">Server.name  //此kibana服务的名称</span><br><span class="line"></span><br><span class="line">elasticsearch.url  //es master节点url</span><br></pre></td></tr></table></figure><p>Kibana 启动方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 /usr/local/kibana-5.5.2/bin 目录下运行：</span><br><span class="line"></span><br><span class="line">./kibana</span><br></pre></td></tr></table></figure><p>Web界面访问: <a href="http://ip:5601" target="_blank" rel="noopener">http://ip:5601</a> 此时需要输入用户名和密码登录,默认分别是 elastic 和 changeme</p><h3 id="X-Pack"><a href="#X-Pack" class="headerlink" title="X-Pack"></a>X-Pack</h3><p>X-Pack 是一个 Elastic Stack 的扩展，将安全，警报，监控，报告和图形功能包含在一个易于安装的软件包中。</p><p>ES 和 Kibana 都可安装。</p><p>插件 x-pack-5.5.2.zip  依旧官网下。</p><h4 id="ES-安装-X-Pack"><a href="#ES-安装-X-Pack" class="headerlink" title="ES 安装 X-Pack"></a>ES 安装 X-Pack</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/elasticsearch/bin</span><br><span class="line"></span><br><span class="line">./elasticsearch-plugin install file:///opt/es/x-pack-5.5.2.zip</span><br></pre></td></tr></table></figure><p>如果成功：显示如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 bin]# ./elasticsearch-plugin install file:///opt/es/x-pack-5.5.2.zip</span><br><span class="line">-&gt; Downloading file:///opt/es/x-pack-5.5.2.zip</span><br><span class="line">[=================================================] 100%</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@     WARNING: plugin requires additional permissions     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">* java.io.FilePermission \\.\pipe\* read,write</span><br><span class="line">* java.lang.RuntimePermission accessClassInPackage.com.sun.activation.registries</span><br><span class="line">* java.lang.RuntimePermission getClassLoader</span><br><span class="line">* java.lang.RuntimePermission setContextClassLoader</span><br><span class="line">* java.lang.RuntimePermission setFactory</span><br><span class="line">* java.security.SecurityPermission createPolicy.JavaPolicy</span><br><span class="line">* java.security.SecurityPermission getPolicy</span><br><span class="line">* java.security.SecurityPermission putProviderProperty.BC</span><br><span class="line">* java.security.SecurityPermission setPolicy</span><br><span class="line">* java.util.PropertyPermission * read,write</span><br><span class="line">* java.util.PropertyPermission sun.nio.ch.bugLevel write</span><br><span class="line">* javax.net.ssl.SSLPermission setHostnameVerifier</span><br><span class="line">See http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.html</span><br><span class="line">for descriptions of what these permissions allow and the associated risks.</span><br><span class="line"></span><br><span class="line">Continue with installation? [y/N]y</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@        WARNING: plugin forks a native controller        @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">This plugin launches a native controller that is not subject to the Java</span><br><span class="line">security manager nor to system call filters.</span><br><span class="line"></span><br><span class="line">Continue with installation? [y/N]y</span><br><span class="line">-&gt; Installed x-pack</span><br></pre></td></tr></table></figure><h4 id="Kibana-安装-X-Pack"><a href="#Kibana-安装-X-Pack" class="headerlink" title="Kibana 安装 X-Pack"></a>Kibana 安装 X-Pack</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/kibana-5.5.2/bin</span><br><span class="line"></span><br><span class="line">./kibana-plugin install file:///opt/es/x-pack-5.5.2.zip</span><br></pre></td></tr></table></figure><p>安装成功如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 bin]# ./kibana-plugin install file:///opt/es/x-pack-5.5.2.zip</span><br><span class="line">Attempting to transfer from file:///opt/es/x-pack-5.5.2.zip</span><br><span class="line">Transferring 159867054 bytes....................</span><br><span class="line">Transfer complete</span><br><span class="line">Retrieving metadata from plugin archive</span><br><span class="line">Extracting plugin archive</span><br><span class="line">Extraction complete</span><br><span class="line">Optimizing and caching browser bundles...</span><br><span class="line">Plugin installation complete</span><br></pre></td></tr></table></figure><h4 id="启用-x-pack-安全机制"><a href="#启用-x-pack-安全机制" class="headerlink" title="启用 x-pack 安全机制"></a>启用 x-pack 安全机制</h4><p>分别在 kibana.yml 和 elasticsearch.yml 中加入下行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpack.security.enabled: true</span><br></pre></td></tr></table></figure><p>这样后，你再打开 ES 的 head 界面和 Kibana 管理界面就需要输入账号密码了。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171225/i8ebl0jgLl.png-1" alt="mark"></p><p>上图右边是安装 X-Pack 后的，功能多了几个。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>环境搭建很简单，后面如果有时间的话可以再讲讲在 Kibana 的 Dev Tools 上构建 ES 的 JSON 串来对 ES 进行操作。</p><p>我还写过 ES 相关的文章：</p><p>1、<a href="http://www.54tianzhisheng.cn/2017/09/07/Elasticsearch-analyzers/" target="_blank" rel="noopener">Elasticsearch 默认分词器和中分分词器之间的比较及使用方法</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/" target="_blank" rel="noopener">全文搜索引擎 Elasticsearch 集群搭建入门教程</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/10/15/ElasticSearch-cluster-health-metrics/" target="_blank" rel="noopener">ElasticSearch 集群监控</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2017/10/18/ElasticSearch-nodes-metrics/" target="_blank" rel="noopener">ElasticSearch 单个节点监控</a></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><blockquote><p>本文首发于：<a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">zhisheng 的博客</a></p><p>转载请注明地址：<a href="http://www.54tianzhisheng.cn/2017/12/25/ELK/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/12/25/ELK/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/171225/82lhH8E4Hk.jpg-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h3&gt;&lt;p&gt;ELK（ElasticSearch, Logstash, Kibana），三者组合在一起搭建实时的日志分析平台，目前好多公司都是这套！&lt;br&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/tags/ElasticSearch/"/>
    
      <category term="LogStash" scheme="http://yoursite.com/tags/LogStash/"/>
    
      <category term="Kibana" scheme="http://yoursite.com/tags/Kibana/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 集群监控</title>
    <link href="http://yoursite.com/2018/01/21/ElasticSearch-cluster-health-metrics/"/>
    <id>http://yoursite.com/2018/01/21/ElasticSearch-cluster-health-metrics/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/cb5.jpeg-1" alt=""></p><p>最近在做 ElasticSearch 的信息（集群和节点）监控，特此稍微整理下学到的东西。这篇文章主要介绍集群的监控。<br><a id="more"></a></p><h3 id="要监控哪些-ElasticSearch-metrics"><a href="#要监控哪些-ElasticSearch-metrics" class="headerlink" title="要监控哪些 ElasticSearch metrics"></a>要监控哪些 ElasticSearch metrics</h3><p><img src="https://datadog-prod.imgix.net/img/blog/monitor-elasticsearch-performance-metrics/elasticsearch-dashboard-final2.png?fit=max" alt=""></p><p>Elasticsearch 提供了大量的 Metric，可以帮助您检测到问题的迹象，在遇到节点不可用、out-of-memory、long garbage collection times 的时候采取相应措施。但是指标太多了，有时我们并不需要这么多，这就需要我们进行筛选。</p><h3 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h3><p>一个 Elasticsearch 集群至少包括一个节点和一个索引。或者它 可能有一百个数据节点、三个单独的主节点，以及一小打客户端节点——这些共同操作一千个索引（以及上万个分片）。</p><p>不管集群扩展到多大规模，你都会想要一个快速获取集群状态的途径。<code>Cluster Health</code> API 充当的就是这个角色。你可以把它想象成是在一万英尺的高度鸟瞰集群。它可以告诉你安心吧一切都好，或者警告你集群某个地方有问题。</p><p>让我们执行一下 <code>cluster-health</code> API 然后看看响应体是什么样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cluster/health</span><br></pre></td></tr></table></figure><p>和 Elasticsearch 里其他 API 一样，<code>cluster-health</code> 会返回一个 JSON 响应。这对自动化和告警系统来说，非常便于解析。响应中包含了和你集群有关的一些关键信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch_zach"</span>,</span><br><span class="line">   <span class="attr">"status"</span>: <span class="string">"green"</span>,</span><br><span class="line">   <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">"number_of_nodes"</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"number_of_data_nodes"</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"active_primary_shards"</span>: <span class="number">10</span>,</span><br><span class="line">   <span class="attr">"active_shards"</span>: <span class="number">10</span>,</span><br><span class="line">   <span class="attr">"relocating_shards"</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"initializing_shards"</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"unassigned_shards"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应信息中最重要的一块就是 <code>status</code> 字段。状态可能是下列三个值之一 :</p><table><thead><tr><th style="text-align:center">status</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">green</td><td style="text-align:center">所有的主分片和副本分片都已分配。你的集群是 100% 可用的。</td></tr><tr><td style="text-align:center">yellow</td><td style="text-align:center">所有的主分片已经分片了，但至少还有一个副本是缺失的。不会有数据丢失，所以搜索结果依然是完整的。不过，你的高可用性在某种程度上被弱化。如果 更多的 分片消失，你就会丢数据了。把 yellow 想象成一个需要及时调查的警告。</td></tr><tr><td style="text-align:center">red</td><td style="text-align:center">至少一个主分片（以及它的全部副本）都在缺失中。这意味着你在缺少数据：搜索只能返回部分数据，而分配到这个分片上的写入请求会返回一个异常。</td></tr></tbody></table><ul><li><code>number_of_nodes</code> 和 <code>number_of_data_nodes</code> 这个命名完全是自描述的。</li><li><code>active_primary_shards</code> 指出你集群中的主分片数量。这是涵盖了所有索引的汇总值。</li><li><code>active_shards</code> 是涵盖了所有索引的所有分片的汇总值，即包括副本分片。</li><li><code>relocating_shards</code> 显示当前正在从一个节点迁往其他节点的分片的数量。通常来说应该是 0，不过在 Elasticsearch 发现集群不太均衡时，该值会上涨。比如说：添加了一个新节点，或者下线了一个节点。</li><li><code>initializing_shards</code> 是刚刚创建的分片的个数。比如，当你刚创建第一个索引，分片都会短暂的处于 <code>initializing</code> 状态。这通常会是一个临时事件，分片不应该长期停留在 <code>initializing</code>状态。你还可能在节点刚重启的时候看到 <code>initializing</code> 分片：当分片从磁盘上加载后，它们会从<code>initializing</code> 状态开始。</li><li><code>unassigned_shards</code> 是已经在集群状态中存在的分片，但是实际在集群里又找不着。通常未分配分片的来源是未分配的副本。比如，一个有 5 分片和 1 副本的索引，在单节点集群上，就会有 5 个未分配副本分片。如果你的集群是 <code>red</code> 状态，也会长期保有未分配分片（因为缺少主分片）。</li></ul><h3 id="集群统计"><a href="#集群统计" class="headerlink" title="集群统计"></a>集群统计</h3><p>集群统计信息包含 集群的分片数，文档数，存储空间，缓存信息，内存作用率，插件内容，文件系统内容，JVM 作用状况，系统 CPU，OS 信息，段信息。</p><p>查看全部统计信息命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/_cluster/stats?human&amp;pretty&apos;</span><br></pre></td></tr></table></figure><p>返回 JSON 结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"timestamp"</span>: <span class="number">1459427693515</span>,</span><br><span class="line">   <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">   <span class="attr">"status"</span>: <span class="string">"green"</span>,</span><br><span class="line">   <span class="attr">"indices"</span>: &#123;</span><br><span class="line">      <span class="attr">"count"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"shards"</span>: &#123;</span><br><span class="line">         <span class="attr">"total"</span>: <span class="number">10</span>,</span><br><span class="line">         <span class="attr">"primaries"</span>: <span class="number">10</span>,</span><br><span class="line">         <span class="attr">"replication"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"index"</span>: &#123;</span><br><span class="line">            <span class="attr">"shards"</span>: &#123;</span><br><span class="line">               <span class="attr">"min"</span>: <span class="number">5</span>,</span><br><span class="line">               <span class="attr">"max"</span>: <span class="number">5</span>,</span><br><span class="line">               <span class="attr">"avg"</span>: <span class="number">5</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"primaries"</span>: &#123;</span><br><span class="line">               <span class="attr">"min"</span>: <span class="number">5</span>,</span><br><span class="line">               <span class="attr">"max"</span>: <span class="number">5</span>,</span><br><span class="line">               <span class="attr">"avg"</span>: <span class="number">5</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"replication"</span>: &#123;</span><br><span class="line">               <span class="attr">"min"</span>: <span class="number">0</span>,</span><br><span class="line">               <span class="attr">"max"</span>: <span class="number">0</span>,</span><br><span class="line">               <span class="attr">"avg"</span>: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"docs"</span>: &#123;</span><br><span class="line">         <span class="attr">"count"</span>: <span class="number">10</span>,</span><br><span class="line">         <span class="attr">"deleted"</span>: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"store"</span>: &#123;</span><br><span class="line">         <span class="attr">"size"</span>: <span class="string">"16.2kb"</span>,</span><br><span class="line">         <span class="attr">"size_in_bytes"</span>: <span class="number">16684</span>,</span><br><span class="line">         <span class="attr">"throttle_time"</span>: <span class="string">"0s"</span>,</span><br><span class="line">         <span class="attr">"throttle_time_in_millis"</span>: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"fielddata"</span>: &#123;</span><br><span class="line">         <span class="attr">"memory_size"</span>: <span class="string">"0b"</span>,</span><br><span class="line">         <span class="attr">"memory_size_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"evictions"</span>: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"query_cache"</span>: &#123;</span><br><span class="line">         <span class="attr">"memory_size"</span>: <span class="string">"0b"</span>,</span><br><span class="line">         <span class="attr">"memory_size_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"total_count"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"hit_count"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"miss_count"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"cache_size"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"cache_count"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"evictions"</span>: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"completion"</span>: &#123;</span><br><span class="line">         <span class="attr">"size"</span>: <span class="string">"0b"</span>,</span><br><span class="line">         <span class="attr">"size_in_bytes"</span>: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"segments"</span>: &#123;</span><br><span class="line">         <span class="attr">"count"</span>: <span class="number">4</span>,</span><br><span class="line">         <span class="attr">"memory"</span>: <span class="string">"8.6kb"</span>,</span><br><span class="line">         <span class="attr">"memory_in_bytes"</span>: <span class="number">8898</span>,</span><br><span class="line">         <span class="attr">"terms_memory"</span>: <span class="string">"6.3kb"</span>,</span><br><span class="line">         <span class="attr">"terms_memory_in_bytes"</span>: <span class="number">6522</span>,</span><br><span class="line">         <span class="attr">"stored_fields_memory"</span>: <span class="string">"1.2kb"</span>,</span><br><span class="line">         <span class="attr">"stored_fields_memory_in_bytes"</span>: <span class="number">1248</span>,</span><br><span class="line">         <span class="attr">"term_vectors_memory"</span>: <span class="string">"0b"</span>,</span><br><span class="line">         <span class="attr">"term_vectors_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"norms_memory"</span>: <span class="string">"384b"</span>,</span><br><span class="line">         <span class="attr">"norms_memory_in_bytes"</span>: <span class="number">384</span>,</span><br><span class="line">         <span class="attr">"doc_values_memory"</span>: <span class="string">"744b"</span>,</span><br><span class="line">         <span class="attr">"doc_values_memory_in_bytes"</span>: <span class="number">744</span>,</span><br><span class="line">         <span class="attr">"index_writer_memory"</span>: <span class="string">"0b"</span>,</span><br><span class="line">         <span class="attr">"index_writer_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"version_map_memory"</span>: <span class="string">"0b"</span>,</span><br><span class="line">         <span class="attr">"version_map_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"fixed_bit_set"</span>: <span class="string">"0b"</span>,</span><br><span class="line">         <span class="attr">"fixed_bit_set_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"file_sizes"</span>: &#123;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"percolator"</span>: &#123;</span><br><span class="line">         <span class="attr">"num_queries"</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"nodes"</span>: &#123;</span><br><span class="line">      <span class="attr">"count"</span>: &#123;</span><br><span class="line">         <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="attr">"data"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="attr">"coordinating_only"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"master"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="attr">"ingest"</span>: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"versions"</span>: [</span><br><span class="line">         <span class="string">"5.6.3"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"os"</span>: &#123;</span><br><span class="line">         <span class="attr">"available_processors"</span>: <span class="number">8</span>,</span><br><span class="line">         <span class="attr">"allocated_processors"</span>: <span class="number">8</span>,</span><br><span class="line">         <span class="attr">"names"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"name"</span>: <span class="string">"Mac OS X"</span>,</span><br><span class="line">               <span class="attr">"count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">         ],</span><br><span class="line">         <span class="attr">"mem"</span> : &#123;</span><br><span class="line">            <span class="attr">"total"</span> : <span class="string">"16gb"</span>,</span><br><span class="line">            <span class="attr">"total_in_bytes"</span> : <span class="number">17179869184</span>,</span><br><span class="line">            <span class="attr">"free"</span> : <span class="string">"78.1mb"</span>,</span><br><span class="line">            <span class="attr">"free_in_bytes"</span> : <span class="number">81960960</span>,</span><br><span class="line">            <span class="attr">"used"</span> : <span class="string">"15.9gb"</span>,</span><br><span class="line">            <span class="attr">"used_in_bytes"</span> : <span class="number">17097908224</span>,</span><br><span class="line">            <span class="attr">"free_percent"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"used_percent"</span> : <span class="number">100</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"process"</span>: &#123;</span><br><span class="line">         <span class="attr">"cpu"</span>: &#123;</span><br><span class="line">            <span class="attr">"percent"</span>: <span class="number">9</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"open_file_descriptors"</span>: &#123;</span><br><span class="line">            <span class="attr">"min"</span>: <span class="number">268</span>,</span><br><span class="line">            <span class="attr">"max"</span>: <span class="number">268</span>,</span><br><span class="line">            <span class="attr">"avg"</span>: <span class="number">268</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"jvm"</span>: &#123;</span><br><span class="line">         <span class="attr">"max_uptime"</span>: <span class="string">"13.7s"</span>,</span><br><span class="line">         <span class="attr">"max_uptime_in_millis"</span>: <span class="number">13737</span>,</span><br><span class="line">         <span class="attr">"versions"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"version"</span>: <span class="string">"1.8.0_74"</span>,</span><br><span class="line">               <span class="attr">"vm_name"</span>: <span class="string">"Java HotSpot(TM) 64-Bit Server VM"</span>,</span><br><span class="line">               <span class="attr">"vm_version"</span>: <span class="string">"25.74-b02"</span>,</span><br><span class="line">               <span class="attr">"vm_vendor"</span>: <span class="string">"Oracle Corporation"</span>,</span><br><span class="line">               <span class="attr">"count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">         ],</span><br><span class="line">         <span class="attr">"mem"</span>: &#123;</span><br><span class="line">            <span class="attr">"heap_used"</span>: <span class="string">"57.5mb"</span>,</span><br><span class="line">            <span class="attr">"heap_used_in_bytes"</span>: <span class="number">60312664</span>,</span><br><span class="line">            <span class="attr">"heap_max"</span>: <span class="string">"989.8mb"</span>,</span><br><span class="line">            <span class="attr">"heap_max_in_bytes"</span>: <span class="number">1037959168</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"threads"</span>: <span class="number">90</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"fs"</span>: &#123;</span><br><span class="line">         <span class="attr">"total"</span>: <span class="string">"200.6gb"</span>,</span><br><span class="line">         <span class="attr">"total_in_bytes"</span>: <span class="number">215429193728</span>,</span><br><span class="line">         <span class="attr">"free"</span>: <span class="string">"32.6gb"</span>,</span><br><span class="line">         <span class="attr">"free_in_bytes"</span>: <span class="number">35064553472</span>,</span><br><span class="line">         <span class="attr">"available"</span>: <span class="string">"32.4gb"</span>,</span><br><span class="line">         <span class="attr">"available_in_bytes"</span>: <span class="number">34802409472</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"plugins"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"analysis-icu"</span>,</span><br><span class="line">          <span class="attr">"version"</span>: <span class="string">"5.6.3"</span>,</span><br><span class="line">          <span class="attr">"description"</span>: <span class="string">"The ICU Analysis plugin integrates Lucene ICU module into elasticsearch, adding ICU relates analysis components."</span>,</span><br><span class="line">          <span class="attr">"classname"</span>: <span class="string">"org.elasticsearch.plugin.analysis.icu.AnalysisICUPlugin"</span>,</span><br><span class="line">          <span class="attr">"has_native_controller"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"ingest-geoip"</span>,</span><br><span class="line">          <span class="attr">"version"</span>: <span class="string">"5.6.3"</span>,</span><br><span class="line">          <span class="attr">"description"</span>: <span class="string">"Ingest processor that uses looksup geo data based on ip adresses using the Maxmind geo database"</span>,</span><br><span class="line">          <span class="attr">"classname"</span>: <span class="string">"org.elasticsearch.ingest.geoip.IngestGeoIpPlugin"</span>,</span><br><span class="line">          <span class="attr">"has_native_controller"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"ingest-user-agent"</span>,</span><br><span class="line">          <span class="attr">"version"</span>: <span class="string">"5.6.3"</span>,</span><br><span class="line">          <span class="attr">"description"</span>: <span class="string">"Ingest processor that extracts information from a user agent"</span>,</span><br><span class="line">          <span class="attr">"classname"</span>: <span class="string">"org.elasticsearch.ingest.useragent.IngestUserAgentPlugin"</span>,</span><br><span class="line">          <span class="attr">"has_native_controller"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存使用和-GC-指标"><a href="#内存使用和-GC-指标" class="headerlink" title="内存使用和 GC 指标"></a>内存使用和 GC 指标</h4><p>在运行 Elasticsearch 时，内存是您要密切监控的关键资源之一。 Elasticsearch 和 Lucene 以两种方式利用节点上的所有可用 RAM：JVM heap 和文件系统缓存。 Elasticsearch 运行在Java虚拟机（JVM）中，这意味着JVM垃圾回收的持续时间和频率将成为其他重要的监控领域。</p><p>上面返回的 JSON监控的指标有我个人觉得有这些：</p><ul><li>nodes.successful</li><li>nodes.failed</li><li>nodes.total</li><li>nodes.mem.used_percent</li><li>nodes.process.cpu.percent</li><li>nodes.jvm.mem.heap_used</li></ul><p>可以看到 JSON 文件是很复杂的，如果从这复杂的 JSON 中获取到对应的指标（key）的值呢，这里请看文章 ：<a href="http://www.54tianzhisheng.cn/2017/10/13/JsonPath/" target="_blank" rel="noopener">JsonPath —— JSON 解析神器</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这里主要讲下 ES 集群的一些监控信息，有些监控指标是个人觉得需要监控的，但是具体情况还是得看需求了。下篇文章主要讲节点的监控信息。转载请注明地址：<a href="http://www.54tianzhisheng.cn/2017/10/15/ElasticSearch-cluster-health-metrics/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/10/15/ElasticSearch-cluster-health-metrics/</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1、<a href="https://www.datadoghq.com/blog/monitor-elasticsearch-performance-metrics/" target="_blank" rel="noopener">How to monitor Elasticsearch performance</a></p><p>2、<a href="http://www.oneapm.com/ci/elasticsearch.html" target="_blank" rel="noopener">ElasticSearch 性能监控</a></p><p>3、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-health.html" target="_blank" rel="noopener">cluster-health</a></p><p>4、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-stats.html" target="_blank" rel="noopener">cluster-stats</a></p><h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><p>1、<a href="http://www.54tianzhisheng.cn/2017/09/07/Elasticsearch-analyzers/" target="_blank" rel="noopener">Elasticsearch 默认分词器和中分分词器之间的比较及使用方法</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/" target="_blank" rel="noopener">全文搜索引擎 Elasticsearch 集群搭建入门教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/cb5.jpeg-1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在做 ElasticSearch 的信息（集群和节点）监控，特此稍微整理下学到的东西。这篇文章主要介绍集群的监控。&lt;br&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 单个节点监控</title>
    <link href="http://yoursite.com/2018/01/21/ElasticSearch-nodes-metrics/"/>
    <id>http://yoursite.com/2018/01/21/ElasticSearch-nodes-metrics/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/cb6.jpeg-1" alt=""></p><p>集群健康监控是对集群信息进行高度的概括，节点统计值 API 提供了集群中每个节点的统计值。节点统计值很多，在监控的时候仍需要我们清楚哪些指标是最值得关注的。</p><p>集群健康监控可以参考这篇文章：<a href="http://www.54tianzhisheng.cn/2017/10/15/ElasticSearch-cluster-health-metrics/" target="_blank" rel="noopener">ElasticSearch 集群监控</a><br><a id="more"></a></p><h3 id="节点信息-Node-Info"><a href="#节点信息-Node-Info" class="headerlink" title="节点信息   Node Info :"></a>节点信息   Node Info :</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/_nodes&apos;</span><br></pre></td></tr></table></figure><p>执行上述命令可以获取所有 node 的信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">_nodes: &#123;</span><br><span class="line">  total: 2,</span><br><span class="line">  successful: 2,</span><br><span class="line">  failed: 0</span><br><span class="line">&#125;,</span><br><span class="line">cluster_name: "elasticsearch",</span><br><span class="line">nodes: &#123;</span><br><span class="line">MSQ_CZ7mTNyOSlYIfrvHag: &#123;</span><br><span class="line">name: "node0",</span><br><span class="line">    transport_address: "192.168.180.110:9300",</span><br><span class="line">    host: "192.168.180.110",</span><br><span class="line">    ip: "192.168.180.110",</span><br><span class="line">    version: "5.5.0",</span><br><span class="line">    build_hash: "260387d",</span><br><span class="line">    total_indexing_buffer: 103887667,</span><br><span class="line">    roles:&#123;...&#125;,</span><br><span class="line">    settings: &#123;...&#125;,</span><br><span class="line">    os: &#123;</span><br><span class="line">      refresh_interval_in_millis: 1000,</span><br><span class="line">      name: "Linux",</span><br><span class="line">      arch: "amd64",</span><br><span class="line">      version: "3.10.0-229.el7.x86_64",</span><br><span class="line">      available_processors: 4,</span><br><span class="line">      allocated_processors: 4</span><br><span class="line">&#125;,</span><br><span class="line">process: &#123;</span><br><span class="line">      refresh_interval_in_millis: 1000,</span><br><span class="line">      id: 3022,</span><br><span class="line">      mlockall: false</span><br><span class="line">&#125;,</span><br><span class="line">jvm: &#123;</span><br><span class="line">      pid: 3022,</span><br><span class="line">      version: "1.8.0_121",</span><br><span class="line">      vm_name: "Java HotSpot(TM) 64-Bit Server VM",</span><br><span class="line">      vm_version: "25.121-b13",</span><br><span class="line">      vm_vendor: "Oracle Corporation",</span><br><span class="line">      start_time_in_millis: 1507515225302,</span><br><span class="line">      mem: &#123;</span><br><span class="line">      heap_init_in_bytes: 1073741824,</span><br><span class="line">      heap_max_in_bytes: 1038876672,</span><br><span class="line">      non_heap_init_in_bytes: 2555904,</span><br><span class="line">      non_heap_max_in_bytes: 0,</span><br><span class="line">      direct_max_in_bytes: 1038876672</span><br><span class="line">      &#125;,</span><br><span class="line">      gc_collectors: [],</span><br><span class="line">      memory_pools: [],</span><br><span class="line">      using_compressed_ordinary_object_pointers: "true",</span><br><span class="line">      input_arguments:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread_pool:&#123;</span><br><span class="line">      force_merge: &#123;&#125;,</span><br><span class="line">      fetch_shard_started: &#123;&#125;,</span><br><span class="line">      listener: &#123;&#125;,</span><br><span class="line">      index: &#123;&#125;,</span><br><span class="line">      refresh: &#123;&#125;,</span><br><span class="line">      generic: &#123;&#125;,</span><br><span class="line">      warmer: &#123;&#125;,</span><br><span class="line">      search: &#123;&#125;,</span><br><span class="line">      flush: &#123;&#125;,</span><br><span class="line">      fetch_shard_store: &#123;&#125;,</span><br><span class="line">      management: &#123;&#125;,</span><br><span class="line">      get: &#123;&#125;,</span><br><span class="line">      bulk: &#123;&#125;,</span><br><span class="line">      snapshot: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    transport: &#123;...&#125;,</span><br><span class="line">    http: &#123;...&#125;,</span><br><span class="line">    plugins: [],</span><br><span class="line">    modules: [],</span><br><span class="line">    ingest: &#123;...&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面是我已经简写了很多数据之后的返回值，但是指标还是很多，有些是一些常规的指标，对于监控来说，没必要拿取。从上面我们可以主要关注以下这些指标:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os, process, jvm, thread_pool, transport, http, ingest and indices</span><br></pre></td></tr></table></figure><h3 id="节点统计-nodes-statistics"><a href="#节点统计-nodes-statistics" class="headerlink" title="节点统计     nodes-statistics"></a>节点统计     nodes-statistics</h3><p>节点统计值 API 可通过如下命令获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_nodes/stats</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">_nodes: &#123;</span><br><span class="line">  total: 2,</span><br><span class="line">  successful: 2,</span><br><span class="line">  failed: 0</span><br><span class="line">&#125;,</span><br><span class="line">cluster_name: "elasticsearch",</span><br><span class="line">nodes: &#123;</span><br><span class="line">  MSQ_CZ7mTNyOSlYI0yvHag: &#123;</span><br><span class="line">    timestamp: 1508312932354,</span><br><span class="line">    name: "node0",</span><br><span class="line">    transport_address: "192.168.180.110:9300",</span><br><span class="line">    host: "192.168.180.110",</span><br><span class="line">    ip: "192.168.180.110:9300",</span><br><span class="line">    roles: [],</span><br><span class="line">    indices: &#123;</span><br><span class="line">      docs: &#123;</span><br><span class="line">           count: 6163666,</span><br><span class="line">           deleted: 0</span><br><span class="line">        &#125;,</span><br><span class="line">      store: &#123;</span><br><span class="line">           size_in_bytes: 2301398179,</span><br><span class="line">           throttle_time_in_millis: 122850</span><br><span class="line">        &#125;,</span><br><span class="line">      indexing: &#123;&#125;,</span><br><span class="line">      get: &#123;&#125;,</span><br><span class="line">      search: &#123;&#125;,</span><br><span class="line">      merges: &#123;&#125;,</span><br><span class="line">      refresh: &#123;&#125;,</span><br><span class="line">      flush: &#123;&#125;,</span><br><span class="line">      warmer: &#123;&#125;,</span><br><span class="line">      query_cache: &#123;&#125;,</span><br><span class="line">      fielddata: &#123;&#125;,</span><br><span class="line">      completion: &#123;&#125;,</span><br><span class="line">      segments: &#123;&#125;,</span><br><span class="line">      translog: &#123;&#125;,</span><br><span class="line">      request_cache: &#123;&#125;,</span><br><span class="line">      recovery: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  os: &#123;</span><br><span class="line">    timestamp: 1508312932369,</span><br><span class="line">    cpu: &#123;</span><br><span class="line">      percent: 0,</span><br><span class="line">      load_average: &#123;</span><br><span class="line">        1m: 0.09,</span><br><span class="line">        5m: 0.12,</span><br><span class="line">        15m: 0.08</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mem: &#123;</span><br><span class="line">      total_in_bytes: 8358301696,</span><br><span class="line">      free_in_bytes: 1381613568,</span><br><span class="line">      used_in_bytes: 6976688128,</span><br><span class="line">      free_percent: 17,</span><br><span class="line">      used_percent: 83</span><br><span class="line">    &#125;,</span><br><span class="line">    swap: &#123;</span><br><span class="line">      total_in_bytes: 8455712768,</span><br><span class="line">      free_in_bytes: 8455299072,</span><br><span class="line">      used_in_bytes: 413696</span><br><span class="line">    &#125;,</span><br><span class="line">    cgroup: &#123;</span><br><span class="line">      cpuacct: &#123;&#125;,</span><br><span class="line">      cpu: &#123;</span><br><span class="line">        control_group: "/user.slice",</span><br><span class="line">        cfs_period_micros: 100000,</span><br><span class="line">        cfs_quota_micros: -1,</span><br><span class="line">        stat: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">process: &#123;</span><br><span class="line">  timestamp: 1508312932369,</span><br><span class="line">  open_file_descriptors: 228,</span><br><span class="line">  max_file_descriptors: 65536,</span><br><span class="line">  cpu: &#123;</span><br><span class="line">    percent: 0,</span><br><span class="line">    total_in_millis: 2495040</span><br><span class="line">  &#125;,</span><br><span class="line">  mem: &#123;</span><br><span class="line">    total_virtual_in_bytes: 5002465280</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">jvm: &#123;</span><br><span class="line">  timestamp: 1508312932369,</span><br><span class="line">  uptime_in_millis: 797735804,</span><br><span class="line">  mem: &#123;</span><br><span class="line">    heap_used_in_bytes: 318233768,</span><br><span class="line">    heap_used_percent: 30,</span><br><span class="line">    heap_committed_in_bytes: 1038876672,</span><br><span class="line">    heap_max_in_bytes: 1038876672,</span><br><span class="line">    non_heap_used_in_bytes: 102379784,</span><br><span class="line">    non_heap_committed_in_bytes: 108773376,</span><br><span class="line">  pools: &#123;</span><br><span class="line">    young: &#123;</span><br><span class="line">      used_in_bytes: 62375176,</span><br><span class="line">      max_in_bytes: 279183360,</span><br><span class="line">      peak_used_in_bytes: 279183360,</span><br><span class="line">      peak_max_in_bytes: 279183360</span><br><span class="line">    &#125;,</span><br><span class="line">    survivor: &#123;</span><br><span class="line">      used_in_bytes: 175384,</span><br><span class="line">      max_in_bytes: 34865152,</span><br><span class="line">      peak_used_in_bytes: 34865152,</span><br><span class="line">      peak_max_in_bytes: 34865152</span><br><span class="line">    &#125;,</span><br><span class="line">    old: &#123;</span><br><span class="line">      used_in_bytes: 255683208,</span><br><span class="line">      max_in_bytes: 724828160,</span><br><span class="line">      peak_used_in_bytes: 255683208,</span><br><span class="line">      peak_max_in_bytes: 724828160</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  threads: &#123;&#125;,</span><br><span class="line">  gc: &#123;&#125;,</span><br><span class="line">  buffer_pools: &#123;&#125;,</span><br><span class="line">  classes: &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">  thread_pool: &#123;</span><br><span class="line">    bulk: &#123;&#125;,</span><br><span class="line">    fetch_shard_started: &#123;&#125;,</span><br><span class="line">    fetch_shard_store: &#123;&#125;,</span><br><span class="line">    flush: &#123;&#125;,</span><br><span class="line">    force_merge: &#123;&#125;,</span><br><span class="line">    generic: &#123;&#125;,</span><br><span class="line">    get: &#123;&#125;,</span><br><span class="line">    index: &#123;</span><br><span class="line">       threads: 1,</span><br><span class="line">       queue: 0,</span><br><span class="line">       active: 0,</span><br><span class="line">       rejected: 0,</span><br><span class="line">       largest: 1,</span><br><span class="line">       completed: 1</span><br><span class="line">    &#125;</span><br><span class="line">    listener: &#123;&#125;,</span><br><span class="line">    management: &#123;&#125;,</span><br><span class="line">    refresh: &#123;&#125;,</span><br><span class="line">    search: &#123;&#125;,</span><br><span class="line">    snapshot: &#123;&#125;,</span><br><span class="line">    warmer: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  fs: &#123;&#125;,</span><br><span class="line">  transport: &#123;</span><br><span class="line">    server_open: 13,</span><br><span class="line">    rx_count: 11696,</span><br><span class="line">    rx_size_in_bytes: 1525774,</span><br><span class="line">    tx_count: 10282,</span><br><span class="line">    tx_size_in_bytes: 1440101928</span><br><span class="line">  &#125;,</span><br><span class="line">  http: &#123;</span><br><span class="line">    current_open: 4,</span><br><span class="line">    total_opened: 23</span><br><span class="line">  &#125;,</span><br><span class="line">  breakers: &#123;&#125;,</span><br><span class="line">  script: &#123;&#125;,</span><br><span class="line">  discovery: &#123;&#125;,</span><br><span class="line">  ingest: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点名是一个 UUID，上面列举了很多指标，下面讲解下：</p><h4 id="索引部分-indices"><a href="#索引部分-indices" class="headerlink" title="索引部分 indices"></a>索引部分 indices</h4><p>这部分列出了这个节点上所有索引的聚合过的统计值 ：</p><ul><li><p><code>docs</code> 展示节点内存有多少文档，包括还没有从段里清除的已删除文档数量。</p></li><li><p><code>store</code> 部分显示节点耗用了多少物理存储。这个指标包括主分片和副本分片在内。如果限流时间很大，那可能表明你的磁盘限流设置得过低。</p></li><li><p><code>indexing</code> 显示已经索引了多少文档。这个值是一个累加计数器。在文档被删除的时候，数值不会下降。还要注意的是，在发生内部 索引操作的时候，这个值也会增加，比如说文档更新。</p><p>还列出了索引操作耗费的时间，正在索引的文档数量，以及删除操作的类似统计值。</p></li><li><p><code>get</code> 显示通过 ID 获取文档的接口相关的统计值。包括对单个文档的 <code>GET</code> 和 <code>HEAD</code> 请求。</p></li><li><p><code>search</code> 描述在活跃中的搜索（ <code>open_contexts</code> ）数量、查询的总数量、以及自节点启动以来在查询上消耗的总时间。用 <code>query_time_in_millis / query_total</code> 计算的比值，可以用来粗略的评价你的查询有多高效。比值越大，每个查询花费的时间越多，你应该要考虑调优了。</p><p>fetch 统计值展示了查询处理的后一半流程（query-then-fetch 里的 <em>fetch</em> ）。如果 fetch 耗时比 query 还多，说明磁盘较慢，或者获取了太多文档，或者可能搜索请求设置了太大的分页（比如， <code>size: 10000</code> ）。</p></li><li><p><code>merges</code> 包括了 Lucene 段合并相关的信息。它会告诉你目前在运行几个合并，合并涉及的文档数量，正在合并的段的总大小，以及在合并操作上消耗的总时间。</p></li><li><p><code>filter_cache</code> 展示了已缓存的过滤器位集合所用的内存数量，以及过滤器被驱逐出内存的次数。过多的驱逐数 <em>可能</em> 说明你需要加大过滤器缓存的大小，或者你的过滤器不太适合缓存（比如它们因为高基数而在大量产生，就像是缓存一个 <code>now</code> 时间表达式）。</p><p>不过，驱逐数是一个很难评定的指标。过滤器是在每个段的基础上缓存的，而从一个小的段里驱逐过滤器，代价比从一个大的段里要廉价的多。有可能你有很大的驱逐数，但是它们都发生在小段上，也就意味着这些对查询性能只有很小的影响。</p><p>把驱逐数指标作为一个粗略的参考。如果你看到数字很大，检查一下你的过滤器，确保他们都是正常缓存的。不断驱逐着的过滤器，哪怕都发生在很小的段上，效果也比正确缓存住了的过滤器差很多。</p></li><li><p><code>field_data</code> 显示 fielddata 使用的内存， 用以聚合、排序等等。这里也有一个驱逐计数。和 <code>filter_cache</code> 不同的是，这里的驱逐计数是很有用的：这个数应该或者至少是接近于 0。因为 fielddata 不是缓存，任何驱逐都消耗巨大，应该避免掉。如果你在这里看到驱逐数，你需要重新评估你的内存情况，fielddata 限制，请求语句，或者这三者。</p></li><li><p><code>segments</code> 会展示这个节点目前正在服务中的 Lucene 段的数量。 这是一个重要的数字。大多数索引会有大概 50–150 个段，哪怕它们存有 TB 级别的数十亿条文档。段数量过大表明合并出现了问题（比如，合并速度跟不上段的创建）。注意这个统计值是节点上所有索引的汇聚总数。记住这点。</p><p><code>memory</code> 统计值展示了 Lucene 段自己用掉的内存大小。 这里包括底层数据结构，比如倒排表，字典，和布隆过滤器等。太大的段数量会增加这些数据结构带来的开销，这个内存使用量就是一个方便用来衡量开销的度量值。</p></li></ul><h4 id="操作系统和进程部分"><a href="#操作系统和进程部分" class="headerlink" title="操作系统和进程部分"></a>操作系统和进程部分</h4><p><code>OS</code> 和 <code>Process</code> 部分基本是自描述的，不会在细节中展开讲解。它们列出来基础的资源统计值，比如 CPU 和负载。<code>OS</code> 部分描述了整个操作系统，而 <code>Process</code> 部分只显示 Elasticsearch 的 JVM 进程使用的资源情况。</p><p>这些都是非常有用的指标，不过通常在你的监控技术栈里已经都测量好了。统计值包括下面这些：</p><ul><li>CPU</li><li>负载</li><li>内存使用率 （mem.used_percent）</li><li>Swap 使用率</li><li>打开的文件描述符 （open_file_descriptors）</li></ul><h4 id="JVM-部分"><a href="#JVM-部分" class="headerlink" title="JVM 部分"></a>JVM 部分</h4><p><code>jvm</code> 部分包括了运行 Elasticsearch 的 JVM 进程一些很关键的信息。 最重要的，它包括了垃圾回收的细节，这对你的 Elasticsearch 集群的稳定性有着重大影响。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jvm: &#123;</span><br><span class="line">  timestamp: 1508312932369,</span><br><span class="line">  uptime_in_millis: 797735804,</span><br><span class="line">  mem: &#123;</span><br><span class="line">    heap_used_in_bytes: 318233768,</span><br><span class="line">    heap_used_percent: 30,</span><br><span class="line">    heap_committed_in_bytes: 1038876672,</span><br><span class="line">    heap_max_in_bytes: 1038876672,</span><br><span class="line">    non_heap_used_in_bytes: 102379784,</span><br><span class="line">    non_heap_committed_in_bytes: 108773376,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jvm</code> 部分首先列出一些和 heap 内存使用有关的常见统计值。你可以看到有多少 heap 被使用了，多少被指派了（当前被分配给进程的），以及 heap 被允许分配的最大值。理想情况下，<code>heap_committed_in_bytes</code> 应该等于 <code>heap_max_in_bytes</code> 。如果指派的大小更小，JVM 最终会被迫调整 heap 大小——这是一个非常昂贵的操作。如果你的数字不相等，阅读 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/heap-sizing.html" target="_blank" rel="noopener">堆内存:大小和交换</a> 学习如何正确的配置它。</p><p><code>heap_used_percent</code> 指标是值得关注的一个数字。Elasticsearch 被配置为当 heap 达到 75% 的时候开始 GC。如果你的节点一直 &gt;= 75%，你的节点正处于 <em>内存压力</em> 状态。这是个危险信号，不远的未来可能就有慢 GC 要出现了。</p><p>如果 heap 使用率一直 &gt;=85%，你就麻烦了。Heap 在 90–95% 之间，则面临可怕的性能风险，此时最好的情况是长达 10–30s 的 GC，最差的情况就是内存溢出（OOM）异常。</p><h4 id="线程池部分"><a href="#线程池部分" class="headerlink" title="线程池部分"></a>线程池部分</h4><p>Elasticsearch 在内部维护了线程池。 这些线程池相互协作完成任务，有必要的话相互间还会传递任务。通常来说，你不需要配置或者调优线程池，不过查看它们的统计值有时候还是有用的，可以洞察你的集群表现如何。</p><p>每个线程池会列出已配置的线程数量（ <code>threads</code> ），当前在处理任务的线程数量（ <code>active</code> ），以及在队列中等待处理的任务单元数量（ <code>queue</code> ）。</p><p>如果队列中任务单元数达到了极限，新的任务单元会开始被拒绝，你会在 <code>rejected</code> 统计值上看到它反映出来。这通常是你的集群在某些资源上碰到瓶颈的信号。因为队列满意味着你的节点或集群在用最高速度运行，但依然跟不上工作的蜂拥而入。</p><p>这里的一系列的线程池，大多数你可以忽略，但是有一小部分还是值得关注的：</p><ul><li><code>indexing</code>    普通的索引请求的线程池</li><li><code>bulk</code>    批量请求，和单条的索引请求不同的线程池</li><li><code>get</code>     Get-by-ID 操作</li><li><code>search</code>    所有的搜索和查询请求</li><li><code>merging</code>   专用于管理 Lucene 合并的线程池</li></ul><h4 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h4><ul><li><code>transport</code> 显示和 <em>传输地址</em> 相关的一些基础统计值。包括节点间的通信（通常是 9300 端口）以及任意传输客户端或者节点客户端的连接。如果看到这里有很多连接数不要担心；Elasticsearch 在节点之间维护了大量的连接。</li><li><code>http</code> 显示 HTTP 端口（通常是 9200）的统计值。如果你看到 <code>total_opened</code> 数很大而且还在一直上涨，这是一个明确信号，说明你的 HTTP 客户端里有没启用 keep-alive 长连接的。持续的 keep-alive 长连接对性能很重要，因为连接、断开套接字是很昂贵的（而且浪费文件描述符）。请确认你的客户端都配置正确。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-info.html" target="_blank" rel="noopener">nodes-info</a></p><p>2、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html" target="_blank" rel="noopener">nodes-stats</a></p><p>3、<a href="http://www.oneapm.com/ci/elasticsearch.html" target="_blank" rel="noopener">ES监控指标</a></p><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>转载请注明地址：<a href="http://www.54tianzhisheng.cn/2017/10/18/ElasticSearch-nodes-metrics/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/10/18/ElasticSearch-nodes-metrics/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/cb6.jpeg-1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;集群健康监控是对集群信息进行高度的概括，节点统计值 API 提供了集群中每个节点的统计值。节点统计值很多，在监控的时候仍需要我们清楚哪些指标是最值得关注的。&lt;/p&gt;
&lt;p&gt;集群健康监控可以参考这篇文章：&lt;a href=&quot;http://www.54tianzhisheng.cn/2017/10/15/ElasticSearch-cluster-health-metrics/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ElasticSearch 集群监控&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>全文搜索引擎 Elasticsearch 集群搭建入门教程</title>
    <link href="http://yoursite.com/2018/01/21/Elasticsearch-install/"/>
    <id>http://yoursite.com/2018/01/21/Elasticsearch-install/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口。Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。基百科、Stack Overflow、Github 都采用它。</p><p>本文从零开始，讲解如何使用 Elasticsearch 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。<br><a id="more"></a></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>1、VMware</p><p>2、Centos 6.6</p><p>3、Elasticsearch 5.5.2</p><p>4、JDK 1.8</p><p>VMware 安装以及在 VMware 中安装 Centos 这个就不说了，环境配置直接默认就好，不过分配给机器的内存最好设置大点（建议 2G），</p><p>使用 dhclient 命令来自动获取 IP 地址，查看获取的 IP 地址则使用命令 ip addr 或者 ifconfig ，则会看到网卡信息和 lo 卡信息。</p><p>给虚拟机额中的 linux 设置固定的  ip（因为后面发现每次机器重启后又要重新使用 dhclient 命令来自动获取 IP 地址）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><p>修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onboot=yes</span><br><span class="line">bootproto=static</span><br></pre></td></tr></table></figure><p>增加：（下面可设置可不设置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPADDR=192.168.1.113            网卡IP地址</span><br><span class="line">GATEWAY=192.168.1.1</span><br><span class="line">NETMASK=255.255.255.0</span><br></pre></td></tr></table></figure><p>设置好之后，把网络服务重启一下， <code>service network restart</code></p><p>修改 ip 地址参考： <a href="http://jingyan.baidu.com/article/e4d08ffdd417660fd3f60d70.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/e4d08ffdd417660fd3f60d70.html</a></p><p>大环境都准备好了，下面开始安装步骤：</p><h3 id="安装-JDK-1-8"><a href="#安装-JDK-1-8" class="headerlink" title="安装 JDK 1.8"></a>安装 JDK 1.8</h3><p>先卸载自带的 openjdk，查找  openjdk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure><p>卸载 openjdk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove  java-1.7.0-openjdk-1.7.0.65-2.5.1.2.el65.x8664</span><br><span class="line">yum -y remove java-1.6.0-openjdk-1.6.0.0-11.1.13.4.el6.x86_64</span><br></pre></td></tr></table></figure><p><strong>解压 JDK 安装包：</strong></p><p>附上jdk1.8的下载地址：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>解压完成后配置一下环境变量就 ok</p><p>1、在/usr/local/下创建Java文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/                                    进入目录</span><br><span class="line">mkdir java                                     新建java目录</span><br></pre></td></tr></table></figure><p>2、文件夹创建完毕，把安装包拷贝到 Java 目录中，然后解压 jdk 到当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/jdk-8u144-linux-x64.tar.gz /usr/local/java/    **注意匹配你自己的文件名**  拷贝到java目录</span><br><span class="line">tar -zxvf jdk-8u144-linux-x64.tar.gz       解压到当前目录（Java目录）</span><br></pre></td></tr></table></figure><p>3、解压完之后，Java目录中会出现一个jdk1.8.0_144的目录，这就解压完成了。之后配置一下环境变量。<br>编辑/etc/下的profile文件，配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile                  进入profile文件的编辑模式</span><br><span class="line"></span><br><span class="line">在最后边追加一下内容(**配置的时候一定要根据自己的目录情况而定哦！**)</span><br><span class="line"></span><br><span class="line"> JAVA_HOME=/usr/local/java/jdk1.8.0_144</span><br><span class="line"> CLASSPATH=$JAVA_HOME/lib/</span><br><span class="line"> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"> export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure><p>之后保存并退出文件之后。</p><p>让文件生效：<code>source /etc/profile</code></p><p>在控制台输入Java 和 Java -version 看有没有信息输出，如下： <code>java -version</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_144&quot;</span><br><span class="line"> Java(TM) SE Runtime Environment (build 1.8.0_60-b27)</span><br><span class="line"> Java HotSpot(TM) Client VM (build 25.60-b23, mixed mode)</span><br></pre></td></tr></table></figure><p>能显示以上信息，就说明 JDK 安装成功啦</p><hr><h3 id="安装-Maven"><a href="#安装-Maven" class="headerlink" title="安装 Maven"></a>安装 Maven</h3><p>因为后面可能会用到 maven ，先装上这个。</p><p>1、下载 maven</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.hust.edu.cn/apache/maven/maven-3/3.2.5/binaries/apache-maven-3.2.5-bin.tar.gz</span><br></pre></td></tr></table></figure><p>2、解压至 /usr/local 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.2.5-bin.tar.gz</span><br></pre></td></tr></table></figure><p>3、配置公司给的配置</p><p>替换成公司给的 setting.xml 文件，修改关于本地仓库的位置, 默认位置: ${user.home}/.m2/repository</p><p>4、配置环境变量etc/profile 最后添加以下两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME=/usr/local/apache-maven-3.2.5</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br></pre></td></tr></table></figure><p>5、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mvn -v</span><br><span class="line">Apache Maven 3.2.5 (12a6b3acb947671f09b81f49094c53f426d8cea1; 2014-12-14T09:29:23-08:00)</span><br><span class="line">Maven home: /usr/local/apache-maven-3.2.5</span><br></pre></td></tr></table></figure><p>VMware 虚拟机里面的三台机器 IP 分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.153.133</span><br><span class="line">192.168.153.134</span><br><span class="line">192.168.153.132</span><br></pre></td></tr></table></figure><h3 id="配置-hosts"><a href="#配置-hosts" class="headerlink" title="配置 hosts"></a>配置 hosts</h3><p>在 /etc/hosts下面编写：ip  node 节点的名字（域名解析）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/hosts</span><br></pre></td></tr></table></figure><p>新增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.153.133  es1</span><br><span class="line">192.168.153.134  es2</span><br><span class="line">192.168.153.132  es3</span><br></pre></td></tr></table></figure><h3 id="设置-SSH-免密码登录"><a href="#设置-SSH-免密码登录" class="headerlink" title="设置 SSH 免密码登录"></a>设置 SSH 免密码登录</h3><p>安装expect命令 ： yum -y install expect</p><p>将 ssh_p2p.jar 随便解压到任何目录下： (这个 jar 包可以去网上下载)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip ssh_p2p.zip</span><br></pre></td></tr></table></figure><p>修改 resource 的 ip 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /ssh_p2p/deploy_data/resource  （各个节点和账户名，密码，free代表相互都可以无密码登陆）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#设置为你每台虚拟机的ip地址，用户名，密码</span><br><span class="line">address=(</span><br><span class="line">&quot;192.168.153.133,root,123456,free&quot;</span><br><span class="line">&quot;192.168.153,134,root,123456,free&quot;</span><br><span class="line">&quot;192.168.153.132,root,123456,free&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>修改 start.sh 的运行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x start.sh</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start.sh</span><br></pre></td></tr></table></figure><p>测试：</p><p>ssh ip地址  （测试是否可以登录）</p><h3 id="安装-ElasticSearch"><a href="#安装-ElasticSearch" class="headerlink" title="安装 ElasticSearch"></a>安装 ElasticSearch</h3><p>下载地址： <a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.2.tar.gz</span><br><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf   elasticsearch-5.5.2.tar.gz</span><br></pre></td></tr></table></figure><p><code>su tzs</code>  切换到 tzs 用户下 ( 默认不支持 root 用户)</p><p><code>sh /usr/local/elasticsearch/bin/elasticsearch -d</code>  其中 -d 表示后台启动</p><p>在 vmware 上测试是否成功：curl <a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a></p><p><img src="http://ohfk1r827.bkt.clouddn.com/test.jpg-1" alt="test"></p><p>出现如上图这样的效果，就代表已经装好了。</p><p>elasticsearch 默认 restful-api 的端口是 9200 不支持 IP 地址，也就是说无法从主机访问虚拟机中的服务，只能在本机用 <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a> 来访问。如果需要改变，需要修改配置文件 /usr/local/elasticsearch/config/elasticsearch.yml 文件，加入以下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">network.bind_host: 0.0.0.0</span><br><span class="line">network.publish_host: _nonloopback:ipv4</span><br></pre></td></tr></table></figure><p>或去除 network.host 和 http.port 之前的注释，并将 network.host 的 IP 地址修改为本机外网 IP。然后重启，Elasticsearch</p><p>关闭方法（输入命令：<code>ps -ef | grep elasticsearch</code> ，找到进程，然后 kill 掉就行了。</p><p>如果外网还是不能访问，则有可能是防火墙设置导致的 ( 关闭防火墙：<code>service iptables stop</code> )</p><p>修改配置文件：<code>vim config/elasticsearch.yml</code></p><p>cluster.name : my-app  (集群的名字，名字相同的就是一个集群)</p><p>node.name : es1  （节点的名字, 和前面配置的 hosts 中的 name 要一致）</p><p>path.data: /data/elasticsearch/data  （数据的路径。没有要创建（<code>mkdir -p /data/elasticsearch/{data,logs}</code>），并且给执行用户权限 <code>chown tzs /data/elasticsearch/{data,logs} -R</code> ）<br>path.logs: /data/elasticsearch/logs    （数据 log 信息的路径，同上）<br>network.host: 0.0.0.0    //允许外网访问，也可以是自己的ip地址<br>http.port: 9200        //访问的端口<br>discovery.zen.ping.unicast.hosts: [“192.168.153.133”, “192.168.153.134”, “192.168.153.132”]   //各个节点的ip地址</p><p>记得需要添加上：（这个是安装 head 插件要用的， 目前不需要）<br>http.cors.enabled: true<br>http.cors.allow-origin: “*”</p><p>最后在外部浏览器的效果如下图：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/test-on-bro.jpg-1" alt="test-on-bro"></p><h3 id="安装-IK-中文分词"><a href="#安装-IK-中文分词" class="headerlink" title="安装 IK 中文分词"></a>安装 IK 中文分词</h3><p>可以自己下载源码使用 maven 编译，当然如果怕麻烦可以直接下载编译好的</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v5.5.2" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v5.5.2</a></p><p>注意下载对应的版本放在 plugins 目录下</p><p>解压</p><p><code>unzip elasticsearch-analysis-ik-5.5.2.zip</code></p><p>在 es 的 plugins 下新建 ik 目录</p><p><code>mkdir ik</code></p><p>将刚才解压的复制到ik目录下</p><p><code>cp -r elasticsearch/* ik</code></p><p>删除刚才解压后的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf elasticsearch</span><br><span class="line">rm -rf elasticsearch-analysis-ik-5.5.2.zip</span><br></pre></td></tr></table></figure><h4 id="IK-带有两个分词器"><a href="#IK-带有两个分词器" class="headerlink" title="IK 带有两个分词器"></a>IK 带有两个分词器</h4><p><strong>ik_max_word</strong> ：会将文本做最细粒度的拆分；尽可能多的拆分出词语</p><p><strong>ik_smart</strong>：会做最粗粒度的拆分；已被分出的词语将不会再次被其它词语占有</p><p>安装完 IK 中文分词器后（当然不止这种中文分词器，还有其他的，可以参考我的文章  <a href="http://www.54tianzhisheng.cn/2017/09/07/Elasticsearch-analyzers/" target="_blank" rel="noopener">Elasticsearch 默认分词器和中分分词器之间的比较及使用方法</a>），测试区别如下：</p><h5 id="ik-max-word"><a href="#ik-max-word" class="headerlink" title="ik_max_word"></a>ik_max_word</h5><p>curl -XGET ‘<a href="http://192.168.153.134:9200/_analyze?pretty&amp;analyzer=ik_max_word" target="_blank" rel="noopener">http://192.168.153.134:9200/_analyze?pretty&amp;analyzer=ik_max_word</a>‘ -d ‘联想是全球最大的笔记本厂商’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;联想&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;是&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;全球&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 3,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;最大&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 5,</span><br><span class="line">      &quot;end_offset&quot; : 7,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;的&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 7,</span><br><span class="line">      &quot;end_offset&quot; : 8,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;笔记本&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 8,</span><br><span class="line">      &quot;end_offset&quot; : 11,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;笔记&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 8,</span><br><span class="line">      &quot;end_offset&quot; : 10,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 6</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;本厂&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 10,</span><br><span class="line">      &quot;end_offset&quot; : 12,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 7</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;厂商&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 11,</span><br><span class="line">      &quot;end_offset&quot; : 13,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 8</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ik-smart"><a href="#ik-smart" class="headerlink" title="ik_smart"></a>ik_smart</h5><p>curl -XGET ‘<a href="http://localhost:9200/_analyze?pretty&amp;analyzer=ik_smart" target="_blank" rel="noopener">http://localhost:9200/_analyze?pretty&amp;analyzer=ik_smart</a>‘ -d ‘联想是全球最大的笔记本厂商’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;联想&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;是&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;全球&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 3,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;最大&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 5,</span><br><span class="line">      &quot;end_offset&quot; : 7,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;的&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 7,</span><br><span class="line">      &quot;end_offset&quot; : 8,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;笔记本&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 8,</span><br><span class="line">      &quot;end_offset&quot; : 11,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;厂商&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 11,</span><br><span class="line">      &quot;end_offset&quot; : 13,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 6</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装-head-插件"><a href="#安装-head-插件" class="headerlink" title="安装 head 插件"></a>安装 head 插件</h3><p>elasticsearch-head 是一个 elasticsearch 的集群管理工具，它是完全由 html5 编写的独立网页程序，你可以通过插件把它集成到 es。</p><p>效果如下图：（图片来自网络）</p><p><img src="http://img.my.csdn.net/uploads/201211/17/1353133910_8134.jpg" alt=""></p><p><img src="http://img.my.csdn.net/uploads/201211/17/1353133911_9624.jpg" alt=""></p><p><img src="http://img.my.csdn.net/uploads/201211/17/1353134135_7264.jpg" alt=""></p><p><img src="http://img.my.csdn.net/uploads/201211/17/1353134135_5729.jpg" alt=""></p><p><img src="http://img.my.csdn.net/uploads/201211/17/1353133911_8912.jpg" alt=""></p><h4 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum remove git</span><br><span class="line">yum install git</span><br><span class="line">git clone git://github.com/mobz/elasticsearch-head.git   拉取 head 插件到本地，或者直接在 GitHub 下载 压缩包下来</span><br></pre></td></tr></table></figure><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p>先去官网下载 node-v8.4.0-linux-x64.tar.xz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -Jxv -f  node-v8.4.0-linux-x64.tar.xz</span><br><span class="line">mv node-v8.4.0-linux-x64  node</span><br></pre></td></tr></table></figure><p>环境变量设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/profile</span><br></pre></td></tr></table></figure><p>新增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NODE_HOME=/opt/node</span><br><span class="line">export PATH=$PATH:$NODE_HOME/bin</span><br><span class="line">export NODE_PATH=$NODE_HOME/lib/node_modules</span><br></pre></td></tr></table></figure><p>使配置文件生效（这步很重要，自己要多注意这步）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>测试是否全局可用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv elasticsearch-head head</span><br><span class="line">cd head/</span><br><span class="line">npm install -g grunt-cli</span><br><span class="line">npm install</span><br><span class="line">grunt server</span><br></pre></td></tr></table></figure><p>再 es 的配置文件中加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>在浏览器打开 <code>http://192.168.153.133:9100/</code>  就可以看到效果了，</p><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>把坑都走了一遍，防止以后再次入坑，特此记录下来</p><p><strong>1、ERROR Could not register mbeans java.security.AccessControlException: access denied (“javax.management.MBeanTrustPermission” “register”)</strong></p><p>改变 elasticsearch 文件夹所有者到当前用户</p><p>sudo chown -R noroot:noroot elasticsearch</p><p>这是因为 elasticsearch 需要读写配置文件，我们需要给予 config 文件夹权限，上面新建了 elsearch 用户，elsearch 用户不具备读写权限，因此还是会报错，解决方法是切换到管理员账户，赋予权限即可：</p><p>sudo -i</p><p>chmod -R 775 config</p><p><strong>2、[WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [] uncaught exception in thread [main]</strong><br><strong>org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root</strong></p><p>原因是elasticsearch默认是不支持用root用户来启动的。</p><p>解决方案一：Des.insecure.allow.root=true</p><p>修改/usr/local/elasticsearch-2.4.0/bin/elasticsearch，</p><p>添加 ES_JAVA_OPTS=”-Des.insecure.allow.root=true”</p><p>或执行时添加： sh /usr/local/elasticsearch-2.4.0/bin/elasticsearch -d -Des.insecure.allow.root=true</p><p>注意：正式环境用root运行可能会有安全风险，不建议用root来跑。</p><p>解决方案二：添加专门的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd elastic</span><br><span class="line">chown -R elastic:elastic  elasticsearch-2.4.0</span><br><span class="line">su elastic</span><br><span class="line">sh /usr/local/elasticsearch-2.4.0/bin/elasticsearch -d</span><br></pre></td></tr></table></figure><p><strong>3、UnsupportedOperationException: seccomp unavailable: requires kernel 3.5+ with CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in</strong></p><p>只是警告，使用新的linux版本，就不会出现此类问题了。</p><p><strong>4、ERROR: [4] bootstrap checks failed</strong><br><strong>[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</strong></p><p>原因：无法创建本地文件问题,用户最大可创建文件数太小</p><p>解决方案：切换到 root 用户，编辑 limits.conf 配置文件， 添加类似如下内容：</p><p>vim /etc/security/limits.conf</p><p>添加如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*  soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure><p><strong>[2]: max number of threads [1024] for user [tzs] is too low, increase to at least [2048]</strong></p><p>原因：无法创建本地线程问题,用户最大可创建线程数太小</p><p>解决方案：切换到root用户，进入limits.d目录下，修改90-nproc.conf 配置文件。</p><p>vim /etc/security/limits.d/90-nproc.conf</p><p>找到如下内容：</p><ul><li>soft nproc 1024</li></ul><p>修改为</p><ul><li>soft nproc 2048</li></ul><p><strong>[3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</strong></p><p>原因：最大虚拟内存太小</p><p>root用户执行命令：</p><p><code>sysctl -w vm.max_map_count=262144</code></p><p>或者修改 /etc/sysctl.conf 文件，添加 “vm.max_map_count”设置<br>设置后，可以使用<br>$ sysctl -p</p><p><strong>[4]: system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</strong></p><p>原因：Centos6不支持SecComp，而ES5.4.1默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。<br>详见 ：<a href="https://github.com/elastic/elasticsearch/issues/22899" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch/issues/22899</a></p><p>解决方法：在elasticsearch.yml中新增配置bootstrap.system_call_filter，设为false，注意要在Memory下面:<br>bootstrap.memory_lock: false<br>bootstrap.system_call_filter: false</p><p><strong>5、 java.lang.IllegalArgumentException: property [elasticsearch.version] is missing for plugin [head]</strong></p><p>再 es 的配置文件中加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>整个搭建的过程全程自己手动安装，不易，如果安装很多台机器，是否可以写个脚本之类的自动搭建呢？可以去想想的。首发于：<a href="http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/</a>   ，转载请注明出处，谢谢配合！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口。Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。基百科、Stack Overflow、Github 都采用它。&lt;/p&gt;
&lt;p&gt;本文从零开始，讲解如何使用 Elasticsearch 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。&lt;br&gt;
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="http://yoursite.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>谷歌开发者大会收获满满，不去真 “可惜” 了</title>
    <link href="http://yoursite.com/2018/01/21/Google-Developer-Days/"/>
    <id>http://yoursite.com/2018/01/21/Google-Developer-Days/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/1DJAFA7Kmb.png-1" alt="mark"><br>全文图片较多，请在 WiFi 下阅读，土豪请随意！<br><a id="more"></a></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>今年 Google 开发者大会再度来袭，大会将于 12 月 13 日和 14 日在上海举办，主题涵盖机器学习(Machine Learning)、Android、移动网络(Mobile Web)、TensorFlow、Firebase、云服务(Cloud)、AR/VR、设计(Design)以及更多开发者相关内容。</p><p>今天我就到走一遭，收获满满，都是用袋子提回来的，哈哈。下图为袋子：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/LB2im47IbD.png-1" alt="mark"></p><p>再秀张图代表我去了：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/ia81GicG37.png-1" alt="mark"></p><h3 id="入场"><a href="#入场" class="headerlink" title="入场"></a>入场</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/1DJAFA7Kmb.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/5KAJDGGGH5.png-1" alt="mark"></p><p>说下今天我参加的会场吧！</p><h3 id="会场"><a href="#会场" class="headerlink" title="会场"></a>会场</h3><h4 id="主会场开幕"><a href="#主会场开幕" class="headerlink" title="主会场开幕"></a>主会场开幕</h4><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/iKjbLIggh8.png-1" alt="mark"></p><p>当然是用来用来做开发者开幕大会主题演讲的。相信不少没到现场的也看了直播。</p><p>拍了两张李飞飞演讲时的照片：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/BggGaADkF7.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/KEAB816319.png-1" alt="mark"></p><p>还有个妹子是讲 TensorFlow 的，全程中文，还贼 6，佩服！！！</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/IbK91Af32b.png-1" alt="mark"></p><p>中途演讲还好几个，没拍照了。。。</p><h3 id="中途茶歇："><a href="#中途茶歇：" class="headerlink" title="中途茶歇："></a>中途茶歇：</h3><p>去外面看了下。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/dLm4BaJE4I.png-1" alt="mark"></p><h3 id="主会场演讲"><a href="#主会场演讲" class="headerlink" title="主会场演讲"></a>主会场演讲</h3><p>主题是：《渐进式网页应用：快速、集成、可靠并且具有吸引力》</p><p>这次坐的是前排，还拍了照，演讲人技巧很好，边演讲边带有身体动作的，而且还比较诙谐。</p><h3 id="午餐"><a href="#午餐" class="headerlink" title="午餐"></a>午餐</h3><p>胸牌上有13、14 号的午餐券，可以免费吃、免费拿，福利超好。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/b06B2HGeC4.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/6K2lChij33.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/lCf1afKlck.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/1IJ74dJ3c1.png-1" alt="mark"></p><h3 id="下午会场"><a href="#下午会场" class="headerlink" title="下午会场"></a>下午会场</h3><p><strong>下午会场有点多，略略略。。。</strong></p><p>都拍了点照，如果想要，可以加群：528776268  找我要、</p><h3 id="晚餐"><a href="#晚餐" class="headerlink" title="晚餐"></a>晚餐</h3><p>诱惑颇大。。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/agJcFAH7ea.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/G6G4d12jLF.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/7gm9hB1i41.png-1" alt="mark"></p><p>我还喝了杯葡萄酒。。哈哈</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/3iHm1dKfG2.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/232lbee3Dg.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/Dlb96kdIfh.png-1" alt="mark"></p><p>另外除了照片，还拍了三个视频</p><video width="400" height="800" controls="controls"><br>  <source src="http://ohfk1r827.bkt.clouddn.com/VID_20171213_183743.mp4" type="video/mp4"><br></video><p><br></p><video width="400" height="800" controls="controls"><br>  <source src="http://ohfk1r827.bkt.clouddn.com/VID_20171213_183253.mp4" type="video/mp4"><br></video><p><br></p><video width="400" height="800" controls="controls"><br>  <source src="http://ohfk1r827.bkt.clouddn.com/VID_20171213_185542.mp4" type="video/mp4"><br></video><h3 id="回家"><a href="#回家" class="headerlink" title="回家"></a>回家</h3><p>吃饱喝足，回家拍了张照</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/6ihACFehj9.png-1" alt="mark"></p><h3 id="礼物"><a href="#礼物" class="headerlink" title="礼物"></a>礼物</h3><p>到家了，整理了下今天的礼物：</p><p>贴纸一张</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/FbBIc9Gm7k.png-1" alt="mark"></p><p>小礼品一个</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/cilDBLBfDB.png-1" alt="mark"></p><p>一个可 DIY 的音箱</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/AIgb2iaEad.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/5aiiBhbAfc.png-1" alt="mark"></p><p>一个定制的手提电脑包，质量很好。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/Lm1D2J4L60.png-1" alt="mark"></p><p>AndroidThings</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/hABaggD631.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171213/gmf7K6Cfgl.png-1" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>全文图片较多，谢谢阅读！自己收获也挺多的，明天还有一天，可惜不打算去了，转载请注明地址：<a href="http://www.54tianzhisheng.cn/2017/12/13/Google-Developer-Days/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/12/13/Google-Developer-Days/</a></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>这个是为了防爬虫写的，哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/171213/1DJAFA7Kmb.png-1&quot; alt=&quot;mark&quot;&gt;&lt;br&gt;全文图片较多，请在 WiFi 下阅读，土豪请随意！&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Google Guava 缓存实现接口的限流</title>
    <link href="http://yoursite.com/2018/01/21/Guava-limit/"/>
    <id>http://yoursite.com/2018/01/21/Guava-limit/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/cb2.jpeg-1" alt=""><br><a id="more"></a></p><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>最近项目中需要进行接口保护，防止高并发的情况把系统搞崩，因此需要对一个查询接口进行限流，主要的目的就是限制单位时间内请求此查询的次数，例如 1000 次，来保护接口。<br>参考了 <a href="http://www.jianshu.com/p/0d7ca597ebd2" target="_blank" rel="noopener">开涛的博客聊聊高并发系统限流特技</a> ，学习了其中利用 Google Guava 缓存实现限流的技巧，在网上也查到了很多关于 Google Guava 缓存的博客，学到了好多，推荐一个博客文章：<a href="http://ifeve.com/google-guava-cachesexplained/" target="_blank" rel="noopener">http://ifeve.com/google-guava-cachesexplained/</a>, 关于 Google Guava 缓存的更多细节或者技术，这篇文章讲的很详细；<br>这里我们并不是用缓存来优化查询，而是利用缓存，存储一个计数器，然后用这个计数器来实现限流。</p><h3 id="效果实验"><a href="#效果实验" class="headerlink" title="效果实验"></a>效果实验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LoadingCache&lt;Long, AtomicLong&gt; count = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS).build(<span class="keyword">new</span> CacheLoader&lt;Long, AtomicLong&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AtomicLong <span class="title">load</span><span class="params">(Long o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//System.out.println("Load call!");</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面，我们通过 CacheBuilder 来新建一个 LoadingCache 缓存对象 count，然后设置其有效时间为 1 秒，即每 1 秒钟刷新一次；缓存中，key 为一个 long 型的时间戳类型，value 是一个计数器，使用原子性的 AtomicLong 保证自增和自减操作的原子性， 每次查询缓存时如果不能命中，即查询的时间戳不在缓存中，则重新加载缓存，执行 load 将当前的时间戳的计数值初始化为 0。这样对于每一秒的时间戳，能计算这一秒内执行的次数，从而达到限流的目的；<br>这是要执行的一个 getCounter 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCounter</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们创建多个线程来执行这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Counter.getCounter());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样执行的话，执行结果很简单，就是很快地执行这个 for 循环，迅速打印 0 到 99 折 100 个数，不再贴出。<br>这里的 for 循环执行 100 个进程时间是很快的，那么现在我们要限制每秒只能有 10 个线程来执行 getCounter() 方法，该怎么办呢，上面讲的限流方法就派上用场了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> LoadingCache&lt;Long, AtomicLong&gt; count = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS).build(<span class="keyword">new</span> CacheLoader&lt;Long, AtomicLong&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AtomicLong <span class="title">load</span><span class="params">(Long o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Load call!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> limits = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCounter</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取当前的时间戳作为key</span></span><br><span class="line">            Long currentSeconds = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (count.get(currentSeconds).getAndIncrement() &gt; limits) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，就可以限制每秒的执行数了。对于每个线程，获取当前时间戳，如果当前时间 (当前这 1 秒) 内有超过 10 个线程正在执行，那么这个进程一直在这里循环，直到下一秒，或者更靠后的时间，重新加载，执行 load，将新的时间戳的计数值重新为 0。<br>执行结果：<br><img src="http://img.blog.csdn.net/20160620150358906" alt=""><br>每秒执行 11 个（因为从 0 开始），每一秒之后，load 方法会执行一次；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">为了更加直观，我们可以让每个<span class="keyword">for</span>循环sleep一段时间：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Counter.getCounter());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述这样的情况下，一个线程如果遇到当前时间正在执行的线程超过 limit 值就会一直在 while 循环，这样会浪费大量的资源，我们在做限流的时候，如果出现这种情况，可以<strong>不进行 while 循环</strong>，而是直接抛出异常或者返回，来拒绝这次执行（查询），这样便可以节省资源。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本篇文章地址： <a href="http://www.54tianzhisheng.cn/2017/09/23/Guava-limit/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/09/23/Guava-limit/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/cb2.jpeg-1&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Guava" scheme="http://yoursite.com/tags/Guava/"/>
    
  </entry>
  
  <entry>
    <title>HBase 集群监控</title>
    <link href="http://yoursite.com/2018/01/21/HBase-metrics/"/>
    <id>http://yoursite.com/2018/01/21/HBase-metrics/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/cb8.jpg-1" alt=""></p><h3 id="为什么需要监控？"><a href="#为什么需要监控？" class="headerlink" title="为什么需要监控？"></a>为什么需要监控？</h3><p>为了保证系统的稳定性，可靠性，可运维性。<br><a id="more"></a></p><ol><li>掌控集群的核心性能指标，了解集群的性能表现。</li><li>集群出现问题时及时报警，便于运维同学及时修复问题。</li><li>集群重要指标值异常时进行预警，将问题扼杀在摇篮中，不用等集群真正不可用时才采取行动。</li><li>当集群出现问题时，监控系统可以帮助我们更快的定位问题和解决问题</li></ol><h3 id="如何构建-HBase-集群监控系统？"><a href="#如何构建-HBase-集群监控系统？" class="headerlink" title="如何构建 HBase 集群监控系统？"></a>如何构建 HBase 集群监控系统？</h3><p>公司有自己的监控系统，我们所要做的就是将 HBase 中我们关心的指标项发送到监控系统去，问题就转换为我们开发，采集并返回哪些 HBase 集群监控指标项。</p><h3 id="HBase-集群监控指标"><a href="#HBase-集群监控指标" class="headerlink" title="HBase 集群监控指标"></a>HBase 集群监控指标</h3><p>采集的监控数据主要包括以下几个方面：某台机器 OS 层面上的数据，例如 CPU、内存、磁盘、网络、load、网络流量等；某台 regionserver（或master）机器 jvm 的状态，例如关于线程的信息，GC 的次数和时间，内存使用状况，以及 ERROR、WARN、Fatal 事件出现的次数；regionserver（或 master）进程中的统计信息。</p><p>可以通过以下地址获取 HBase 提供的 JMX 信息的 web 页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your_master:60010/jmx  //所有的bean</span><br></pre></td></tr></table></figure><p>JMX web 页面的数据格式是<code>json</code>格式，信息很多！</p><h4 id="OS-监控数据"><a href="#OS-监控数据" class="headerlink" title="OS 监控数据"></a>OS 监控数据</h4><p>HBase 中对于 OS 的监控数据，主要是 OperatingSystem 的对象来进行的，如下就是我提取出来的 JSON 信息，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"java.lang:type=OperatingSystem"</span>,</span><br><span class="line">    <span class="attr">"modelerType"</span> : <span class="string">"com.sun.management.UnixOperatingSystem"</span>,</span><br><span class="line">    <span class="attr">"MaxFileDescriptorCount"</span> : <span class="number">1000000</span>,</span><br><span class="line">    <span class="attr">"OpenFileDescriptorCount"</span> : <span class="number">413</span>,</span><br><span class="line">    <span class="attr">"CommittedVirtualMemorySize"</span> : <span class="number">1892225024</span>,</span><br><span class="line">    <span class="attr">"FreePhysicalMemorySize"</span> : <span class="number">284946432</span>,</span><br><span class="line">    <span class="attr">"FreeSwapSpaceSize"</span> : <span class="number">535703552</span>,</span><br><span class="line">    <span class="attr">"ProcessCpuLoad"</span> : <span class="number">0.0016732901066722444</span>,</span><br><span class="line">    <span class="attr">"ProcessCpuTime"</span> : <span class="number">59306210000000</span>,</span><br><span class="line">    <span class="attr">"SystemCpuLoad"</span> : <span class="number">0.018197029910060655</span>,</span><br><span class="line">    <span class="attr">"TotalPhysicalMemorySize"</span> : <span class="number">16660848640</span>,</span><br><span class="line">    <span class="attr">"TotalSwapSpaceSize"</span> : <span class="number">536862720</span>,</span><br><span class="line">    <span class="attr">"AvailableProcessors"</span> : <span class="number">8</span>,</span><br><span class="line">    <span class="attr">"Arch"</span> : <span class="string">"amd64"</span>,</span><br><span class="line">    <span class="attr">"SystemLoadAverage"</span> : <span class="number">0.0</span>,</span><br><span class="line">    <span class="attr">"Name"</span> : <span class="string">"Linux"</span>,</span><br><span class="line">    <span class="attr">"Version"</span> : <span class="string">"2.6.32-431.11.7.el6.ucloud.x86_64"</span>,</span><br><span class="line">    <span class="attr">"ObjectName"</span> : <span class="string">"java.lang:type=OperatingSystem"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中比较重要的指标有 <code>OpenFileDescriptorCount</code> ,  <code>FreePhysicalMemorySize</code> ,  <code>ProcessCpuLoad</code> , <code>SystemCpuLoad</code> ,  <code>AvailableProcessors</code> ,  <code>SystemLoadAverage</code></p><h4 id="JVM-监控数据"><a href="#JVM-监控数据" class="headerlink" title="JVM 监控数据"></a>JVM 监控数据</h4><p>Hbase 中对于 JVM 的监控数据，主要是 JvmMetrics 的对象来进行的，如下就是我提取出来的 JSON 信息，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Hadoop:service=HBase,name=JvmMetrics"</span>,</span><br><span class="line">    <span class="attr">"modelerType"</span> : <span class="string">"JvmMetrics"</span>,</span><br><span class="line">    <span class="attr">"tag.Context"</span> : <span class="string">"jvm"</span>,</span><br><span class="line">    <span class="attr">"tag.ProcessName"</span> : <span class="string">"Master"</span>,</span><br><span class="line">    <span class="attr">"tag.SessionId"</span> : <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"tag.Hostname"</span> : <span class="string">"uhadoop-qrljqo-master2"</span>,</span><br><span class="line">    <span class="attr">"MemNonHeapUsedM"</span> : <span class="number">53.846107</span>,</span><br><span class="line">    <span class="attr">"MemNonHeapCommittedM"</span> : <span class="number">85.84375</span>,</span><br><span class="line">    <span class="attr">"MemNonHeapMaxM"</span> : <span class="number">130.0</span>,</span><br><span class="line">    <span class="attr">"MemHeapUsedM"</span> : <span class="number">79.05823</span>,</span><br><span class="line">    <span class="attr">"MemHeapCommittedM"</span> : <span class="number">240.125</span>,</span><br><span class="line">    <span class="attr">"MemHeapMaxM"</span> : <span class="number">989.875</span>,</span><br><span class="line">    <span class="attr">"MemMaxM"</span> : <span class="number">989.875</span>,</span><br><span class="line">    <span class="attr">"GcCountParNew"</span> : <span class="number">15190</span>,</span><br><span class="line">    <span class="attr">"GcTimeMillisParNew"</span> : <span class="number">72300</span>,</span><br><span class="line">    <span class="attr">"GcCountConcurrentMarkSweep"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"GcTimeMillisConcurrentMarkSweep"</span> : <span class="number">319</span>,</span><br><span class="line">    <span class="attr">"GcCount"</span> : <span class="number">15192</span>,</span><br><span class="line">    <span class="attr">"GcTimeMillis"</span> : <span class="number">72619</span>,</span><br><span class="line">    <span class="attr">"ThreadsNew"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"ThreadsRunnable"</span> : <span class="number">21</span>,</span><br><span class="line">    <span class="attr">"ThreadsBlocked"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"ThreadsWaiting"</span> : <span class="number">144</span>,</span><br><span class="line">    <span class="attr">"ThreadsTimedWaiting"</span> : <span class="number">18</span>,</span><br><span class="line">    <span class="attr">"ThreadsTerminated"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"LogFatal"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"LogError"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"LogWarn"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"LogInfo"</span> : <span class="number">0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> JvmMetrics 主要统计的信息包括：内存的使用状态信息；GC的统计信息；线程的统计信息；以及事件的统计信息。</p><p>内存的统计信息主要是：JVM 当前已经使用的 NonHeapMemory 的大小、以及配置的 NonHeapMemory 的大小；JVM 当前已经使用的 HeapMemory 的大小、以及配置的 HeapMemory 的大小； JVM 运行时的可以使用的最大的内存的大小。</p><p>GC 的统计较为简单，仅统计了进程在固定间隔内 GC 的次数和花费的总时间。</p><p>线程的统计，主要是统计进程内当前线程的处于 NEW 、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED 这六种状态下的线程数量。</p><p>对于事件的统计，主要统计固定时间间隔内的 Fatal、Error、Warn 以及 Info 的数量。(这块好像不怎么重要)</p><h4 id="Region-Servers-健康"><a href="#Region-Servers-健康" class="headerlink" title="Region Servers 健康"></a>Region Servers 健康</h4><p>你也可以通过如下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your_master:60010/jmx?qry=Hadoop:service=HBase,name=Master,sub=Server</span><br></pre></td></tr></table></figure><p>获得到 Region Servers 健康值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Hadoop:service=HBase,name=Master,sub=Server"</span>,</span><br><span class="line">    <span class="attr">"modelerType"</span> : <span class="string">"Master,sub=Server"</span>,</span><br><span class="line">    <span class="attr">"tag.liveRegionServers"</span> : <span class="string">"xxx"</span>,</span><br><span class="line">    <span class="attr">"tag.deadRegionServers"</span> : <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"tag.zookeeperQuorum"</span> : <span class="string">"xxx"</span>,</span><br><span class="line">    <span class="attr">"tag.serverName"</span> : <span class="string">"xxx2,60000,1495683310213"</span>,</span><br><span class="line">    <span class="attr">"tag.clusterId"</span> : <span class="string">"e5e044a3-ef9f-48f7-ba63-637376f5fa90"</span>,</span><br><span class="line">    <span class="attr">"tag.isActiveMaster"</span> : <span class="string">"true"</span>,</span><br><span class="line">    <span class="attr">"tag.Context"</span> : <span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"tag.Hostname"</span> : <span class="string">"xxx"</span>,</span><br><span class="line">    <span class="attr">"masterActiveTime"</span> : <span class="number">1495683312239</span>,</span><br><span class="line">    <span class="attr">"masterStartTime"</span> : <span class="number">1495683310213</span>,</span><br><span class="line">    <span class="attr">"averageLoad"</span> : <span class="number">143.66666666666666</span>,</span><br><span class="line">    <span class="attr">"numRegionServers"</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"numDeadRegionServers"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"clusterRequests"</span> : <span class="number">1297834323</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="MemoryPool"><a href="#MemoryPool" class="headerlink" title="MemoryPool"></a>MemoryPool</h4><p>从全部的 JSON 值中你会看到很多种 MemoryPool 值，比如 Par Eden Space 、CMS Perm Gen、Par Survivor Space、CMS Old Gen、Code Cache ，按需获取吧。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>任何一个服务的监控系统都是一个不断迭代，不断优化的过程，不可能一开始就做到最好。监控总是比问题发生来的更早一些，而每一次出问题，又进一步加强相应方面的监控，我们需要让监控系统从出问题时才报警到可能出现问题时就预警逐渐过渡，最终让监控系统成为我们保证系统稳定性的一个有力工具。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>监控指标有很多，但请按需获取 ! 转载文章请注明原出处，谢谢支持！  <a href="http://www.54tianzhisheng.cn/2017/10/21/HBase-metrics/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/10/21/HBase-metrics/</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1、<a href="https://www.tuicool.com/articles/zQNrM3" target="_blank" rel="noopener">hbase性能监控（一）</a></p><p>2、<a href="https://www.tuicool.com/articles/YbQbIj" target="_blank" rel="noopener">hbase性能监控（二）</a></p><p>3、<a href="https://www.tuicool.com/articles/imArAb" target="_blank" rel="noopener">hbase性能监控（三）</a></p><p>4、<a href="https://blog.bcmeng.com/post/hbase-monitor.html" target="_blank" rel="noopener">HBase 集群监控系统构建</a></p><p>5、<a href="http://blog.csdn.net/englishsname/article/details/53883682" target="_blank" rel="noopener">hbase jmx常用监控指标</a></p><h3 id="推荐相关文章"><a href="#推荐相关文章" class="headerlink" title="推荐相关文章"></a>推荐相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2017/10/18/ElasticSearch-nodes-metrics/" target="_blank" rel="noopener">ElasticSearch 单个节点监控</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/10/15/ElasticSearch-cluster-health-metrics/" target="_blank" rel="noopener">ElasticSearch 集群监控</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/cb8.jpg-1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么需要监控？&quot;&gt;&lt;a href=&quot;#为什么需要监控？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要监控？&quot;&gt;&lt;/a&gt;为什么需要监控？&lt;/h3&gt;&lt;p&gt;为了保证系统的稳定性，可靠性，可运维性。&lt;br&gt;
    
    </summary>
    
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>Github pages + Hexo 博客 yilia 主题使用畅言评论系统</title>
    <link href="http://yoursite.com/2018/01/21/Hexo-yilia-changyan/"/>
    <id>http://yoursite.com/2018/01/21/Hexo-yilia-changyan/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Hexo的Yilia主题由于原来使用的是多说的留言板，近期<a href="http://dev.duoshuo.com/threads/58d1169ae293b89a20c57241" target="_blank" rel="noopener">多说公告要停止提供服务</a>了，所以我就把多说换成搜狐的畅言了，下面写一个简单的小教程。</p><p><img src="http://img.blog.csdn.net/20170413231005895?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHpzXzEwNDEyMTgxMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="duoshuo"></p><h3 id="注册畅言"><a href="#注册畅言" class="headerlink" title="注册畅言"></a>注册畅言</h3><p>进入<a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言官网</a> , 点击右上角 “免费注册”，并填写注册信息。（注意域名需要备案信息）</p><a id="more"></a><h3 id="登录并进入畅言后台"><a href="#登录并进入畅言后台" class="headerlink" title="登录并进入畅言后台"></a>登录并进入畅言后台</h3><p>注册完后，登录进入畅言官网，获取你的畅言 <strong>app id</strong> 和 <strong>app key</strong>。</p><p><img src="http://img.blog.csdn.net/20170413231102348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHpzXzEwNDEyMTgxMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="id"></p><h3 id="使用畅言系统"><a href="#使用畅言系统" class="headerlink" title="使用畅言系统"></a>使用畅言系统</h3><p>下面说下修改评论为<strong>畅言</strong>的方法，其实方法和多说是差不多的。</p><p>1、修改 <code>themes\yilia\layout\_partial\article.ejs</code> 模板，把如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class="line"> &lt;section id=<span class="string">"comments"</span>&gt;</span><br><span class="line">   &lt;div id=<span class="string">"disqus_thread"</span>&gt;</span><br><span class="line">     这里还有很多代码</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>section&gt;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> &lt;% if (!index &amp;&amp; post.comments)&#123; %&gt;</span><br><span class="line">  &lt;section id=&quot;comments&quot;&gt;</span><br><span class="line">&lt;!--高速版，加载速度快，使用前需测试页面的兼容性--&gt;</span><br><span class="line">&lt;div id=&quot;SOHUCS&quot; sid=&quot;&lt;%= page.title %&gt;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  (function()&#123;</span><br><span class="line">    var appid = &apos;你的APP ID&apos;,</span><br><span class="line">    conf = &apos;你的APP KEY&apos;;</span><br><span class="line">    var doc = document,</span><br><span class="line">    s = doc.createElement(&apos;script&apos;),</span><br><span class="line">    h = doc.getElementsByTagName(&apos;head&apos;)[0] || doc.head || doc.documentElement;</span><br><span class="line">    s.type = &apos;text/javascript&apos;;</span><br><span class="line">    s.charset = &apos;utf-8&apos;;</span><br><span class="line">    s.src =  &apos;http://assets.changyan.sohu.com/upload/changyan.js?conf=&apos;+ conf +&apos;&amp;appid=&apos; + appid;</span><br><span class="line">    h.insertBefore(s,h.firstChild);</span><br><span class="line">    window.SCS_NO_IFRAME = true;</span><br><span class="line">  &#125;)()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>上面的<code>APP ID</code>和<code>APP KEY</code>是在畅言设置中得到。</p><p>这里需要<strong>注意</strong>一点的是：<code>sid=&quot;&lt;%= page.title %&gt;&quot;&gt;</code> 这样的话畅言就可以直接根据对应的文章来识别，使得文章有对应的评论，不会都乱在一起。</p><p>2、在每篇文章开头的 front-matter 中添加一句<code>comments: true</code>，然后回到博客根目录执行命令 <code>hexo d -g</code> ，重新生成博客并部署博客，然后刷新，任选一篇文章进入下拉，会发现评论功能可以使用了。</p><p><img src="http://img.blog.csdn.net/20170413231216474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHpzXzEwNDEyMTgxMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="comments"></p><h3 id="修改-BUG"><a href="#修改-BUG" class="headerlink" title="修改 BUG"></a>修改 BUG</h3><p>但是，这是你会发现一个 Bug，表情按钮点击不了，原因是被左侧的 div 层覆盖了，回到我们刚才改过的代码，找到 <code>&lt;div id=&quot;SOHUCS&quot;</code> 开头的一串代码。并做如下更改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"SOHUCS"</span> <span class="attr">sid</span>=<span class="string">"&lt;%=title %&gt;"</span> <span class="attr">style</span>=<span class="string">"padding: 0px 30px 0px 46px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加上上面这一段样式代码，即可修复。</p><hr><p>参考文章：</p><p>1、<a href="http://www.luck666.cn/2017/03/22/hexo-yilia-changyan/" target="_blank" rel="noopener">Hexo博客yilia主题更换畅言评论系统</a></p><p>2、<a href="http://www.lichanglin.cn/%E5%9C%A8Hexo%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">在Hexo中使用畅言评论系统</a></p><hr><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>由于问题太多了，所以新写了篇文章：<a href="http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia/" target="_blank" rel="noopener">Github page + Hexo + yilia 搭建博客可能会遇到的所有疑问</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Hexo的Yilia主题由于原来使用的是多说的留言板，近期&lt;a href=&quot;http://dev.duoshuo.com/threads/58d1169ae293b89a20c57241&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多说公告要停止提供服务&lt;/a&gt;了，所以我就把多说换成搜狐的畅言了，下面写一个简单的小教程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170413231005895?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHpzXzEwNDEyMTgxMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;duoshuo&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;注册畅言&quot;&gt;&lt;a href=&quot;#注册畅言&quot; class=&quot;headerlink&quot; title=&quot;注册畅言&quot;&gt;&lt;/a&gt;注册畅言&lt;/h3&gt;&lt;p&gt;进入&lt;a href=&quot;http://changyan.kuaizhan.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;畅言官网&lt;/a&gt; , 点击右上角 “免费注册”，并填写注册信息。（注意域名需要备案信息）&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="yilia" scheme="http://yoursite.com/tags/yilia/"/>
    
  </entry>
  
  <entry>
    <title>HashMap、Hashtable、HashSet 和 ConcurrentHashMap 的比较</title>
    <link href="http://yoursite.com/2018/01/21/HashMap-Hashtable/"/>
    <id>http://yoursite.com/2018/01/21/HashMap-Hashtable/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap 和 Hashtable 的比较是 Java 面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap 的工作原理、ArrayList 与 Vector 的比较以及这个问题是有关 Java 集合框架的最经典的问题。Hashtable 是个过时的集合类，存在于 Java API 中很久了。在 Java 4 中被重写了，实现了 Map 接口，所以自此以后也成了 Java 集合框架中的一部分。Hashtable 和 HashMap 在 Java 面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何 Java 面试之前，都不要忘了准备这一题。<br><a id="more"></a><br>这篇文章中，我们不仅将会看到 HashMap 和 Hashtable 的区别，还将看到它们之间的相似之处。</p><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><p>HashMap 和 Hashtable 都实现了 Map 接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步 (synchronization)，以及速度。</p><ol><li>HashMap 几乎可以等价于 Hashtable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值 (key) 和值 (value)，而 Hashtable 则不行)。</li><li>HashMap 是非 synchronized，而 Hashtable 是 synchronized，这意味着 Hashtable 是线程安全的，多个线程可以共享一个 Hashtable；而如果没有正确的同步的话，多个线程是不能共享 HashMap 的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable 的扩展性更好。</li><li>另一个区别是 HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，而 Hashtable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的 remove() 方法移除元素则不会抛出ConcurrentModificationException 异常。但这并不是一个一定发生的行为，要看 JVM。这条同样也是Enumeration 和 Iterato r的区别。</li><li>由于 Hashtable 是线程安全的也是 synchronized，所以在单线程环境下它比 HashMap 要慢。如果你不需要同步，只需要单一线程，那么使用 HashMap 性能要好过 Hashtable。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ol><h3 id="要注意的一些重要术语："><a href="#要注意的一些重要术语：" class="headerlink" title="要注意的一些重要术语："></a>要注意的一些重要术语：</h3><p>1) sychronized 意味着在一次仅有一个线程能够更改 Hashtable。就是说任何线程要更新 Hashtable 时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新 Hashtable。</p><p>2) Fail-safe 和 iterator 迭代器相关。如果某个集合对象创建了 Iterator 或者 ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出 ConcurrentModificationException 异常。但其它线程可以通过 set() 方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用 set() 方法，将会抛出 IllegalArgumentException 异常。</p><p>3) 结构上的更改指的是删除或者插入一个元素，这样会影响到 map 的结构。</p><h3 id="我们能否让-HashMap-同步？"><a href="#我们能否让-HashMap-同步？" class="headerlink" title="我们能否让 HashMap 同步？"></a>我们能否让 HashMap 同步？</h3><p>HashMap 可以通过下面的语句进行同步：<br>Map m = Collections.synchronizeMap(hashMap);</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Hashtable 和 HashMap 有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用 Java 5 或以上的话，请使用 ConcurrentHashMap 吧。</p><p>转载自：<a href="http://www.importnew.com/7010.html" target="_blank" rel="noopener">HashMap和Hashtable的区别</a></p><hr><p>关于 HashMap 线程不安全这一点，《Java并发编程的艺术》一书中是这样说的：</p><blockquote><p>HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近 100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环。</p></blockquote><p>原因：</p><ul><li><a href="http://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">疫苗：JAVA HASHMAP的死循环 —— 酷壳</a></li><li><a href="http://firezhfox.iteye.com/blog/2241043" target="_blank" rel="noopener">HashMap在java并发中如何发生死循环</a></li><li><a href="http://coding-geek.com/how-does-a-hashmap-work-in-java/" target="_blank" rel="noopener">How does a HashMap work in JAVA</a></li></ul><hr><p>下面的是自己有道云笔记中记录的：</p><p><strong>HashMap ， HashTable 和 HashSet 区别</strong></p><ol><li>关于 HashMap 的一些说法：</li></ol><p>a)  HashMap 实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap 的底层结构是一个数组，数组中的每一项是一条链表。</p><p>b)  HashMap 的实例有俩个参数影响其性能： “初始容量” 和 装填因子。</p><p>c)  HashMap 实现不同步，线程不安全。  HashTable 线程安全</p><p>d)  HashMap 中的 key-value 都是存储在 Entry 中的。</p><p>e)  HashMap 可以存 null 键和 null 值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode() 方法和 equals 方法保证键的唯一性</p><p>f)  解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap 是采用拉链法解决哈希冲突的。</p><p>注： 链表法是将相同 hash 值的对象组成一个链表放在 hash 值对应的槽位；</p><p>用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。</p><p>拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。</p><ol><li>Hashtable 和 HashMap 的区别：</li></ol><p>a)   继承不同。</p><p> public class Hashtable extends Dictionary implements Map</p><p>public class HashMap extends  AbstractMap implements Map</p><p>b)  Hashtable 中的方法是同步的，而 HashMap 中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用 Hashtable，但是要使用 HashMap 的话就要自己增加同步处理了。</p><p>c)  Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。</p><p>d)  两个遍历方式的内部实现上不同。Hashtable、HashMap 都使用了Iterator。而由于历史原因，Hashtable还使用了 Enumeration 的方式 。</p><p>e)  哈希值的使用不同，HashTable 直接使用对象的 hashCode。而 HashMap 重新计算 hash 值。</p><p>f)  Hashtable 和 HashMap 它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable 中 hash 数组默认大小是11，增加的方式是 old*2+1。HashMap 中 hash 数组的默认大小是 16，而且一定是2的指数。</p><p>注：  HashSet 子类依靠 hashCode() 和 equal() 方法来区分重复元素。</p><p>HashSet 内部使用 Map 保存数据，即将 HashSet 的数据作为 Map 的 key 值保存，这也是 HashSet 中元素不能重复的原因。而 Map 中保存 key 值的,会去判断当前 Map 中是否含有该 Key 对象，内部是先通过 key 的hashCode, 确定有相同的 hashCode 之后，再通过 equals 方法判断是否相同。</p><hr><p>《HashMap 的工作原理》</p><p>HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道 Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！</p><h3 id="先来些简单的问题"><a href="#先来些简单的问题" class="headerlink" title="先来些简单的问题"></a>先来些简单的问题</h3><p><strong>“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</strong></p><p>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p><p><strong>“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</strong></p><p>你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。”</p><p>但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：</p><p><strong>“当两个对象的hashcode相同会发生什么？”</strong> </p><p>从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：</p><p><strong>“如果两个键的hashcode相同，你如何获取值对象？”</strong></p><p> 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。</p><p>其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！</p><p>许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p><p>如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。</p><p><strong>“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”</strong></p><p>除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p><p>如果你能够回答这道问题，下面的问题来了：</p><p><strong>“你了解重新调整HashMap大小存在什么问题吗？”</strong></p><p>你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。</p><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）</p><p>热心的读者贡献了更多的关于HashMap的问题：</p><ol><li><p><strong>为什么String, Interger这样的wrapper类适合作为键？</strong> </p><p>String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</p></li><li><p><strong>我们可以使用自定义的对象作为键吗？</strong> </p><p>这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。</p></li><li><p><strong>我们可以使用CocurrentHashMap来代替Hashtable吗？</strong></p><p>这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看 <a href="http://javarevisited.blogspot.sg/2011/04/difference-between-concurrenthashmap.html" target="_blank" rel="noopener">这篇博客</a> 查看Hashtable和ConcurrentHashMap的区别。</p></li></ol><p>我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：</p><ul><li>hashing的概念</li><li>HashMap中解决碰撞的方法</li><li>equals()和hashCode()的应用，以及它们在HashMap中的重要性</li><li>不可变对象的好处</li><li>HashMap多线程的条件竞争</li><li>重新调整HashMap的大小</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h4><p>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p><p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p><p>因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。你可以查看更多的关于HashMap的文章:</p><ul><li><a href="http://www.importnew.com/7010.html" target="_blank" rel="noopener">HashMap和Hashtable的区别</a></li><li><a href="http://www.importnew.com/6931.html" target="_blank" rel="noopener">HashMap和HashSet的区别</a></li></ul><p>转载自：<a href="http://www.importnew.com/7099.html" target="_blank" rel="noopener">HashMap的工作原理</a></p><hr><p>其他的 HashMap 学习资料：</p><ul><li><a href="https://segmentfault.com/a/1190000003617333" target="_blank" rel="noopener">jdk7中HashMap知识点整理</a></li><li><a href="http://blog.csdn.net/q291611265/article/details/46797557" target="_blank" rel="noopener">HashMap源码分析（四）put-jdk8-红黑树的引入</a></li><li><a href="https://my.oschina.net/hosee/blog/618953" target="_blank" rel="noopener">JDK7与JDK8中HashMap的实现</a></li><li><a href="https://wenku.baidu.com/view/6e1035943968011ca30091cd.html" target="_blank" rel="noopener">JDK1.8HashMap原理和源码分析(java面试收藏)</a></li><li><a href="http://www.jianshu.com/p/e694f1e868ec" target="_blank" rel="noopener">谈谈ConcurrentHashMap1.7和1.8的不同实现</a></li><li><a href="https://my.oschina.net/pingpangkuangmo/blog/817973" target="_blank" rel="noopener">jdk1.8的HashMap和ConcurrentHashMap</a></li><li><a href="http://blog.csdn.net/u010723709/article/details/48007881" target="_blank" rel="noopener">ConcurrentHashMap源码分析（JDK8版本）</a></li></ul><hr><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>谢谢阅读，如果可以的话欢迎大家转发和点赞。如需转载注明<a href="www.54tianzhisheng.cn/2017/06/10/HashMap-Hashtable/">原地址</a>就行。</p><p>群 528776268 欢迎各位大牛进群一起讨论。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/1473414112000.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap 和 Hashtable 的比较是 Java 面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap 的工作原理、ArrayList 与 Vector 的比较以及这个问题是有关 Java 集合框架的最经典的问题。Hashtable 是个过时的集合类，存在于 Java API 中很久了。在 Java 4 中被重写了，实现了 Map 接口，所以自此以后也成了 Java 集合框架中的一部分。Hashtable 和 HashMap 在 Java 面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何 Java 面试之前，都不要忘了准备这一题。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + yilia 主题实现文章目录</title>
    <link href="http://yoursite.com/2018/01/21/Hexo-yilia-toc/"/>
    <id>http://yoursite.com/2018/01/21/Hexo-yilia-toc/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>为了方便查看每篇文章的目录结构，可以定位到想看的地方，特地找了下如何实现这个功能。</p><h3 id="添加-CSS-样式"><a href="#添加-CSS-样式" class="headerlink" title="添加 CSS 样式"></a>添加 CSS 样式</h3><p>打开 <code>themes\yilia\source</code> 下的 <code>main.234bc0.css</code> 文件，直接在后面添加如下代码：<br><a id="more"></a><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 新添加的 */</span></span><br><span class="line"><span class="selector-id">#container</span> <span class="selector-class">.show-toc-btn</span>,<span class="selector-id">#container</span> <span class="selector-class">.toc-article</span>&#123;<span class="attribute">display</span>:block&#125;</span><br><span class="line"><span class="selector-class">.toc-article</span>&#123;<span class="attribute">z-index</span>:<span class="number">100</span>;<span class="attribute">background</span>:<span class="number">#fff</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ccc</span>;<span class="attribute">max-width</span>:<span class="number">250px</span>;<span class="attribute">min-width</span>:<span class="number">150px</span>;<span class="attribute">max-height</span>:<span class="number">500px</span>;<span class="attribute">overflow-y</span>:auto;<span class="attribute">-webkit-box-shadow</span>:<span class="number">5px</span> <span class="number">5px</span> <span class="number">2px</span> <span class="number">#ccc</span>;<span class="attribute">box-shadow</span>:<span class="number">5px</span> <span class="number">5px</span> <span class="number">2px</span> <span class="number">#ccc</span>;<span class="attribute">font-size</span>:<span class="number">12px</span>;<span class="attribute">padding</span>:<span class="number">10px</span>;<span class="attribute">position</span>:fixed;<span class="attribute">right</span>:<span class="number">35px</span>;<span class="attribute">top</span>:<span class="number">129px</span>&#125;<span class="selector-class">.toc-article</span> <span class="selector-class">.toc-close</span>&#123;<span class="attribute">font-weight</span>:<span class="number">700</span>;<span class="attribute">font-size</span>:<span class="number">20px</span>;<span class="attribute">cursor</span>:pointer;<span class="attribute">float</span>:right;<span class="attribute">color</span>:<span class="number">#ccc</span>&#125;<span class="selector-class">.toc-article</span> <span class="selector-class">.toc-close</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:<span class="number">#000</span>&#125;<span class="selector-class">.toc-article</span> <span class="selector-class">.toc</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">line-height</span>:<span class="number">20px</span>&#125;<span class="selector-class">.toc-article</span> <span class="selector-class">.toc</span> <span class="selector-class">.toc-number</span>&#123;<span class="attribute">color</span>:<span class="number">#333</span>&#125;<span class="selector-class">.toc-article</span> <span class="selector-class">.toc</span> <span class="selector-class">.toc-text</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">text-decoration</span>:underline;<span class="attribute">color</span>:<span class="number">#2a6496</span>&#125;<span class="selector-class">.toc-article</span> <span class="selector-tag">li</span>&#123;<span class="attribute">list-style-type</span>:none&#125;<span class="selector-class">.toc-article</span> <span class="selector-class">.toc-level-1</span>&#123;<span class="attribute">margin</span>:<span class="number">4px</span> <span class="number">0</span>&#125;<span class="selector-class">.toc-article</span> <span class="selector-class">.toc-child</span>&#123;&#125;@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> cd-bounce-<span class="number">1</span>&#123;0%&#123;<span class="attribute">opacity</span>:<span class="number">0</span>;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1)&#125;60%&#123;<span class="attribute">opacity</span>:<span class="number">1</span>;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1.01)&#125;100%&#123;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1)&#125;&#125;@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> cd-bounce-<span class="number">1</span>&#123;0%&#123;<span class="attribute">opacity</span>:<span class="number">0</span>;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1)&#125;60%&#123;<span class="attribute">opacity</span>:<span class="number">1</span>;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1.01)&#125;100%&#123;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1)&#125;&#125;@-<span class="keyword">o</span>-<span class="keyword">keyframes</span> cd-bounce-<span class="number">1</span>&#123;0%&#123;<span class="attribute">opacity</span>:<span class="number">0</span>;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1)&#125;60%&#123;<span class="attribute">opacity</span>:<span class="number">1</span>;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1.01)&#125;100%&#123;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1)&#125;&#125;@<span class="keyword">keyframes</span> cd-bounce-<span class="number">1</span>&#123;0%&#123;<span class="attribute">opacity</span>:<span class="number">0</span>;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1)&#125;60%&#123;<span class="attribute">opacity</span>:<span class="number">1</span>;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1.01);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1.01)&#125;100%&#123;<span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-moz-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(1);<span class="attribute">transform</span>:<span class="built_in">scale</span>(1)&#125;&#125;<span class="selector-class">.show-toc-btn</span>&#123;<span class="attribute">display</span>:none;<span class="attribute">z-index</span>:<span class="number">10</span>;<span class="attribute">width</span>:<span class="number">30px</span>;<span class="attribute">min-height</span>:<span class="number">14px</span>;<span class="attribute">overflow</span>:hidden;<span class="attribute">padding</span>:<span class="number">4px</span> <span class="number">6px</span> <span class="number">8px</span> <span class="number">5px</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;<span class="attribute">border-right</span>:none;<span class="attribute">position</span>:fixed;<span class="attribute">right</span>:<span class="number">40px</span>;<span class="attribute">text-align</span>:center;<span class="attribute">background-color</span>:<span class="number">#f9f9f9</span>&#125;<span class="selector-class">.show-toc-btn</span> <span class="selector-class">.btn-bg</span>&#123;<span class="attribute">margin-top</span>:<span class="number">2px</span>;<span class="attribute">display</span>:block;<span class="attribute">width</span>:<span class="number">16px</span>;<span class="attribute">height</span>:<span class="number">14px</span>;<span class="attribute">background</span>:<span class="built_in">url</span>(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;<span class="attribute">-webkit-background-size</span>:<span class="number">100%</span>;<span class="attribute">-moz-background-size</span>:<span class="number">100%</span>;<span class="attribute">background-size</span>:<span class="number">100%</span>&#125;<span class="selector-class">.show-toc-btn</span> <span class="selector-class">.btn-text</span>&#123;<span class="attribute">color</span>:<span class="number">#999</span>;<span class="attribute">font-size</span>:<span class="number">12px</span>&#125;<span class="selector-class">.show-toc-btn</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">cursor</span>:pointer&#125;<span class="selector-class">.show-toc-btn</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.btn-bg</span>&#123;<span class="attribute">background-position</span>:<span class="number">0</span> -<span class="number">16px</span>&#125;<span class="selector-class">.show-toc-btn</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.btn-text</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;<span class="attribute">color</span>:<span class="number">#ea8010</span>&#125;</span><br><span class="line"><span class="selector-class">.toc-article</span> <span class="selector-tag">li</span> <span class="selector-tag">ol</span>, <span class="selector-class">.toc-article</span> <span class="selector-tag">li</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.toc-article</span> <span class="selector-tag">ol</span>, <span class="selector-class">.toc-article</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改-article-ejs-文件"><a href="#修改-article-ejs-文件" class="headerlink" title="修改 article.ejs 文件"></a>修改 article.ejs 文件</h3><p>打开 <code>themes\yilia\layout\_partial</code> 文件夹下的 <code>article.ejs</code> 文件,  在 <code>&lt;/header&gt; &lt;% } %&gt;</code> 下面加入如下内容（注意位置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 目录内容 --&gt;</span><br><span class="line">&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;</span><br><span class="line">    &lt;p class=&quot;show-toc-btn&quot; id=&quot;show-toc-btn&quot; onclick=&quot;showToc();&quot; style=&quot;display:none&quot;&gt;</span><br><span class="line">          &lt;span class=&quot;btn-bg&quot;&gt;&lt;/span&gt;</span><br><span class="line">          &lt;span class=&quot;btn-text&quot;&gt;文章导航&lt;/span&gt;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">&lt;div id=&quot;toc-article&quot; class=&quot;toc-article&quot;&gt;</span><br><span class="line">    &lt;span id=&quot;toc-close&quot; class=&quot;toc-close&quot; title=&quot;隐藏导航&quot; onclick=&quot;showBtn();&quot;&gt;×&lt;/span&gt;</span><br><span class="line">&lt;strong class=&quot;toc-title&quot;&gt;文章目录&lt;/strong&gt;</span><br><span class="line">           &lt;%- toc(post.content) %&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function showToc()&#123;</span><br><span class="line">var toc_article = document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">toc_article.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">function showBtn()&#123;</span><br><span class="line">var toc_article = document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">toc_article.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">&lt;!-- 目录内容结束 --&gt;</span><br></pre></td></tr></table></figure><p>然后若想要文章显示目录，在每篇文章开头加入：<code>toc: true</code>  即可。</p><p>参考文章：<a href="http://lawlite.me/2017/04/17/Hexo-yilia%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%A7%86%E9%A2%91/" target="_blank" rel="noopener">Hexo+yilia主题实现文章目录和添加视频 </a></p><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>由于问题太多了，所以新写了篇文章：<a href="http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia/" target="_blank" rel="noopener">Github page + Hexo + yilia 搭建博客可能会遇到的所有疑问</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;为了方便查看每篇文章的目录结构，可以定位到想看的地方，特地找了下如何实现这个功能。&lt;/p&gt;
&lt;h3 id=&quot;添加-CSS-样式&quot;&gt;&lt;a href=&quot;#添加-CSS-样式&quot; class=&quot;headerlink&quot; title=&quot;添加 CSS 样式&quot;&gt;&lt;/a&gt;添加 CSS 样式&lt;/h3&gt;&lt;p&gt;打开 &lt;code&gt;themes\yilia\source&lt;/code&gt; 下的 &lt;code&gt;main.234bc0.css&lt;/code&gt; 文件，直接在后面添加如下代码：&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 默认分词器和中分分词器之间的比较及使用方法</title>
    <link href="http://yoursite.com/2018/01/21/Elasticsearch-analyzers/"/>
    <id>http://yoursite.com/2018/01/21/Elasticsearch-analyzers/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍：ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口。Elasticsearch 是用 Java 开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p><p>Elasticsearch中，内置了很多分词器（analyzers）。下面来进行比较下系统默认分词器和常用的中文分词器之间的区别。<br><a id="more"></a></p><h2 id="系统默认分词器："><a href="#系统默认分词器：" class="headerlink" title="系统默认分词器："></a>系统默认分词器：</h2><h3 id="1、standard-分词器"><a href="#1、standard-分词器" class="headerlink" title="1、standard 分词器"></a>1、standard 分词器</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html</a></p><p>如何使用：<a href="http://www.yiibai.com/lucene/lucene_standardanalyzer.html" target="_blank" rel="noopener">http://www.yiibai.com/lucene/lucene_standardanalyzer.html</a></p><p>英文的处理能力同于StopAnalyzer.支持中文采用的方法为单字切分。他会将词汇单元转换成小写形式，并去除停用词和标点符号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**StandardAnalyzer分析器*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">standardAnalyzer</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    StandardAnalyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_36);</span><br><span class="line">   <span class="keyword">this</span>.getTokens(analyzer, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、simple-分词器"><a href="#2、simple-分词器" class="headerlink" title="2、simple 分词器"></a>2、simple 分词器</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-simple-analyzer.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-simple-analyzer.html</a></p><p>如何使用: <a href="http://www.yiibai.com/lucene/lucene_simpleanalyzer.html" target="_blank" rel="noopener">http://www.yiibai.com/lucene/lucene_simpleanalyzer.html</a></p><p>功能强于WhitespaceAnalyzer, 首先会通过非字母字符来分割文本信息，然后将词汇单元统一为小写形式。该分析器会去掉数字类型的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**SimpleAnalyzer分析器*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleAnalyzer</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        SimpleAnalyzer analyzer = <span class="keyword">new</span> SimpleAnalyzer(Version.LUCENE_36);</span><br><span class="line">        <span class="keyword">this</span>.getTokens(analyzer, msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、Whitespace-分词器"><a href="#3、Whitespace-分词器" class="headerlink" title="3、Whitespace 分词器"></a>3、Whitespace 分词器</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-whitespace-analyzer.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-whitespace-analyzer.html</a></p><p>如何使用：<a href="http://www.yiibai.com/lucene/lucene_whitespaceanalyzer.html" target="_blank" rel="noopener">http://www.yiibai.com/lucene/lucene_whitespaceanalyzer.html</a></p><p>仅仅是去除空格，对字符没有lowcase化,不支持中文；<br>并且不对生成的词汇单元进行其他的规范化处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**WhitespaceAnalyzer分析器*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whitespaceAnalyzer</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        WhitespaceAnalyzer analyzer = <span class="keyword">new</span> WhitespaceAnalyzer(Version.LUCENE_36);</span><br><span class="line">        <span class="keyword">this</span>.getTokens(analyzer, msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4、Stop-分词器"><a href="#4、Stop-分词器" class="headerlink" title="4、Stop 分词器"></a>4、Stop 分词器</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-stop-analyzer.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-stop-analyzer.html</a></p><p>如何使用：<a href="http://www.yiibai.com/lucene/lucene_stopanalyzer.html" target="_blank" rel="noopener">http://www.yiibai.com/lucene/lucene_stopanalyzer.html</a></p><p> StopAnalyzer的功能超越了SimpleAnalyzer，在SimpleAnalyzer的基础上增加了去除英文中的常用单词（如the，a等），也可以更加自己的需要设置常用单词；不支持中文</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**StopAnalyzer分析器*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopAnalyzer</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">       StopAnalyzer analyzer = <span class="keyword">new</span> StopAnalyzer(Version.LUCENE_36);</span><br><span class="line">       <span class="keyword">this</span>.getTokens(analyzer, msg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="5、keyword-分词器"><a href="#5、keyword-分词器" class="headerlink" title="5、keyword 分词器"></a>5、keyword 分词器</h3><p>KeywordAnalyzer把整个输入作为一个单独词汇单元，方便特殊类型的文本进行索引和检索。针对邮政编码，地址等文本信息使用关键词分词器进行索引项建立非常方便。</p><h3 id="6、pattern-分词器"><a href="#6、pattern-分词器" class="headerlink" title="6、pattern 分词器"></a>6、pattern 分词器</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-analyzer.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-analyzer.html</a></p><p>一个pattern类型的analyzer可以通过正则表达式将文本分成”terms”(经过token Filter 后得到的东西 )。接受如下设置:</p><p>一个 pattern analyzer 可以做如下的属性设置:</p><table><thead><tr><th>lowercase</th><th>terms是否是小写. 默认为 true 小写.</th></tr></thead><tbody><tr><td>pattern</td><td>正则表达式的pattern, 默认是 \W+.</td></tr><tr><td>flags</td><td>正则表达式的flags</td></tr><tr><td>stopwords</td><td>一个用于初始化stop filter的需要stop 单词的列表.默认单词是空的列表</td></tr></tbody></table><h3 id="7、language-分词器"><a href="#7、language-分词器" class="headerlink" title="7、language 分词器"></a>7、language 分词器</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html</a></p><p>一个用于解析特殊语言文本的analyzer集合。（ arabic,armenian, basque, brazilian, bulgarian, catalan, cjk, czech, danish, dutch, english, finnish, french,galician, german, greek, hindi, hungarian, indonesian, irish, italian, latvian, lithuanian, norwegian,persian, portuguese, romanian, russian, sorani, spanish, swedish, turkish, thai.）可惜没有中文。不予考虑</p><h3 id="8、snowball-分词器"><a href="#8、snowball-分词器" class="headerlink" title="8、snowball 分词器"></a>8、snowball 分词器</h3><p>一个snowball类型的analyzer是由standard tokenizer和standard filter、lowercase filter、stop filter、snowball filter这四个filter构成的。</p><p>snowball analyzer 在Lucene中通常是不推荐使用的。</p><h3 id="9、Custom-分词器"><a href="#9、Custom-分词器" class="headerlink" title="9、Custom 分词器"></a>9、Custom 分词器</h3><p>是自定义的analyzer。允许多个零到多个tokenizer，零到多个 Char Filters. custom analyzer 的名字不能以 “_”开头.</p><p>The following are settings that can be set for a custom analyzer type:</p><table><thead><tr><th>Setting</th><th>Description</th></tr></thead><tbody><tr><td>tokenizer</td><td>通用的或者注册的tokenizer.</td></tr><tr><td>filter</td><td>通用的或者注册的token filters</td></tr><tr><td>char_filter</td><td>通用的或者注册的 character filters</td></tr><tr><td>position_increment_gap</td><td>距离查询时，最大允许查询的距离，默认是100</td></tr></tbody></table><p>自定义的模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">index :</span><br><span class="line">    analysis :</span><br><span class="line">        analyzer :</span><br><span class="line">            myAnalyzer2 :</span><br><span class="line">                type : custom</span><br><span class="line">                tokenizer : myTokenizer1</span><br><span class="line">                filter : [myTokenFilter1, myTokenFilter2]</span><br><span class="line">                char_filter : [my_html]</span><br><span class="line">                position_increment_gap: 256</span><br><span class="line">        tokenizer :</span><br><span class="line">            myTokenizer1 :</span><br><span class="line">                type : standard</span><br><span class="line">                max_token_length : 900</span><br><span class="line">        filter :</span><br><span class="line">            myTokenFilter1 :</span><br><span class="line">                type : stop</span><br><span class="line">                stopwords : [stop1, stop2, stop3, stop4]</span><br><span class="line">            myTokenFilter2 :</span><br><span class="line">                type : length</span><br><span class="line">                min : 0</span><br><span class="line">                max : 2000</span><br><span class="line">        char_filter :</span><br><span class="line">              my_html :</span><br><span class="line">                type : html_strip</span><br><span class="line">                escaped_tags : [xxx, yyy]</span><br><span class="line">                read_ahead : 1024</span><br></pre></td></tr></table></figure><h3 id="10、fingerprint-分词器"><a href="#10、fingerprint-分词器" class="headerlink" title="10、fingerprint 分词器"></a>10、fingerprint 分词器</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-fingerprint-analyzer.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-fingerprint-analyzer.html</a></p><hr><h2 id="中文分词器："><a href="#中文分词器：" class="headerlink" title="中文分词器："></a>中文分词器：</h2><h3 id="1、ik-analyzer"><a href="#1、ik-analyzer" class="headerlink" title="1、ik-analyzer"></a>1、ik-analyzer</h3><p><a href="https://github.com/wks/ik-analyzer" target="_blank" rel="noopener">https://github.com/wks/ik-analyzer</a></p><p>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。</p><p>采用了特有的“正向迭代最细粒度切分算法“，支持细粒度和最大词长两种切分模式；具有83万字/秒（1600KB/S）的高速处理能力。</p><p>采用了多子处理器分析模式，支持：英文字母、数字、中文词汇等分词处理，兼容韩文、日文字符</p><p>优化的词典存储，更小的内存占用。支持用户词典扩展定义</p><p>针对Lucene全文检索优化的查询分析器IKQueryParser(作者吐血推荐)；引入简单搜索表达式，采用歧义分析算法优化查询关键字的搜索排列组合，能极大的提高Lucene检索的命中率。</p><p>Maven用法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.wltea.ik-analyzer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ik-analyzer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IK Analyzer加入Maven Central Repository之前，你需要手动安装，安装到本地的repository，或者上传到自己的Maven repository服务器上。</p><p>要安装到本地Maven repository，使用如下命令，将自动编译，打包并安装：<br>mvn install -Dmaven.test.skip=true</p><h4 id="Elasticsearch添加中文分词"><a href="#Elasticsearch添加中文分词" class="headerlink" title="Elasticsearch添加中文分词"></a>Elasticsearch添加中文分词</h4><h5 id="安装IK分词插件"><a href="#安装IK分词插件" class="headerlink" title="安装IK分词插件"></a>安装IK分词插件</h5><p><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></p><p>进入elasticsearch-analysis-ik-master</p><p>更多安装请参考博客：</p><p>1、<a href="http://blog.csdn.net/dingzfang/article/details/42776693" target="_blank" rel="noopener">为elastic添加中文分词</a> ： <a href="http://blog.csdn.net/dingzfang/article/details/42776693" target="_blank" rel="noopener">http://blog.csdn.net/dingzfang/article/details/42776693</a></p><p>2、<a href="http://www.cnblogs.com/xing901022/p/5910139.html" target="_blank" rel="noopener">如何在Elasticsearch中安装中文分词器(IK+pinyin)</a> ：<a href="http://www.cnblogs.com/xing901022/p/5910139.html" target="_blank" rel="noopener">http://www.cnblogs.com/xing901022/p/5910139.html</a></p><p>3、<a href="http://blog.csdn.net/jam00/article/details/52983056" target="_blank" rel="noopener">Elasticsearch 中文分词器 IK 配置和使用</a> ： <a href="http://blog.csdn.net/jam00/article/details/52983056" target="_blank" rel="noopener">http://blog.csdn.net/jam00/article/details/52983056</a></p><h4 id="ik-带有两个分词器"><a href="#ik-带有两个分词器" class="headerlink" title="ik 带有两个分词器"></a>ik 带有两个分词器</h4><p><strong>ik_max_word</strong> ：会将文本做最细粒度的拆分；尽可能多的拆分出词语</p><p><strong>ik_smart</strong>：会做最粗粒度的拆分；已被分出的词语将不会再次被其它词语占有</p><p>区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"># ik_max_word</span><br><span class="line"></span><br><span class="line">curl -XGET &apos;http://localhost:9200/_analyze?pretty&amp;analyzer=ik_max_word&apos; -d &apos;联想是全球最大的笔记本厂商&apos;</span><br><span class="line">#返回</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;联想&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;是&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;全球&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 3,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;最大&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 5,</span><br><span class="line">      &quot;end_offset&quot; : 7,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;的&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 7,</span><br><span class="line">      &quot;end_offset&quot; : 8,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;笔记本&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 8,</span><br><span class="line">      &quot;end_offset&quot; : 11,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;笔记&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 8,</span><br><span class="line">      &quot;end_offset&quot; : 10,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 6</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;本厂&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 10,</span><br><span class="line">      &quot;end_offset&quot; : 12,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 7</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;厂商&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 11,</span><br><span class="line">      &quot;end_offset&quot; : 13,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 8</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ik_smart</span><br><span class="line"></span><br><span class="line">curl -XGET &apos;http://localhost:9200/_analyze?pretty&amp;analyzer=ik_smart&apos; -d &apos;联想是全球最大的笔记本厂商&apos;</span><br><span class="line"></span><br><span class="line"># 返回</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;联想&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;是&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;全球&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 3,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;最大&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 5,</span><br><span class="line">      &quot;end_offset&quot; : 7,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;的&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 7,</span><br><span class="line">      &quot;end_offset&quot; : 8,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;笔记本&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 8,</span><br><span class="line">      &quot;end_offset&quot; : 11,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;厂商&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 11,</span><br><span class="line">      &quot;end_offset&quot; : 13,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 6</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来创建一个索引，使用 ik<br>创建一个名叫 iktest 的索引，设置它的分析器用 ik ，分词器用 ik_max_word，并创建一个 article 的类型，里面有一个 subject 的字段，指定其使用 ik_max_word 分词器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &apos;http://localhost:9200/iktest?pretty&apos; -d &apos;&#123;</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">        &quot;analysis&quot; : &#123;</span><br><span class="line">            &quot;analyzer&quot; : &#123;</span><br><span class="line">                &quot;ik&quot; : &#123;</span><br><span class="line">                    &quot;tokenizer&quot; : &quot;ik_max_word&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">        &quot;article&quot; : &#123;</span><br><span class="line">            &quot;dynamic&quot; : true,</span><br><span class="line">            &quot;properties&quot; : &#123;</span><br><span class="line">                &quot;subject&quot; : &#123;</span><br><span class="line">                    &quot;type&quot; : &quot;string&quot;,</span><br><span class="line">                    &quot;analyzer&quot; : &quot;ik_max_word&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>批量添加几条数据，这里我指定元数据 _id 方便查看，subject 内容为我随便找的几条新闻的标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/iktest/article/_bulk?pretty -d &apos;</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_id&quot; : &quot;1&quot; &#125; &#125;</span><br><span class="line">&#123;&quot;subject&quot; : &quot;＂闺蜜＂崔顺实被韩检方传唤 韩总统府促彻查真相&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_id&quot; : &quot;2&quot; &#125; &#125;</span><br><span class="line">&#123;&quot;subject&quot; : &quot;韩举行＂护国训练＂ 青瓦台:决不许国家安全出问题&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_id&quot; : &quot;3&quot; &#125; &#125;</span><br><span class="line">&#123;&quot;subject&quot; : &quot;媒体称FBI已经取得搜查令 检视希拉里电邮&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_id&quot; : &quot;4&quot; &#125; &#125;</span><br><span class="line">&#123;&quot;subject&quot; : &quot;村上春树获安徒生奖 演讲中谈及欧洲排外问题&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_id&quot; : &quot;5&quot; &#125; &#125;</span><br><span class="line">&#123;&quot;subject&quot; : &quot;希拉里团队炮轰FBI 参院民主党领袖批其“违法”&quot; &#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure><p>查询 “希拉里和韩国”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/iktest/article/_search?pretty  -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;subject&quot; : &quot;希拉里和韩国&quot; &#125;&#125;,</span><br><span class="line">    &quot;highlight&quot; : &#123;</span><br><span class="line">        &quot;pre_tags&quot; : [&quot;&lt;font color=&apos;red&apos;&gt;&quot;],</span><br><span class="line">        &quot;post_tags&quot; : [&quot;&lt;/font&gt;&quot;],</span><br><span class="line">        &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;subject&quot; : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&apos;</span><br><span class="line">#返回</span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 113,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 5,</span><br><span class="line">    &quot;successful&quot; : 5,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 4,</span><br><span class="line">    &quot;max_score&quot; : 0.034062363,</span><br><span class="line">    &quot;hits&quot; : [ &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;iktest&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;article&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;2&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.034062363,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;subject&quot; : &quot;韩举行＂护国训练＂ 青瓦台:决不许国家安全出问题&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;highlight&quot; : &#123;</span><br><span class="line">        &quot;subject&quot; : [ &quot;&lt;font color=red&gt;韩&lt;/font&gt;举行＂护&lt;font color=red&gt;国&lt;/font&gt;训练＂ 青瓦台:决不许国家安全出问题&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;iktest&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;article&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;3&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.0076681254,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;subject&quot; : &quot;媒体称FBI已经取得搜查令 检视希拉里电邮&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;highlight&quot; : &#123;</span><br><span class="line">        &quot;subject&quot; : [ &quot;媒体称FBI已经取得搜查令 检视&lt;font color=red&gt;希拉里&lt;/font&gt;电邮&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;iktest&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;article&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;5&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.006709609,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;subject&quot; : &quot;希拉里团队炮轰FBI 参院民主党领袖批其“违法”&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;highlight&quot; : &#123;</span><br><span class="line">        &quot;subject&quot; : [ &quot;&lt;font color=red&gt;希拉里&lt;/font&gt;团队炮轰FBI 参院民主党领袖批其“违法”&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;iktest&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;article&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.0021509775,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;subject&quot; : &quot;＂闺蜜＂崔顺实被韩检方传唤 韩总统府促彻查真相&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;highlight&quot; : &#123;</span><br><span class="line">        &quot;subject&quot; : [ &quot;＂闺蜜＂崔顺实被&lt;font color=red&gt;韩&lt;/font&gt;检方传唤 &lt;font color=red&gt;韩&lt;/font&gt;总统府促彻查真相&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用了高亮属性 highlight，直接显示到 html 中，被匹配到的字或词将以红色突出显示。若要用过滤搜索，直接将 match 改为 term 即可</p><h4 id="热词更新配置"><a href="#热词更新配置" class="headerlink" title="热词更新配置"></a>热词更新配置</h4><p>网络词语日新月异，如何让新出的网络热词（或特定的词语）实时的更新到我们的搜索当中呢</p><p>先用 ik 测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/_analyze?pretty&amp;analyzer=ik_max_word&apos; -d &apos;</span><br><span class="line">成龙原名陈港生</span><br><span class="line">&apos;</span><br><span class="line">#返回</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [ &#123;</span><br><span class="line">    &quot;token&quot; : &quot;成龙&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 1,</span><br><span class="line">    &quot;end_offset&quot; : 3,</span><br><span class="line">    &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">    &quot;position&quot; : 0</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;原名&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 3,</span><br><span class="line">    &quot;end_offset&quot; : 5,</span><br><span class="line">    &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">    &quot;position&quot; : 1</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;陈&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 5,</span><br><span class="line">    &quot;end_offset&quot; : 6,</span><br><span class="line">    &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">    &quot;position&quot; : 2</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;港&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 6,</span><br><span class="line">    &quot;end_offset&quot; : 7,</span><br><span class="line">    &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">    &quot;position&quot; : 3</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;生&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 7,</span><br><span class="line">    &quot;end_offset&quot; : 8,</span><br><span class="line">    &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">    &quot;position&quot; : 4</span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ik 的主词典中没有”陈港生” 这个词，所以被拆分了。<br>现在我们来配置一下</p><p>修改 IK 的配置文件 ：ES 目录/plugins/ik/config/ik/IKAnalyzer.cfg.xml</p><p>修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;</span><br><span class="line">    &lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="line">    &lt;entry key=&quot;ext_dict&quot;&gt;custom/mydict.dic;custom/single_word_low_freq.dic&lt;/entry&gt;</span><br><span class="line">     &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="line">    &lt;entry key=&quot;ext_stopwords&quot;&gt;custom/ext_stopword.dic&lt;/entry&gt;</span><br><span class="line">    &lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><br><span class="line">    &lt;entry key=&quot;remote_ext_dict&quot;&gt;http://192.168.1.136/hotWords.php&lt;/entry&gt;</span><br><span class="line">    &lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span><br><span class="line">    &lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>这里我是用的是远程扩展字典，因为可以使用其他程序调用更新，且不用重启 ES，很方便；当然使用自定义的 mydict.dic 字典也是很方便的，一行一个词，自己加就可以了</p><p>既然是远程词典，那么就要是一个可访问的链接，可以是一个页面，也可以是一个txt的文档，但要保证输出的内容是 utf-8 的格式</p><p>hotWords.php 的内容</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$s = <span class="string">&lt;&lt;&lt;'EOF'</span></span><br><span class="line"><span class="string">陈港生</span></span><br><span class="line"><span class="string">元楼</span></span><br><span class="line"><span class="string">蓝瘦</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line">header(<span class="string">'Last-Modified: '</span>.gmdate(<span class="string">'D, d M Y H:i:s'</span>, time()).<span class="string">' GMT'</span>, <span class="keyword">true</span>, <span class="number">200</span>);</span><br><span class="line">header(<span class="string">'ETag: "5816f349-19"'</span>);</span><br><span class="line"><span class="keyword">echo</span> $s;</span><br></pre></td></tr></table></figure><p>ik 接收两个返回的头部属性 Last-Modified 和 ETag，只要其中一个有变化，就会触发更新，ik 会每分钟获取一次<br>重启 Elasticsearch ，查看启动记录，看到了三个词已被加载进来</p><p>再次执行上面的请求，返回, 就可以看到 ik 分词器已经匹配到了 “陈港生” 这个词，同理一些关于我们公司的专有名字（例如：永辉、永辉超市、永辉云创、云创 …. ）也可以自己手动添加到字典中去。</p><h3 id="2、结巴中文分词"><a href="#2、结巴中文分词" class="headerlink" title="2、结巴中文分词"></a>2、结巴中文分词</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>1、支持三种分词模式：</p><ul><li><p>精确模式，试图将句子最精确地切开，适合文本分析；</p></li><li><p>全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；</p></li><li><p>搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。</p></li></ul><p>2、支持繁体分词</p><p>3、支持自定义词典</p><h3 id="3、THULAC"><a href="#3、THULAC" class="headerlink" title="3、THULAC"></a>3、THULAC</h3><p>THULAC（THU Lexical Analyzer for Chinese）由清华大学自然语言处理与社会人文计算实验室研制推出的一套中文词法分析工具包，具有中文分词和词性标注功能。THULAC具有如下几个特点：</p><p>能力强。利用我们集成的目前世界上规模最大的人工分词和词性标注中文语料库（约含5800万字）训练而成，模型标注能力强大。</p><p>准确率高。该工具包在标准数据集Chinese Treebank（CTB5）上分词的F1值可达97.3％，词性标注的F1值可达到92.9％，与该数据集上最好方法效果相当。</p><p>速度较快。同时进行分词和词性标注速度为300KB/s，每秒可处理约15万字。只进行分词速度可达到1.3MB/s。</p><p>中文分词工具thulac4j发布</p><p>1、规范化分词词典，并去掉一些无用词；</p><p>2、重写DAT（双数组Trie树）的构造算法，生成的DAT size减少了8%左右，从而节省了内存；</p><p>3、优化分词算法，提高了分词速率。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.yizhiru<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thulac4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;thulac4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://www.cnblogs.com/en-heng/p/6526598.html" target="_blank" rel="noopener">http://www.cnblogs.com/en-heng/p/6526598.html</a></p><p>thulac4j支持两种分词模式：</p><p>SegOnly模式，只分词没有词性标注；</p><p>SegPos模式，分词兼有词性标注。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SegOnly mode</span></span><br><span class="line">String sentence = <span class="string">"滔滔的流水，向着波士顿湾无声逝去"</span>;</span><br><span class="line">SegOnly seg = <span class="keyword">new</span> SegOnly(<span class="string">"models/seg_only.bin"</span>);</span><br><span class="line">System.out.println(seg.segment(sentence));</span><br><span class="line"><span class="comment">// [滔滔, 的, 流水, ，, 向着, 波士顿湾, 无声, 逝去]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SegPos mode</span></span><br><span class="line">SegPos pos = <span class="keyword">new</span> SegPos(<span class="string">"models/seg_pos.bin"</span>);</span><br><span class="line">System.out.println(pos.segment(sentence));</span><br><span class="line"><span class="comment">//[滔滔/a, 的/u, 流水/n, ，/w, 向着/p, 波士顿湾/ns, 无声/v, 逝去/v]</span></span><br></pre></td></tr></table></figure><h3 id="4、NLPIR"><a href="#4、NLPIR" class="headerlink" title="4、NLPIR"></a>4、NLPIR</h3><p>中科院计算所 NLPIR：<a href="http://ictclas.nlpir.org/nlpir/" target="_blank" rel="noopener">http://ictclas.nlpir.org/nlpir/</a>  (可直接在线分析中文)</p><p>下载地址：<a href="https://github.com/NLPIR-team/NLPIR" target="_blank" rel="noopener">https://github.com/NLPIR-team/NLPIR</a></p><p>中科院分词系统(NLPIR)JAVA简易教程: <a href="http://www.cnblogs.com/wukongjiuwo/p/4092480.html" target="_blank" rel="noopener">http://www.cnblogs.com/wukongjiuwo/p/4092480.html</a></p><h3 id="5、ansj分词器"><a href="#5、ansj分词器" class="headerlink" title="5、ansj分词器"></a>5、ansj分词器</h3><p><a href="https://github.com/NLPchina/ansj_seg" target="_blank" rel="noopener">https://github.com/NLPchina/ansj_seg</a></p><p>这是一个基于n-Gram+CRF+HMM的中文分词的java实现.</p><p>分词速度达到每秒钟大约200万字左右（mac air下测试），准确率能达到96%以上</p><p>目前实现了.中文分词. 中文姓名识别 .</p><p>用户自定义词典,关键字提取，自动摘要，关键字标记等功能<br>可以应用到自然语言处理等方面,适用于对分词效果要求高的各种项目.</p><p>maven 引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ansj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ansj_seg<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>调用demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"欢迎使用ansj_seg,(ansj中文分词)在这里如果你遇到什么问题都可以联系我.我一定尽我所能.帮助大家.ansj_seg更快,更准,更自由!"</span> ;</span><br><span class="line"> System.out.println(ToAnalysis.parse(str));</span><br><span class="line"></span><br><span class="line"> 欢迎/v,使用/v,ansj/en,_,seg/en,,,(,ansj/en,中文/nz,分词/n,),在/p,这里/r,如果/c,你/r,遇到/v,什么/r,问题/n,都/d,可以/v,联系/v,我/r,./m,我/r,一定/d,尽我所能/l,./m,帮助/v,大家/r,./m,ansj/en,_,seg/en,更快/d,,,更/d,准/a,,,更/d,自由/a,!</span><br></pre></td></tr></table></figure><h3 id="6、哈工大的LTP"><a href="#6、哈工大的LTP" class="headerlink" title="6、哈工大的LTP"></a>6、哈工大的LTP</h3><p><a href="https://link.zhihu.com/?target=https%3A//github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">https://link.zhihu.com/?target=https%3A//github.com/HIT-SCIR/ltp</a></p><p>LTP制定了基于XML的语言处理结果表示，并在此基础上提供了一整套自底向上的丰富而且高效的中文语言处理模块（包括词法、句法、语义等6项中文处理核心技术），以及基于动态链接库（Dynamic Link Library, DLL）的应用程序接口、可视化工具，并且能够以网络服务（Web Service）的形式进行使用。</p><p>关于LTP的使用，请参考:  <a href="http://ltp.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://ltp.readthedocs.io/zh_CN/latest/</a></p><h3 id="7、庖丁解牛"><a href="#7、庖丁解牛" class="headerlink" title="7、庖丁解牛"></a>7、庖丁解牛</h3><p>下载地址：<a href="http://pan.baidu.com/s/1eQ88SZS" target="_blank" rel="noopener">http://pan.baidu.com/s/1eQ88SZS</a></p><p>使用分为如下几步：</p><ol><li><p>配置dic文件：<br>修改paoding-analysis.jar中的paoding-dic-home.properties文件，将“#paoding.dic.home=dic”的注释去掉，并配置成自己dic文件的本地存放路径。eg：/home/hadoop/work/paoding-analysis-2.0.4-beta/dic</p></li><li><p>把Jar包导入到项目中：<br>将paoding-analysis.jar、commons-logging.jar、lucene-analyzers-2.2.0.jar和lucene-core-2.2.0.jar四个包导入到项目中，这时就可以在代码片段中使用庖丁解牛工具提供的中文分词技术，例如：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Analyzer analyzer = <span class="keyword">new</span> PaodingAnalyzer(); <span class="comment">//定义一个解析器</span></span><br><span class="line">String text = <span class="string">"庖丁系统是个完全基于lucene的中文分词系统，它就是重新建了一个analyzer，叫做PaodingAnalyzer，这个analyer的核心任务就是生成一个可以切词TokenStream。"</span>; &lt;span style=<span class="string">"font-family: Arial, Helvetica, sans-serif;"</span>&gt;<span class="comment">//待分词的内容&lt;/span&gt;</span></span><br><span class="line">TokenStream tokenStream = analyzer.tokenStream(text, <span class="keyword">new</span> StringReader(text)); <span class="comment">//得到token序列的输出流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Token t;</span><br><span class="line">    <span class="keyword">while</span> ((t = tokenStream.next()) != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">           System.out.println(t); <span class="comment">//输出每个token</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、sogo在线分词"><a href="#8、sogo在线分词" class="headerlink" title="8、sogo在线分词"></a>8、sogo在线分词</h3><p>sogo在线分词采用了基于汉字标注的分词方法，主要使用了线性链链CRF（Linear-chain CRF）模型。词性标注模块主要基于结构化线性模型（Structured Linear Model）</p><p>在线使用地址为：<br><a href="http://www.sogou.com/labs/webservice/" target="_blank" rel="noopener">http://www.sogou.com/labs/webservice/</a></p><h3 id="9、word分词"><a href="#9、word分词" class="headerlink" title="9、word分词"></a>9、word分词</h3><p>地址： <a href="https://github.com/ysc/word" target="_blank" rel="noopener">https://github.com/ysc/word</a></p><p>word分词是一个Java实现的分布式的中文分词组件，提供了多种基于词典的分词算法，并利用ngram模型来消除歧义。能准确识别英文、数字，以及日期、时间等数量词，能识别人名、地名、组织机构名等未登录词。能通过自定义配置文件来改变组件行为，能自定义用户词库、自动检测词库变化、支持大规模分布式环境，能灵活指定多种分词算法，能使用refine功能灵活控制分词结果，还能使用词频统计、词性标注、同义标注、反义标注、拼音标注等功能。提供了10种分词算法，还提供了10种文本相似度算法，同时还无缝和Lucene、Solr、ElasticSearch、Luke集成。注意：word1.3需要JDK1.8</p><p>maven 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apdplat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>word<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ElasticSearch插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1、打开命令行并切换到elasticsearch的bin目录</span><br><span class="line">cd elasticsearch-2.1.1/bin</span><br><span class="line"></span><br><span class="line">2、运行plugin脚本安装word分词插件：</span><br><span class="line">./plugin install http://apdplat.org/word/archive/v1.4.zip</span><br><span class="line"></span><br><span class="line">安装的时候注意：</span><br><span class="line">    如果提示：</span><br><span class="line">        ERROR: failed to download</span><br><span class="line">    或者</span><br><span class="line">        Failed to install word, reason: failed to download</span><br><span class="line">    或者</span><br><span class="line">        ERROR: incorrect hash (SHA1)</span><br><span class="line">    则重新再次运行命令，如果还是不行，多试两次</span><br><span class="line"></span><br><span class="line">如果是elasticsearch1.x系列版本，则使用如下命令：</span><br><span class="line">./plugin -u http://apdplat.org/word/archive/v1.3.1.zip -i word</span><br><span class="line"></span><br><span class="line">3、修改文件elasticsearch-2.1.1/config/elasticsearch.yml，新增如下配置：</span><br><span class="line">index.analysis.analyzer.default.type : &quot;word&quot;</span><br><span class="line">index.analysis.tokenizer.default.type : &quot;word&quot;</span><br><span class="line"></span><br><span class="line">4、启动ElasticSearch测试效果，在Chrome浏览器中访问：</span><br><span class="line">http://localhost:9200/_analyze?analyzer=word&amp;text=杨尚川是APDPlat应用级产品开发平台的作者</span><br><span class="line"></span><br><span class="line">5、自定义配置</span><br><span class="line">修改配置文件elasticsearch-2.1.1/plugins/word/word.local.conf</span><br><span class="line"></span><br><span class="line">6、指定分词算法</span><br><span class="line">修改文件elasticsearch-2.1.1/config/elasticsearch.yml，新增如下配置：</span><br><span class="line">index.analysis.analyzer.default.segAlgorithm : &quot;ReverseMinimumMatching&quot;</span><br><span class="line">index.analysis.tokenizer.default.segAlgorithm : &quot;ReverseMinimumMatching&quot;</span><br><span class="line"></span><br><span class="line">这里segAlgorithm可指定的值有：</span><br><span class="line">正向最大匹配算法：MaximumMatching</span><br><span class="line">逆向最大匹配算法：ReverseMaximumMatching</span><br><span class="line">正向最小匹配算法：MinimumMatching</span><br><span class="line">逆向最小匹配算法：ReverseMinimumMatching</span><br><span class="line">双向最大匹配算法：BidirectionalMaximumMatching</span><br><span class="line">双向最小匹配算法：BidirectionalMinimumMatching</span><br><span class="line">双向最大最小匹配算法：BidirectionalMaximumMinimumMatching</span><br><span class="line">全切分算法：FullSegmentation</span><br><span class="line">最少词数算法：MinimalWordCount</span><br><span class="line">最大Ngram分值算法：MaxNgramScore</span><br><span class="line">如不指定，默认使用双向最大匹配算法：BidirectionalMaximumMatching</span><br></pre></td></tr></table></figure><h3 id="10、jcseg分词器"><a href="#10、jcseg分词器" class="headerlink" title="10、jcseg分词器"></a>10、jcseg分词器</h3><p><a href="https://code.google.com/archive/p/jcseg/" target="_blank" rel="noopener">https://code.google.com/archive/p/jcseg/</a></p><h3 id="11、stanford分词器"><a href="#11、stanford分词器" class="headerlink" title="11、stanford分词器"></a>11、stanford分词器</h3><p>Stanford大学的一个开源分词工具，目前已支持汉语。</p><p>首先，去【1】下载Download Stanford Word Segmenter version 3.5.2，取得里面的 data 文件夹，放在maven project的 src/main/resources 里。</p><p>然后，maven依赖添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">corenlp.version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">corenlp.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>edu.stanford.nlp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>stanford-corenlp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;corenlp.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>edu.stanford.nlp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>stanford-corenlp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;corenlp.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>models<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>edu.stanford.nlp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>stanford-corenlp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;corenlp.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>models-chinese<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.stanford.nlp.ie.crf.CRFClassifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoreNLPSegment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CoreNLPSegment instance;</span><br><span class="line">    <span class="keyword">private</span> CRFClassifier         classifier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CoreNLPSegment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.setProperty(<span class="string">"sighanCorporaDict"</span>, <span class="string">"data"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"serDictionary"</span>, <span class="string">"data/dict-chris6.ser.gz"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"inputEncoding"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"sighanPostProcessing"</span>, <span class="string">"true"</span>);</span><br><span class="line">        classifier = <span class="keyword">new</span> CRFClassifier(props);</span><br><span class="line">        classifier.loadClassifierNoExceptions(<span class="string">"data/ctb.gz"</span>, props);</span><br><span class="line">        classifier.flags.setProperties(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CoreNLPSegment <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> CoreNLPSegment();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] doSegment(String data) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String[]) classifier.segmentString(data).toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String sentence = <span class="string">"他和我在学校里常打桌球。"</span>;</span><br><span class="line">        String ret[] = CoreNLPSegment.getInstance().doSegment(sentence);</span><br><span class="line">        <span class="keyword">for</span> (String str : ret) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>博客</strong>：</p><p><a href="https://blog.sectong.com/blog/corenlp_segment.html" target="_blank" rel="noopener">https://blog.sectong.com/blog/corenlp_segment.html</a></p><p><a href="http://blog.csdn.net/lightty/article/details/51766602" target="_blank" rel="noopener">http://blog.csdn.net/lightty/article/details/51766602</a></p><h3 id="12、Smartcn"><a href="#12、Smartcn" class="headerlink" title="12、Smartcn"></a>12、Smartcn</h3><p>Smartcn为Apache2.0协议的开源中文分词系统，Java语言编写，修改的中科院计算所ICTCLAS分词系统。很早以前看到Lucene上多了一个中文分词的contribution，当时只是简单的扫了一下.class文件的文件名，通过文件名可以看得出又是一个改的ICTCLAS的分词系统。</p><p><a href="http://lucene.apache.org/core/5_1_0/analyzers-smartcn/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.html" target="_blank" rel="noopener">http://lucene.apache.org/core/5_1_0/analyzers-smartcn/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.html</a></p><h3 id="13、pinyin-分词器"><a href="#13、pinyin-分词器" class="headerlink" title="13、pinyin 分词器"></a>13、pinyin 分词器</h3><p>pinyin分词器可以让用户输入拼音，就能查找到相关的关键词。比如在某个商城搜索中，输入 <code>yonghui</code>，就能匹配到  <code>永辉</code>。这样的体验还是非常好的。</p><p>pinyin分词器的安装与IK是一样的。下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-pinyin" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p><p>一些参数请参考 GitHub 的 readme 文档。</p><p>这个分词器在1.8版本中，提供了两种分词规则：</p><ul><li><p>pinyin,就是普通的把汉字转换成拼音；</p></li><li><p>pinyin_first_letter，提取汉字的拼音首字母</p></li></ul><p>使用：</p><p>1.Create a index with custom pinyin analyzer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT http://localhost:9200/medcl/ -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index&quot; : &#123;</span><br><span class="line">        &quot;analysis&quot; : &#123;</span><br><span class="line">            &quot;analyzer&quot; : &#123;</span><br><span class="line">                &quot;pinyin_analyzer&quot; : &#123;</span><br><span class="line">                    &quot;tokenizer&quot; : &quot;my_pinyin&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;tokenizer&quot; : &#123;</span><br><span class="line">                &quot;my_pinyin&quot; : &#123;</span><br><span class="line">                    &quot;type&quot; : &quot;pinyin&quot;,</span><br><span class="line">                    &quot;keep_separate_first_letter&quot; : false,</span><br><span class="line">                    &quot;keep_full_pinyin&quot; : true,</span><br><span class="line">                    &quot;keep_original&quot; : true,</span><br><span class="line">                    &quot;limit_first_letter_length&quot; : 16,</span><br><span class="line">                    &quot;lowercase&quot; : true,</span><br><span class="line">                    &quot;remove_duplicated_term&quot; : true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>2.Test Analyzer, analyzing a chinese name, such as 刘德华</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9200/medcl/_analyze?text=%e5%88%98%e5%be%b7%e5%8d%8e&amp;analyzer=pinyin_analyzer</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;liu&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 1,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;de&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 1,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;hua&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;刘德华&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;ldh&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.Create mapping</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/medcl/folks/_mapping -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;folks&quot;: &#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">                &quot;fields&quot;: &#123;</span><br><span class="line">                    &quot;pinyin&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                        &quot;store&quot;: &quot;no&quot;,</span><br><span class="line">                        &quot;term_vector&quot;: &quot;with_offsets&quot;,</span><br><span class="line">                        &quot;analyzer&quot;: &quot;pinyin_analyzer&quot;,</span><br><span class="line">                        &quot;boost&quot;: 10</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>4.Indexing</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/medcl/folks/andy -d&apos;&#123;&quot;name&quot;:&quot;刘德华&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>5.Let’s search</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9200/medcl/folks/_search?q=name:%E5%88%98%E5%BE%B7%E5%8D%8E</span><br><span class="line">curl http://localhost:9200/medcl/folks/_search?q=name.pinyin:%e5%88%98%e5%be%b7</span><br><span class="line">curl http://localhost:9200/medcl/folks/_search?q=name.pinyin:liu</span><br><span class="line">curl http://localhost:9200/medcl/folks/_search?q=name.pinyin:ldh</span><br><span class="line">curl http://localhost:9200/medcl/folks/_search?q=name.pinyin:de+hua</span><br></pre></td></tr></table></figure><p>6.Using Pinyin-TokenFilter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">curl -XPUT http://localhost:9200/medcl1/ -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index&quot; : &#123;</span><br><span class="line">        &quot;analysis&quot; : &#123;</span><br><span class="line">            &quot;analyzer&quot; : &#123;</span><br><span class="line">                &quot;user_name_analyzer&quot; : &#123;</span><br><span class="line">                    &quot;tokenizer&quot; : &quot;whitespace&quot;,</span><br><span class="line">                    &quot;filter&quot; : &quot;pinyin_first_letter_and_full_pinyin_filter&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;pinyin_first_letter_and_full_pinyin_filter&quot; : &#123;</span><br><span class="line">                    &quot;type&quot; : &quot;pinyin&quot;,</span><br><span class="line">                    &quot;keep_first_letter&quot; : true,</span><br><span class="line">                    &quot;keep_full_pinyin&quot; : false,</span><br><span class="line">                    &quot;keep_none_chinese&quot; : true,</span><br><span class="line">                    &quot;keep_original&quot; : false,</span><br><span class="line">                    &quot;limit_first_letter_length&quot; : 16,</span><br><span class="line">                    &quot;lowercase&quot; : true,</span><br><span class="line">                    &quot;trim_whitespace&quot; : true,</span><br><span class="line">                    &quot;keep_none_chinese_in_first_letter&quot; : true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>Token Test:刘德华 张学友 郭富城 黎明 四大天王</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://localhost:9200/medcl1/_analyze?text=%e5%88%98%e5%be%b7%e5%8d%8e+%e5%bc%a0%e5%ad%a6%e5%8f%8b+%e9%83%ad%e5%af%8c%e5%9f%8e+%e9%bb%8e%e6%98%8e+%e5%9b%9b%e5%a4%a7%e5%a4%a9%e7%8e%8b&amp;analyzer=user_name_analyzer</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;ldh&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;zxy&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 4,</span><br><span class="line">      &quot;end_offset&quot; : 7,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;gfc&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 8,</span><br><span class="line">      &quot;end_offset&quot; : 11,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;lm&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 12,</span><br><span class="line">      &quot;end_offset&quot; : 14,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;sdtw&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 15,</span><br><span class="line">      &quot;end_offset&quot; : 19,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.Used in phrase query</p><p>(1)、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PUT /medcl/</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;index&quot; : &#123;</span><br><span class="line">         &quot;analysis&quot; : &#123;</span><br><span class="line">             &quot;analyzer&quot; : &#123;</span><br><span class="line">                 &quot;pinyin_analyzer&quot; : &#123;</span><br><span class="line">                     &quot;tokenizer&quot; : &quot;my_pinyin&quot;</span><br><span class="line">                     &#125;</span><br><span class="line">             &#125;,</span><br><span class="line">             &quot;tokenizer&quot; : &#123;</span><br><span class="line">                 &quot;my_pinyin&quot; : &#123;</span><br><span class="line">                     &quot;type&quot; : &quot;pinyin&quot;,</span><br><span class="line">                     &quot;keep_first_letter&quot;:false,</span><br><span class="line">                     &quot;keep_separate_first_letter&quot; : false,</span><br><span class="line">                     &quot;keep_full_pinyin&quot; : true,</span><br><span class="line">                     &quot;keep_original&quot; : false,</span><br><span class="line">                     &quot;limit_first_letter_length&quot; : 16,</span><br><span class="line">                     &quot;lowercase&quot; : true</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> GET /medcl/folks/_search</span><br><span class="line"> &#123;</span><br><span class="line">   &quot;query&quot;: &#123;&quot;match_phrase&quot;: &#123;</span><br><span class="line">     &quot;name.pinyin&quot;: &quot;刘德华&quot;</span><br><span class="line">   &#125;&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>(2)、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PUT /medcl/</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;index&quot; : &#123;</span><br><span class="line">          &quot;analysis&quot; : &#123;</span><br><span class="line">              &quot;analyzer&quot; : &#123;</span><br><span class="line">                  &quot;pinyin_analyzer&quot; : &#123;</span><br><span class="line">                      &quot;tokenizer&quot; : &quot;my_pinyin&quot;</span><br><span class="line">                      &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;tokenizer&quot; : &#123;</span><br><span class="line">                  &quot;my_pinyin&quot; : &#123;</span><br><span class="line">                      &quot;type&quot; : &quot;pinyin&quot;,</span><br><span class="line">                      &quot;keep_first_letter&quot;:false,</span><br><span class="line">                      &quot;keep_separate_first_letter&quot; : true,</span><br><span class="line">                      &quot;keep_full_pinyin&quot; : false,</span><br><span class="line">                      &quot;keep_original&quot; : false,</span><br><span class="line">                      &quot;limit_first_letter_length&quot; : 16,</span><br><span class="line">                      &quot;lowercase&quot; : true</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  POST /medcl/folks/andy</span><br><span class="line">  &#123;&quot;name&quot;:&quot;刘德华&quot;&#125;</span><br><span class="line"></span><br><span class="line">  GET /medcl/folks/_search</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;query&quot;: &#123;&quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name.pinyin&quot;: &quot;刘德h&quot;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  GET /medcl/folks/_search</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;query&quot;: &#123;&quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name.pinyin&quot;: &quot;刘dh&quot;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  GET /medcl/folks/_search</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;query&quot;: &#123;&quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name.pinyin&quot;: &quot;dh&quot;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="14、Mmseg-分词器"><a href="#14、Mmseg-分词器" class="headerlink" title="14、Mmseg 分词器"></a>14、Mmseg 分词器</h3><p>也支持 Elasticsearch</p><p>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-mmseg/releases" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-mmseg/releases</a>   根据对应的版本进行下载</p><p>如何使用：</p><p>1、创建索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT http://localhost:9200/index</span><br></pre></td></tr></table></figure><p>2、创建 mapping</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/index/fulltext/_mapping -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;content&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">                &quot;term_vector&quot;: &quot;with_positions_offsets&quot;,</span><br><span class="line">                &quot;analyzer&quot;: &quot;mmseg_maxword&quot;,</span><br><span class="line">                &quot;search_analyzer&quot;: &quot;mmseg_maxword&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>3.Indexing some docs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/index/fulltext/1 -d&apos;</span><br><span class="line">&#123;&quot;content&quot;:&quot;美国留给伊拉克的是个烂摊子吗&quot;&#125;</span><br><span class="line">&apos;</span><br><span class="line"></span><br><span class="line">curl -XPOST http://localhost:9200/index/fulltext/2 -d&apos;</span><br><span class="line">&#123;&quot;content&quot;:&quot;公安部：各地校车将享最高路权&quot;&#125;</span><br><span class="line">&apos;</span><br><span class="line"></span><br><span class="line">curl -XPOST http://localhost:9200/index/fulltext/3 -d&apos;</span><br><span class="line">&#123;&quot;content&quot;:&quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;&#125;</span><br><span class="line">&apos;</span><br><span class="line"></span><br><span class="line">curl -XPOST http://localhost:9200/index/fulltext/4 -d&apos;</span><br><span class="line">&#123;&quot;content&quot;:&quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;&#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure><p>4.Query with highlighting(查询高亮)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/index/fulltext/_search  -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123; &quot;term&quot; : &#123; &quot;content&quot; : &quot;中国&quot; &#125;&#125;,</span><br><span class="line">    &quot;highlight&quot; : &#123;</span><br><span class="line">        &quot;pre_tags&quot; : [&quot;&lt;tag1&gt;&quot;, &quot;&lt;tag2&gt;&quot;],</span><br><span class="line">        &quot;post_tags&quot; : [&quot;&lt;/tag1&gt;&quot;, &quot;&lt;/tag2&gt;&quot;],</span><br><span class="line">        &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;content&quot; : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure><p>5、结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 14,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 5,</span><br><span class="line">        &quot;successful&quot;: 5,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;max_score&quot;: 2,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;index&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;fulltext&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;4&quot;,</span><br><span class="line">                &quot;_score&quot;: 2,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;content&quot;: &quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;highlight&quot;: &#123;</span><br><span class="line">                    &quot;content&quot;: [</span><br><span class="line">                        &quot;&lt;tag1&gt;中国&lt;/tag1&gt;驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首 &quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;index&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;fulltext&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;3&quot;,</span><br><span class="line">                &quot;_score&quot;: 2,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;content&quot;: &quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;highlight&quot;: &#123;</span><br><span class="line">                    &quot;content&quot;: [</span><br><span class="line">                        &quot;均每天扣1艘&lt;tag1&gt;中国&lt;/tag1&gt;渔船 &quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博客：</p><p>为elastic添加中文分词: <a href="http://blog.csdn.net/dingzfang/article/details/42776693" target="_blank" rel="noopener">http://blog.csdn.net/dingzfang/article/details/42776693</a></p><h3 id="15、bosonnlp-（玻森数据中文分析器）"><a href="#15、bosonnlp-（玻森数据中文分析器）" class="headerlink" title="15、bosonnlp （玻森数据中文分析器）"></a>15、bosonnlp （玻森数据中文分析器）</h3><p>下载地址：<a href="https://github.com/bosondata/elasticsearch-analysis-bosonnlp" target="_blank" rel="noopener">https://github.com/bosondata/elasticsearch-analysis-bosonnlp</a></p><p>如何使用：</p><p>运行 ElasticSearch 之前需要在 config 文件夹中修改 elasticsearch.yml 来定义使用玻森中文分析器，并填写玻森 API_TOKEN 以及玻森分词 API 的地址，即在该文件结尾处添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">index:</span><br><span class="line">  analysis:</span><br><span class="line">    analyzer:</span><br><span class="line">      bosonnlp:</span><br><span class="line">          type: bosonnlp</span><br><span class="line">          API_URL: http://api.bosonnlp.com/tag/analysis</span><br><span class="line">          # You MUST give the API_TOKEN value, otherwise it doesn&apos;t work</span><br><span class="line">          API_TOKEN: *PUT YOUR API TOKEN HERE*</span><br><span class="line">          # Please uncomment if you want to specify ANY ONE of the following</span><br><span class="line">          # areguments, otherwise the DEFAULT value will be used, i.e.,</span><br><span class="line">          # space_mode is 0,</span><br><span class="line">          # oov_level is 3,</span><br><span class="line">          # t2s is 0,</span><br><span class="line">          # special_char_conv is 0.</span><br><span class="line">          # More detials can be found in bosonnlp docs:</span><br><span class="line">          # http://docs.bosonnlp.com/tag.html</span><br><span class="line">          #</span><br><span class="line">          #</span><br><span class="line">          # space_mode: put your value here(range from 0-3)</span><br><span class="line">          # oov_level: put your value here(range from 0-4)</span><br><span class="line">          # t2s: put your value here(range from 0-1)</span><br><span class="line">          # special_char_conv: put your value here(range from 0-1)</span><br></pre></td></tr></table></figure><p>需要注意的是</p><p>必须在 API_URL 填写给定的分词地址以及在API_TOKEN：<em>PUT YOUR API TOKEN HERE</em> 中填写给定的玻森数据API_TOKEN，否则无法使用玻森中文分析器。该 API_TOKEN 是注册玻森数据账号所获得。</p><p>如果配置文件中已经有配置过其他的 analyzer，请直接在 analyzer 下如上添加 bosonnlp analyzer。</p><p>如果有多个 node 并且都需要 BosonNLP 的分词插件，则每个 node 下的 yaml 文件都需要如上安装和设置。</p><p>另外，玻森中文分词还提供了4个参数（space_mode，oov_level，t2s，special_char_conv）可满足不同的分词需求。如果取默认值，则无需任何修改；否则，可取消对应参数的注释并赋值。</p><p><strong>测试：</strong></p><p>建立 index</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &apos;localhost:9200/test&apos;</span><br></pre></td></tr></table></figure><p>测试分析器是否配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;localhost:9200/test/_analyze?analyzer=bosonnlp&amp;pretty&apos; -d &apos;这是玻森数据分词的测试&apos;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [ &#123;</span><br><span class="line">    &quot;token&quot; : &quot;这&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 0,</span><br><span class="line">    &quot;end_offset&quot; : 1,</span><br><span class="line">    &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">    &quot;position&quot; : 0</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;是&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 1,</span><br><span class="line">    &quot;end_offset&quot; : 2,</span><br><span class="line">    &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">    &quot;position&quot; : 1</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;玻森&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 2,</span><br><span class="line">    &quot;end_offset&quot; : 4,</span><br><span class="line">    &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">    &quot;position&quot; : 2</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;数据&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 4,</span><br><span class="line">    &quot;end_offset&quot; : 6,</span><br><span class="line">    &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">    &quot;position&quot; : 3</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;分词&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 6,</span><br><span class="line">    &quot;end_offset&quot; : 8,</span><br><span class="line">    &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">    &quot;position&quot; : 4</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;的&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 8,</span><br><span class="line">    &quot;end_offset&quot; : 9,</span><br><span class="line">    &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">    &quot;position&quot; : 5</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; : &quot;测试&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 9,</span><br><span class="line">    &quot;end_offset&quot; : 11,</span><br><span class="line">    &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">    &quot;position&quot; : 6</span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 Token Filter</p><p>现有的 BosonNLP 分析器没有内置 token filter，如果有过滤 Token 的需求，可以利用 BosonNLP Tokenizer 和 ES 提供的 token filter 搭建定制分析器。</p><p>步骤</p><p>配置定制的 analyzer 有以下三个步骤：</p><p>添加 BosonNLP tokenizer<br>在 elasticsearch.yml 文件中 analysis 下添加 tokenizer， 并在 tokenizer 中添加 BosonNLP tokenizer 的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">index:</span><br><span class="line">  analysis:</span><br><span class="line">    analyzer:</span><br><span class="line">      ...</span><br><span class="line">    tokenizer:</span><br><span class="line">      bosonnlp:</span><br><span class="line">          type: bosonnlp</span><br><span class="line">          API_URL: http://api.bosonnlp.com/tag/analysis</span><br><span class="line">          # You MUST give the API_TOKEN value, otherwise it doesn&apos;t work</span><br><span class="line">          API_TOKEN: *PUT YOUR API TOKEN HERE*</span><br><span class="line">          # Please uncomment if you want to specify ANY ONE of the following</span><br><span class="line">          # areguments, otherwise the DEFAULT value will be used, i.e.,</span><br><span class="line">          # space_mode is 0,</span><br><span class="line">          # oov_level is 3,</span><br><span class="line">          # t2s is 0,</span><br><span class="line">          # special_char_conv is 0.</span><br><span class="line">          # More detials can be found in bosonnlp docs:</span><br><span class="line">          # http://docs.bosonnlp.com/tag.html</span><br><span class="line">          #</span><br><span class="line">          #</span><br><span class="line">          # space_mode: put your value here(range from 0-3)</span><br><span class="line">          # oov_level: put your value here(range from 0-4)</span><br><span class="line">          # t2s: put your value here(range from 0-1)</span><br><span class="line">          # special_char_conv: put your value here(range from 0-1)</span><br></pre></td></tr></table></figure><p>添加 token filter</p><p>在 elasticsearch.yml 文件中 analysis 下添加 filter， 并在 filter 中添加所需 filter 的配置（下面例子中，我们以 lowercase filter 为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">index:</span><br><span class="line">  analysis:</span><br><span class="line">    analyzer:</span><br><span class="line">      ...</span><br><span class="line">    tokenizer:</span><br><span class="line">      ...</span><br><span class="line">    filter:</span><br><span class="line">      lowercase:</span><br><span class="line">          type: lowercase</span><br></pre></td></tr></table></figure><p>添加定制的 analyzer</p><p>在 elasticsearch.yml 文件中 analysis 下添加 analyzer， 并在 analyzer 中添加定制的 analyzer 的配置（下面例子中，我们把定制的 analyzer 命名为 filter_bosonnlp）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index:</span><br><span class="line">  analysis:</span><br><span class="line">    analyzer:</span><br><span class="line">      ...</span><br><span class="line">      filter_bosonnlp:</span><br><span class="line">          type: custom</span><br><span class="line">          tokenizer: bosonnlp</span><br><span class="line">          filter: [lowercase]</span><br></pre></td></tr></table></figure><hr><h2 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h2><p>虽然Elasticsearch带有一些现成的分析器，然而在分析器上Elasticsearch真正的强大之处在于，你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。</p><p><strong>字符过滤器</strong>：</p><p>字符过滤器 用来 整理 一个尚未被分词的字符串。例如，如果我们的文本是HTML格式的，它会包含像 <code>&lt;p&gt;</code> 或者 <code>&lt;div&gt;</code> 这样的HTML标签，这些标签是我们不想索引的。我们可以使用 html清除 字符过滤器 来移除掉所有的HTML标签，并且像把 <code>&amp;Aacute;</code> 转换为相对应的Unicode字符 Á 这样，转换HTML实体。</p><p>一个分析器可能有0个或者多个字符过滤器。</p><p><strong>分词器</strong>:</p><p>一个分析器 必须 有一个唯一的分词器。 分词器把字符串分解成单个词条或者词汇单元。 标准 分析器里使用的 标准 分词器 把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号，然而还有其他不同行为的分词器存在。</p><p><strong>词单元过滤器</strong>:</p><p>经过分词，作为结果的 词单元流 会按照指定的顺序通过指定的词单元过滤器 。</p><p>词单元过滤器可以修改、添加或者移除词单元。我们已经提到过 lowercase 和 stop 词过滤器 ，但是在 Elasticsearch 里面还有很多可供选择的词单元过滤器。 词干过滤器 把单词 遏制 为 词干。 ascii_folding 过滤器移除变音符，把一个像 “très” 这样的词转换为 “tres” 。 ngram 和 edge_ngram 词单元过滤器 可以产生 适合用于部分匹配或者自动补全的词单元。</p><h3 id="创建一个自定义分析器"><a href="#创建一个自定义分析器" class="headerlink" title="创建一个自定义分析器"></a>创建一个自定义分析器</h3><p>我们可以在 analysis 下的相应位置设置字符过滤器、分词器和词单元过滤器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;analysis&quot;: &#123;</span><br><span class="line">            &quot;char_filter&quot;: &#123; ... custom character filters ... &#125;,</span><br><span class="line">            &quot;tokenizer&quot;:   &#123; ...    custom tokenizers     ... &#125;,</span><br><span class="line">            &quot;filter&quot;:      &#123; ...   custom token filters   ... &#125;,</span><br><span class="line">            &quot;analyzer&quot;:    &#123; ...    custom analyzers      ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个分析器可以做到下面的这些事:</p><p>1、使用 html清除 字符过滤器移除HTML部分。</p><p>2、使用一个自定义的 映射 字符过滤器把 &amp; 替换为 “和” ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;char_filter&quot;: &#123;</span><br><span class="line">    &quot;&amp;_to_and&quot;: &#123;</span><br><span class="line">        &quot;type&quot;:       &quot;mapping&quot;,</span><br><span class="line">        &quot;mappings&quot;: [ &quot;&amp;=&gt; and &quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用 标准 分词器分词。</p><p>4、小写词条，使用 小写 词过滤器处理。</p><p>5、使用自定义 停止 词过滤器移除自定义的停止词列表中包含的词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;filter&quot;: &#123;</span><br><span class="line">    &quot;my_stopwords&quot;: &#123;</span><br><span class="line">        &quot;type&quot;:        &quot;stop&quot;,</span><br><span class="line">        &quot;stopwords&quot;: [ &quot;the&quot;, &quot;a&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的分析器定义用我们之前已经设置好的自定义过滤器组合了已经定义好的分词器和过滤器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyzer&quot;: &#123;</span><br><span class="line">    &quot;my_analyzer&quot;: &#123;</span><br><span class="line">        &quot;type&quot;:           &quot;custom&quot;,</span><br><span class="line">        &quot;char_filter&quot;:  [ &quot;html_strip&quot;, &quot;&amp;_to_and&quot; ],</span><br><span class="line">        &quot;tokenizer&quot;:      &quot;standard&quot;,</span><br><span class="line">        &quot;filter&quot;:       [ &quot;lowercase&quot;, &quot;my_stopwords&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇总起来，完整的 创建索引 请求 看起来应该像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;analysis&quot;: &#123;</span><br><span class="line">            &quot;char_filter&quot;: &#123;</span><br><span class="line">                &quot;&amp;_to_and&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;:       &quot;mapping&quot;,</span><br><span class="line">                    &quot;mappings&quot;: [ &quot;&amp;=&gt; and &quot;]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;my_stopwords&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;:       &quot;stop&quot;,</span><br><span class="line">                    &quot;stopwords&quot;: [ &quot;the&quot;, &quot;a&quot; ]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            &quot;analyzer&quot;: &#123;</span><br><span class="line">                &quot;my_analyzer&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;:         &quot;custom&quot;,</span><br><span class="line">                    &quot;char_filter&quot;:  [ &quot;html_strip&quot;, &quot;&amp;_to_and&quot; ],</span><br><span class="line">                    &quot;tokenizer&quot;:    &quot;standard&quot;,</span><br><span class="line">                    &quot;filter&quot;:       [ &quot;lowercase&quot;, &quot;my_stopwords&quot; ]</span><br><span class="line">            &#125;&#125;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>索引被创建以后，使用 analyze API 来 测试这个新的分析器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=my_analyzer</span><br><span class="line">The quick &amp; brown fox</span><br></pre></td></tr></table></figure><p>下面的缩略结果展示出我们的分析器正在正确地运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">      &#123; &quot;token&quot; :   &quot;quick&quot;,    &quot;position&quot; : 2 &#125;,</span><br><span class="line">      &#123; &quot;token&quot; :   &quot;and&quot;,      &quot;position&quot; : 3 &#125;,</span><br><span class="line">      &#123; &quot;token&quot; :   &quot;brown&quot;,    &quot;position&quot; : 4 &#125;,</span><br><span class="line">      &#123; &quot;token&quot; :   &quot;fox&quot;,      &quot;position&quot; : 5 &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个分析器现在是没有多大用处的，除非我们告诉 Elasticsearch在哪里用上它。我们可以像下面这样把这个分析器应用在一个 string 字段上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;title&quot;: &#123;</span><br><span class="line">            &quot;type&quot;:      &quot;string&quot;,</span><br><span class="line">            &quot;analyzer&quot;:  &quot;my_analyzer&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>整理参考网上资料，如有不正确的地方还请多多指教！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍：ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口。Elasticsearch 是用 Java 开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&lt;/p&gt;
&lt;p&gt;Elasticsearch中，内置了很多分词器（analyzers）。下面来进行比较下系统默认分词器和常用的中文分词器之间的区别。&lt;br&gt;
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="http://yoursite.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能调优监控工具jps、jstack、jmap、jhat、jstat等使用详解</title>
    <link href="http://yoursite.com/2018/01/21/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7jps%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%E3%80%81jstat%E7%AD%89%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/21/JVM性能调优监控工具jps、jstack、jmap、jhat、jstat等使用详解/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="javap-和-javac"><a href="#javap-和-javac" class="headerlink" title="javap 和  javac"></a>javap 和  javac</h3><ul><li>javac -verbose 类名.java</li><li>java -verbose 类名</li><li>javap -c 类名</li><li>javap -verbose 类名</li></ul><hr><a id="more"></a><h4 id="javap-help"><a href="#javap-help" class="headerlink" title="javap -help"></a>javap -help</h4><p>用法: javap <options> <classes></classes></options></p><p>其中, 可能的选项包括:</p><p>  -help  –help  -?        输出此用法消息</p><p>  -version                 版本信息</p><p>  -v  -verbose             输出附加信息</p><p>  -l                       输出行号和本地变量表</p><p>  -public                  仅显示公共类和成员</p><p>  -protected               显示受保护的/公共类和成员</p><p>  -package                 显示程序包/受保护的/公共类<br>                           和成员 (默认)</p><p>  -p  -private             显示所有类和成员</p><p>  -c                       对代码进行反汇编</p><p>  -s                       输出内部类型签名</p><p>  -sysinfo                 显示正在处理的类的<br>                           系统信息 (路径, 大小, 日期, MD5 散列)</p><p>  -constants               显示最终常量</p><p>  -classpath <path></path>        指定查找用户类文件的位置</p><p>  -cp <path></path>               指定查找用户类文件的位置</p><p>  -bootclasspath <path></path>    覆盖引导类文件的位置</p><hr><h4 id="javac-help"><a href="#javac-help" class="headerlink" title="javac -help"></a>javac -help</h4><p>用法: javac <options> <source files=""></options></p><p>其中, 可能的选项包括:</p><p>  -g                         生成所有调试信息</p><p>  -g:none                    不生成任何调试信息</p><p>  -g:{lines,vars,source}     只生成某些调试信息</p><p>  -nowarn                    不生成任何警告</p><p>  -verbose                   输出有关编译器正在执行的操作的消息</p><p>  -deprecation               输出使用已过时的 API 的源位置</p><p>  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</p><p>  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</p><p>  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</p><p>  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</p><p>  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</p><p>  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</p><p>  -proc:{none,only}          控制是否执行注释处理和/或编译。</p><p>  -processor <class1>[,<class2>,<class3>…] 要运行的注释处理程序的名称; 绕过默认的搜索进程</class3></class2></class1></p><p>  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</p><p>  -parameters                生成元数据以用于方法参数的反射</p><p>  -d &lt;目录&gt;                    指定放置生成的类文件的位置</p><p>  -s &lt;目录&gt;                    指定放置生成的源文件的位置</p><p>  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</p><p>  -implicit:{none,class}     指定是否为隐式引用文件生成类文件</p><p>  -encoding &lt;编码&gt;             指定源文件使用的字符编码</p><p>  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</p><p>  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</p><p>  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</p><p>  -version                   版本信息</p><p>  -help                      输出标准选项的提要</p><p>  -A关键字[=值]                  传递给注释处理程序的选项</p><p>  -X                         输出非标准选项的提要</p><p>  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</p><p>  -Werror                    出现警告时终止编译</p><p>  @&lt;文件名&gt;                     从文件读取选项和文件名</p><hr><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>用来查看基于HotSpot的JVM里面中，所有具有访问权限的Java进程的具体状态, 包括进程ID，进程启动的路径及启动参数等等，与unix上的ps类似，只不过jps是用来显示java进程，可以把jps理解为ps的一个子集。</p><p>使用jps时，如果没有指定hostid，它只会显示本地环境中所有的Java进程；如果指定了hostid，它就会显示指定hostid上面的java进程，不过这需要远程服务上开启了jstatd服务。</p><h4 id="jps-help"><a href="#jps-help" class="headerlink" title="jps -help"></a>jps -help</h4><p>usage: jps [-help]</p><pre><code>jps [-q] [-mlvV] [&lt;hostid&gt;]</code></pre><p>Definitions:</p><pre><code>&lt;hostid&gt;:  &lt;hostname&gt;[:&lt;port&gt;]</code></pre><p>-q：忽略输出的类名、Jar名以及传递给main方法的参数，只输出pid。</p><p>-m：输出传递给main方法的参数，如果是内嵌的JVM则输出为null。</p><p>-l：输出完全的包名，应用主类名，jar的完全路径名</p><p>-v：输出传给jvm的参数</p><p>-V：输出通过标记的文件传递给JVM的参数（.hotspotrc文件，或者是通过参数-XX:Flags=<filename>指定的文件）。</filename></p><p>-J  用于传递jvm选项到由javac调用的java加载器中，例如，“-J-Xms48m”将把启动内存设置为48M，使用-J选项可以非常方便的向基于Java的开发的底层虚拟机应用程序传递参数。</p><hr><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息，如果是在64位机器上，需要指定选项”-J-d64”，Windows的jstack使用方式只支持以下的这种方式：</p><blockquote><p>jstack [-l] pid</p></blockquote><p>如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。</p><h4 id="jstack-help"><a href="#jstack-help" class="headerlink" title="jstack -help"></a>jstack -help</h4><p>Usage:</p><pre><code>jstack [-l] &lt;pid&gt;    (to connect to running process)jstack -F [-m] [-l] &lt;pid&gt;    (to connect to a hung process)jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;    (to connect to a core file)jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;    (to connect to a remote debug server)</code></pre><p>Options:</p><pre><code>-F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)(当’jstack [-l] pid’没有相应的时候强制打印栈信息)-m  to print both java and native frames (mixed mode)(打印java和native c/c++框架的所有栈信息.)-l  long listing. Prints additional information about locks (长列表. 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表.)-h  or -help to print this help message (打印帮助信息)</code></pre><hr><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>Jstat 用于监控基于HotSpot的JVM，对其堆的使用情况进行实时的命令行的统计，使用jstat我们可以对指定的JVM做如下监控：</p><ul><li>类的加载及卸载情况</li><li>查看新生代、老生代及持久代的容量及使用情况</li><li>查看新生代、老生代及持久代的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间</li><li>查看新生代中Eden区及Survior区中容量及分配情况等</li></ul><p>jstat -help</p><p>Usage:</p><pre><code>jstat -help|-optionsjstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></pre><p>Definitions:<br>&gt;</p><blockquote><p>  <option>      An option reported by the -options option</option></p><p>  <vmid>        Virtual Machine Identifier. A vmid takes<br> the following form:<br>                     <lvmid>[@<hostname>[:<port>]]<br>                Where <lvmid> is the local vm identifier for the target<br>                Java virtual machine, typically a process id; <hostname> is<br>                the name of the host running the target Java virtual machine;<br>                and <port> is the port number for the rmiregistry on the<br>                target host. See the jvmstat documentation for a more complete<br>                description of the Virtual Machine Identifier.</port></hostname></lvmid></port></hostname></lvmid></vmid></p><p>  <lines>       Number of samples between header lines.</lines></p><p>  <interval>    Sampling interval. The following forms are allowed:<br>                    <n>[“ms”|”s”]<br>                Where <n> is an integer and the suffix specifies the units as<br>                milliseconds(“ms”) or seconds(“s”). The default units are “ms”.</n></n></interval></p><p>  <count>       Number of samples to take before terminating.</count></p><p>  -J<flag>      Pass <flag> directly to the runtime system.</flag></flag></p></blockquote><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>1、<a href="http://blog.csdn.net/zhaozheng7758/article/details/8623549" target="_blank" rel="noopener">jstat命令详解</a></p><p>2、<a href="http://blog.csdn.net/fenglibing/article/details/6411951" target="_blank" rel="noopener">jstat命令(Java Virtual Machine Statistics Monitoring Tool)</a></p><p>3、<a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#class_option" target="_blank" rel="noopener">http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#class_option</a></p><hr><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）。</p><p>可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。使用方法</p><blockquote><p>jmap -histo pid</p></blockquote><p>如果连用SHELL</p><blockquote><p>jmap -histo pid&gt;a.log</p></blockquote><p>可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出GC回收了哪些对象。</p><blockquote><p>jmap -dump:format=b,file=outfile 3024</p></blockquote><p>可以将3024进程的内存heap输出出来到outfile文件里，再配合MAT（内存分析工具(Memory Analysis Tool），使用参见：<a href="http://blog.csdn.net/fenglibing/archive/2011/04/02/6298326.aspx" target="_blank" rel="noopener">http://blog.csdn.net/fenglibing/archive/2011/04/02/6298326.aspx</a>）或与jhat (Java Heap Analysis Tool)一起使用，能够以图像的形式直观的展示当前内存是否有问题。</p><p>64位机上使用需要使用如下方式：</p><blockquote><p>jmap -J-d64 -heap pid</p></blockquote><h4 id="jmap-help"><a href="#jmap-help" class="headerlink" title="jmap -help"></a>jmap -help</h4><p>Usage:</p><pre><code>jmap [option] &lt;pid&gt;    (to connect to running process)jmap [option] &lt;executable &lt;core&gt;    (to connect to a core file)jmap [option] [server_id@]&lt;remote server IP or hostname&gt;    (to connect to remote debug server)</code></pre><p>where <option> is one of:</option></p><pre><code>&lt;none&gt;               to print same info as Solaris pmap-heap                to print java heap summary-histo[:live]        to print histogram of java object heap; if the &quot;live&quot;                     suboption is specified, only count live objects-clstats             to print class loader statistics-finalizerinfo       to print information on objects awaiting finalization-dump:&lt;dump-options&gt; to dump java heap in hprof binary format                     dump-options:                       live         dump only live objects; if not specified,                                    all objects in the heap are dumped.                       format=b     binary format                       file=&lt;file&gt;  dump heap to &lt;file&gt;                     Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;-F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo                     to force a heap dump or histogram when &lt;pid&gt; does not                     respond. The &quot;live&quot; suboption is not supported                     in this mode.-h | -help           to print this help message-J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</code></pre><p>参数说明</p><p>1)、options：</p><p>executable Java executable from which the core dump was produced.<br>(可能是产生core dump的java可执行程序)</p><p>core 将被打印信息的core dump文件</p><p>remote-hostname-or-IP 远程debug服务的主机名或ip</p><p>server-id 唯一id,假如一台主机上多个远程debug服务</p><p>2）、基本参数：</p><p>-dump:[live,]format=b,file=<filename> 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件.</filename></p><p>-finalizerinfo 打印正等候回收的对象的信息.</p><p>-heap 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.</p><p>-histo[:live] 打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量.</p><p>-permstat 打印classload和jvm heap长久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.</p><p>-F 强迫.在pid没有相应的时候使用-dump或者-histo参数. 在这个模式下,live子参数无效.</p><p>-h | -help 打印辅助信息</p><p>-J 传递参数给jmap启动的jvm.</p><p>pid 需要被打印配相信息的java进程id,创业与打工的区别 - 博文预览,可以用jps查问.</p><hr><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>jinfo 可以输出并修改运行时的java 进程的opts。</p><p>用处比较简单，用于输出JAVA系统参数及命令行参数。</p><p>用法是 <code>jinfo -opt  pid</code></p><p>如：查看2788的MaxPerm大小可以用  jinfo -flag MaxPermSize 2788。</p><p>jinfo -help</p><p>Usage:</p><pre><code>jinfo [option] &lt;pid&gt;    (to connect to running process)jinfo [option] &lt;executable &lt;core&gt;    (to connect to a core file)jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;    (to connect to remote debug server)</code></pre><p>where <option> is one of:</option></p><pre><code>-flag &lt;name&gt;         to print the value of the named VM flag-flag [+|-]&lt;name&gt;    to enable or disable the named VM flag-flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value-flags               to print VM flags-sysprops            to print Java system properties&lt;no option&gt;          to print both of the above-h | -help           to print this help message</code></pre><hr><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强。命令行里打 jconsole，选则进程就可以了。</p><p>需要注意的就是在运行jconsole之前，必须要先设置环境变量DISPLAY，否则会报错误，Linux下设置环境变量如下：</p><blockquote><p>export DISPLAY=:0.0</p></blockquote><p><img src="http://img.blog.csdn.net/20170312201809429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHpzXzEwNDEyMTgxMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以这里选择查看本地进程的状况，还是远程进程的状况</p><p><img src="http://img.blog.csdn.net/20170312201840055?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHpzXzEwNDEyMTgxMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>通过这张图可以看到内存、线程、类及CPU使用的一些情况。</p><hr><h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><p>参考文章：</p><p><a href="http://blog.csdn.net/tzs_1041218129/article/details/59165488" target="_blank" rel="noopener">程序员必备利器—Java程序性能分析工具Java VisualVM（Visual GC）</a></p><hr><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>用于对JAVA heap进行离线分析的工具，他可以对不同虚拟机中导出的heap信息文件进行分析，如Linux上导出的文件可以拿到WINDOWS上进行分析，可以查找诸如内存方面的问题，使用方式可以查看这篇文章：</p><p><a href="http://blog.csdn.net/gtuu0123/archive/2010/11/27/6039474.aspx" target="_blank" rel="noopener">jhat命令</a></p><p>不过jhat和MAT比较起来，就没有MAT那么直观了，MAT是以图形界面的方式展现结果，MAT的使用方式可以参看文章：</p><p><a href="http://blog.csdn.net/fenglibing/archive/2011/04/02/6298326.aspx" target="_blank" rel="noopener">MAT(Memory Analyzer Tool)工具入门介绍</a></p><p>Usage:<br>jhat [-stack <bool>] [-refs <bool>] [-port <port>] [-baseline <file>] [-debug <int>] [-version] [-h|-help] <file></file></int></file></port></bool></bool></p><pre><code>-J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For                  example, -J-mx512m to use a maximum heap size of 512MB-stack false:     Turn off tracking object allocation call stack.-refs false:      Turn off tracking of references to objects-port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000-exclude &lt;file&gt;:  Specify a file that lists data members that should                  be excluded from the reachableFrom query.-baseline &lt;file&gt;: Specify a baseline object dump.  Objects in                  both heap dumps with the same ID and same class will                  be marked as not being &quot;new&quot;.-debug &lt;int&gt;:     Set debug level.                    0:  No debug output                    1:  Debug hprof file parsing                    2:  Debug hprof file parsing, no server-version          Report version number-h|-help          Print this help and exit&lt;file&gt;            The file to read</code></pre><hr><h3 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h3><p>用来对core文件和正在运行的Java进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和Sun studio里面所带的dbx非常相似，但 jdb是专门用来针对Java应用程序的。</p><hr><h3 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h3><p>jstatd是一个基于RMI（Remove Method Invocation）的服务程序，它用于监控基于HotSpot的JVM中资源的创建及销毁，并且提供了一个远程接口允许远程的监控工具连接到本地的JVM执行命令。</p><p>jstatd是基于RMI的，所以在运行jstatd的服务器上必须存在RMI注册中心，如果没有通过选项”-p port”指定要连接的端口，jstatd会尝试连接RMI注册中心的默认端口。</p><p>用法：</p><blockquote><p>jstatd [-nr] [-p port] [-n rminame]</p></blockquote><p>-nr 如果RMI注册中心没有找到，不会创建一个内部的RMI注册中心。</p><p>-p port RMI注册中心的端口号，默认为1099。</p><p>-n rminame 默认为JStatRemoteHost；如果同一台主机上同时运行了多个jstatd服务，rminame可以用于唯一确定一个jstatd服务；这里需要注意一下，如果开启了这个选项，那么监控客户端远程连接时，必须同时指定hostid及vmid，才可以唯一确定要连接的服务，这个可以参看jps章节中列出远程服务器上Java进程的示例。</p><p>-J 用于传递jvm选项到由javac调用的java加载器中，例如，“-J-Xms48m”将把启动内存设置为48M，使用-J选项可以非常方便的向基于Java的开发的底层虚拟机应用程序传递参数。</p><hr><p>参考文章</p><p><a href="http://blog.csdn.net/fenglibing/article/details/6411999" target="_blank" rel="noopener">JDK内置工具使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;javap-和-javac&quot;&gt;&lt;a href=&quot;#javap-和-javac&quot; class=&quot;headerlink&quot; title=&quot;javap 和  javac&quot;&gt;&lt;/a&gt;javap 和  javac&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;javac -verbose 类名.java&lt;/li&gt;
&lt;li&gt;java -verbose 类名&lt;/li&gt;
&lt;li&gt;javap -c 类名&lt;/li&gt;
&lt;li&gt;javap -verbose 类名&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="性能调优工具" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>面试过阿里等互联网大公司，我知道了这些套路</title>
    <link href="http://yoursite.com/2018/01/21/Interview-summary/"/>
    <id>http://yoursite.com/2018/01/21/Interview-summary/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/shanghai.jpeg-1" alt=""></p><a id="more"></a><h3 id="前面感谢一波"><a href="#前面感谢一波" class="headerlink" title="前面感谢一波"></a>前面感谢一波</h3><p>因为看到掘金在做秋招求职征文大赛，赞助商也有牛客网，自己前段时间也稍微写了篇博客总结我的大学生活，<a href="http://www.54tianzhisheng.cn/2017/08/26/recommend-books/" target="_blank" rel="noopener">那些年我看过的书 —— 致敬我的大学生活 —— Say Good Bye ！</a>  博客中稍微简单的介绍了下自己的求职，重点是推荐了下我自己看过的那些书籍，对我帮助真的很大。</p><p>如今借这么个机会，回馈掘金和牛客网，想想自己这一年在掘金也写过不少文章，从 0 个粉丝到如今被 11047 人（截止写此篇文章时）关注，有点小激动，竟然这么多粉，也不知道真正活跃的用户有多少。不管怎样，这一年在掘金还是收获很多的，不仅可以阅读到很多大神的文章，学习新的知识，而且还遇到了好几个不错的哥们，如今平常也有和他们交流，比如 ：<a href="https://juejin.im/user/5904c637b123db3ee479d923" target="_blank" rel="noopener">芋道源码</a> 老哥人就很不错，在上海还和老哥见过面，吃过饭，平常对我帮助也很大，会推荐一些很有用的书籍给我看。欢迎大家关注他的博客：<a href="http://vip.iocoder.cn/" target="_blank" rel="noopener">芋道源码的博客</a>   ，里面有好几系列的源码分析博客文章呢。至于牛客网，我就更是老用户了，印象中好像是大一的时候注册的，那时有空的话就会去上面刷几道基础题，写写题解，坚持了好久了，如今早已是红名了。（其实是水出来的，哈哈）在牛客网遇到的大神也是超多，好多朋友几乎都是通过牛客网认识的，那时早的时候一起在一群讨论问题，别提那场面了，震惊，我等弱渣瑟瑟发抖。感谢叶神，左神，牛妹！</p><p>说着说着，好像偏题了。<img src="http://ohfk1r827.bkt.clouddn.com/201612031957235746.gif" alt=""></p><p>正式进入话题吧！</p><h3 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h3><p>本篇秋招求职征文主要分享如下几方面：<strong>招聘职位需求套路</strong> 、<strong>招聘面试的套路</strong>、<strong>简历撰写套路</strong>、<strong>简历投递套路</strong> 、<strong>找工作经历</strong> 、<strong>自己面试面经</strong> 、<strong>实习感悟</strong>、<strong>书籍推荐</strong> 、<strong>优秀网站推荐</strong> 、<strong>优秀博客推荐</strong> 、<strong>求职资料放送</strong>。</p><h3 id="招聘职位需求套路"><a href="#招聘职位需求套路" class="headerlink" title="招聘职位需求套路"></a>招聘职位需求套路</h3><p>摘举下几个公司的招聘需求：（from lagou）</p><p>1、Java开发校招生( 有赞 )</p><blockquote><p>职位诱惑：<br>福利好待遇佳，技术氛围浓，有大牛带成长快<br>职位描述：</p><p>有赞2018校招官方网申地址（请在官网投递，勿直接在Lagou上投递）：<br><a href="https://job.youzan.com/campus" target="_blank" rel="noopener">https://job.youzan.com/campus</a><br>岗位职责</p><ol><li>我们拥有世界级的 SaaS 电商解决方案，每天处理几百万订单、几亿条消息，并且量级不断攀升；</li><li>我们开放了有赞云，连接了数十万开发者，大大提升了 SaaS 对商家产生的价值；</li><li>我们正在新零售的潮流中激流勇进、开疆拓土，用产品技术撬动巨大的市场；</li><li>而你的工作，就是参与这些大流量系统的研发，哪怕提升1%的性能和稳定性都将是激动人心的时刻。</li></ol><p>岗位要求</p><ol><li>2018届本科及以上学历应届毕业生，计算机或者软件工程相关专业；</li><li>具备扎实的计算机基础知识，至少熟练使用一门主流开发语言；</li><li>积极参与开发实践，如果拥有引以为豪的项目经历则加分；</li><li>热衷数据结构与算法，如果一不小心在 ACM 赛场摘过金，夺过银则加分；</li><li>能在 Linux 上写任何脚本，比王者荣耀上手还快则加分；</li><li>快速学习新鲜事物，自我驱动追求卓越，积极应对问题和变化。</li></ol></blockquote><p>2、京东居家生活事业部-汽车用品招聘实习生（2018届）</p><blockquote><p>职位诱惑：<br>京东商城</p><p>职位描述：<br>京东商城-汽车用品部门招聘实习生</p><p>我们需要这样的你：</p><ul><li>2018届毕业生（本科或硕士均可）</li><li>学习能力强</li><li>担当、抗压、接受变化</li><li>能长期实习（优秀者有转正机会）</li><li>需要一个大的平台来展示和发挥自己的能力</li></ul><p>你将收获：</p><ul><li>重新认识快速成长的自己</li><li>一份世界500强的实习经历</li><li>一群优秀的伙伴</li></ul></blockquote><p>3、爱奇艺 Java 实习生 - 游戏事业部</p><blockquote><p>要求：至少 6 个月以上每周三天以上实习。</p><ol><li>本科以上学历，计算机、软件工程相关专业；</li><li>基础扎实，熟悉 Java 编程，熟悉 Spring、MyBatis 等框架优先；</li><li>熟悉 SQL 语句，熟练使用 MySQL 数据库；</li><li>良好的沟通、表达、协调能力，富有激情，学习能力强；</li><li>有 GitHub 账号或者技术博客优先；</li><li>热爱游戏行业优先。</li></ol></blockquote><p>这里随便找了三个，从招聘需求里看，好多公司目前招聘的话在招聘需求中并不怎么会写的很清楚，有的也不会说明要求的技术栈，这其实有时会对我们这种新人来说，有点不好的，这样的话我们就没有明确的目标去复习，还有就是一些加分项，其实也是有点帮助的。就比如有些招聘上面的说有优秀博客和 GitHub 者优先，这两点的话我们其实可以在大学慢慢积累出来的，对面试确实有帮助，我好些面试机会都是靠这两个的。还有套路就是，别光信他这招聘需求，进去面试可能就不问你这些方面的问题了，那些公司几乎都是这么个套路：<strong>面试造火箭，入职拧螺丝</strong> ！  进去公司之前可能需要你懂很多东西，但是进去的话还只是专门做一方面的东西。不管怎样，如果你有机会进去大公司的话（而且适合去），还是去大公司吧，出来大厂光环不少。</p><ol><li>认真耐心地拧螺丝钉，说不定有机会去造大火箭——正规大公司的节奏。</li><li>短时间把螺丝拧出花，说不定有机会造小火箭——上升中创业公司的节奏。</li></ol><h3 id="招聘面试的套路"><a href="#招聘面试的套路" class="headerlink" title="招聘面试的套路"></a>招聘面试的套路</h3><p>参考：<a href="https://mp.weixin.qq.com/s/qRwDowetBkJqpeMeAZsIpA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qRwDowetBkJqpeMeAZsIpA</a>    一个在掘金上认识的老哥，在京东工作，写的不错，干脆分享下。大家可以去看他的博客，<a href="http://mindwind.me/" target="_blank" rel="noopener">http://mindwind.me/</a>   当时我求职的时候通过作者博客也学到不少东西。</p><p>一次集中的扩招需求，有点像每年一度的晋升评审，都需要对大量的候选人进行定级评审，因为每一个新招聘的人员都会对其有一个定级的过程。</p><p>维度：</p><blockquote><ul><li>通用能力：考察其沟通表达、学习成长等</li><li>专业知识：考察其知识的掌握、深度、广度等</li><li>专业能力：考察其技能应用的能力和结果</li><li>工作业绩：考察其工作成果、产出、创新点等</li><li>价值观：考察其认知、理解、行为等</li></ul></blockquote><p>整个面试过程会包括下面几个部分：</p><p><strong>自我介绍</strong><br>一开始的简短自我介绍，考察点在于对自我的总结、归纳和认知能力。观察其表达的逻辑性和清晰性，有个整体印象。</p><p><strong>项目经历</strong><br>一般我不会专门问一些比较死的专业技术点之类的知识，都是套在候选人的项目经历和过往经验中穿插。通过其描述，来判断其掌握知识点的范围和深度，以及在实际的案例中如何运用这些知识与技能解决真正的问题的。</p><p>所以，不会有所谓的题库。每一个我决定面试的候选人，都是提前细读其简历，提炼场景和发掘需要问的问题，相当于面试前有个二三十分钟的备课过程，组织好面试时的交互过程与场景，以顺利达到我想要了解的点。</p><p><strong>团队合作</strong><br>通常还会问候选人其所在团队中的角色，他们的工作模式、协作方式，并给出一些真实的场景化案例观察其应对的反应。评价一下关于他周围的同事、下属或领导，了解他在团队中的自我定位。这里的考察点是沟通协作方面的通用能力。</p><p><strong>学习成长</strong><br>这个维度考察的关键点包括：成长潜力、职业生涯规划的清晰度。人与人之间成长速度的关键差距，我自己观察得出的结论在于：自驱力。而路径的清晰性，也是产生自驱的一个源动力，否则可能会感觉迷茫，而陷于困顿。</p><p><strong>文化匹配</strong><br>这算是价值观的一部分吧。其实，这是最难考核的，我没有什么好方法，基本靠感觉。曾经有过好几次碰到经历和技能都不错的人，但总是感觉哪里不对，但又着急要人，就放进来了。但最终感觉是对的，合作很快就结束了，人也走了。</p><p><strong>综合评价</strong><br>总结点评候选人的优势、劣势并进行技术定级，定级也没有绝对标准，而是相对的。我一般就是和周围觉得差不多级别的人的平均水准比较下，大概就会有一个技术级别的判断。</p><p><strong>套路</strong></p><p>招聘面试，其实是一个对人的筛选，而筛选的本质是匹配 —— 匹配人与职位。第一，你得非常清楚地理解，这个职位需要什么样属性的人。第二，确定你的候选人是否拥有这个职位要求的必须属性。那么，首先回答第一个问题，一般的职位需要什么样的属性？</p><p>属性，又可以进一步拆解为三个层次。第一层次是「技能（Skills）」，技能是你习得的一种工具，就像程序员会用某种语言和框架来编写某类应用程序。第二层次是「能力（Abilities）」，能力是你运用工具的思考和行为方式，用同样的语言和框架编写同样程序的程序员能力可以差别很大。而第三层次是「价值观（Values）」，价值观是一个人根深蒂固的信念以及驱动行为的原因与动力所在。</p><h3 id="简历撰写套路"><a href="#简历撰写套路" class="headerlink" title="简历撰写套路"></a>简历撰写套路</h3><p>参考：<a href="https://mp.weixin.qq.com/s/3f8hGAQ-auLdkxkQ8XG3CQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3f8hGAQ-auLdkxkQ8XG3CQ</a></p><p>简历，是如此重要，它是获得一份满意工作的敲门砖，但不同的简历敲门的声响可不同。</p><p>但很多时候简历给人的感觉也似乎微不足道，因为没有人会真正细致的去读一份简历。而仅仅是快速的浏览一遍，就几乎同时对一个候选人形成了一种要么强烈，要么无感的印象。现实中的真实情况是，你的简历只有十几二十秒的时间窗口机会会被浏览到，然后就决定了能否进入下一步。</p><p>要让面试官看了你的简历后：知道你做过什么？看看技能、经历与岗位需求的匹配度，然后再问问你是谁？你通过简历散发出来的味道是什么感觉，我愿意和这样的人一起共事么？</p><p>一份简历的最少必要内容包括：</p><blockquote><ul><li><p>个人信息</p></li><li><ul><li>姓名</li><li>年龄</li><li>手机</li><li>邮箱</li></ul></li><li><p>教育经历</p></li><li><ul><li>博士（硕士、本科） 有多个全部写出来，最高学历写在上面</li></ul></li><li><p>工作经历（最匹配职位需求的，挑选出来的 TOP3 的项目）</p></li><li><ul><li><p>项目1</p></li><li><ul><li>项目背景上下文（场景、问题）</li><li>你在其中的角色（职责、发挥的作用、结果度量）</li><li>与此项经历有关的知识与技能（技术栈）</li></ul></li><li><p>项目2</p></li><li><p>项目3</p></li></ul></li><li><p>附加信息</p></li><li><ul><li>博客：持续有内容，不碎碎念</li><li>开源：GitHub 持续 commit</li><li>社区：有一定专业影响力的</li><li>书籍：用心写的</li><li>演讲：行业大会级别的</li><li>专利：凑数的就算了</li><li>论文：学术界比较有影响力的</li><li>爱好：真正的兴趣点</li></ul></li></ul></blockquote><p>对于我们学生，缺乏工作经历，那就写写独特的学习或实习经历。同学们大家都共有的经历就不要随便写上去凑数了。对于学生，看重的是通用能力，学习能力，适应能力以及对工作的态度和热情。如果没有区分度高的经历，那么有作品也是很好的。比如将你的做的网站部署出来，把地址写在简历上。</p><p>关于技术栈部分的技术术语，很多程序员不太注意。比如，把 Java 写成 java 或 JAVA，Java 已是一个专有品牌名词，大小写要完全符合，这一点和 iOS 类似（i 小写，OS 大写）。另外，像 HTML，CSS 则全部大写，因为这是多个单词的缩写。一些小小的细节就能读出你的专业性和散发出来的味道。最后，技术术语不是罗列得多就好，不是真正熟练的技能，不要轻易写进简历。因为这将给你自己挖坑。你可以将你自己擅长的或者很熟的知识点写进去，有时想着重就加粗或者打个括号，这样可以挖坑给面试官，让他去问你熟悉的（前提要确保你真的能讲清楚，我试过这个方法很有效的）。</p><p>然后就是简历格式了，最好是 PDF 了，Word 在不同的电脑上的打开效果可能不一样，格式可能会变，况且有些人的电脑不一定装了 Word，不过我喜欢用 Markdown 写简历，简洁，适合程序员，然后把 Markdown 转换成 PDF 出来。</p><h3 id="简历投递套路"><a href="#简历投递套路" class="headerlink" title="简历投递套路"></a>简历投递套路</h3><p><strong>内推</strong></p><p>有内推通道尽量走内推通道，不知道方便多少，而且成功几率也很大！找熟人，找学长学姐吧！牛客网讨论区很多内推帖子，可以去找找。不过今年的好多公司的内推通道都不咋管用了，套路越来越多了。记得去年好多公司内推都是免笔试，直接进入面试阶段，今年直接变成内推免简历筛选，进入笔试。因为现在的内推越来越不靠谱，直接面试的话，会增加公司的面试成本，干脆笔试再筛选一部分人。</p><p><strong>拉勾网</strong></p><p>拉勾上还是算不错的。</p><p><strong>Boss 直聘</strong></p><p>虽说前段时间出现了程序员找工作进入传销最后导致死亡的惨事发生，但是里面总比智联招聘和前程无忧靠谱点。因为智联招聘和前程无忧几乎被广告党和培训机构给占领了。</p><p><strong>脉脉</strong></p><p>里面招应届生和实习生比较少，但是也有，可以试试。</p><p>总之，简历投递给公司之前，请确认下这家公司到底咋样，先去百度了解下，别被坑了，每个平台都有一些居心不良的广告党等着你上钩，千万别上当！！！</p><h3 id="找工作经历"><a href="#找工作经历" class="headerlink" title="找工作经历"></a>找工作经历</h3><p>这段经历，算是自己很难忘记的经历吧。既辛酸既充实的日子！也很感谢自己在这段时间的系统复习，感觉把自己的基础知识再次聚集在一起了，自己的能力在这一段时间提升的也很快。后面有机会的话我也想写一系列的相关文章，为后来准备工作（面试）的同学提供一些自己的帮助。自己在找工作的这段时间面过的公司也有几家大厂，但是结果都不是很好，对我自己有很大的压力，当时心里真的感觉 ：“自己真的有这么差”，为什么一直被拒，当时很怀疑自己的能力，自己也有总结原因。一是面试的时候自己准备的还不够充分，虽说自己脑子里对这些基础有点印象，但是面试的时候自己稍紧张下就描述不怎么清楚了，导致面试官觉得你可能广度够了，深度还不够（这是阿里面试官电话面试说的）；二是自己的表达能力还是有所欠缺，不能够将自己所要表达的东西说出来，这可能我要在后面加强的地方；三是我的学校问题。在面了几家公司失败后，终于面了家公司要我了，我也确定在这家公司了。很幸运，刚出来，就有一个很好（很负责）的架构师带我，这周就给了我一个很牛逼的项目给我看，里面新东西很多，说吃透了这个项目，以后绝对可以拿出去吹逼（一脸正经.jpg）。找工作期间，自己也经常去收集一些博客，并把它保存下来，这样能够让自己下次更好的系统复习，还在牛客网整理了很多面经，每天看几篇面经，知道面试一般问什么问题，都有啥套路，其实你看多了面经就会发现，面试考的题目几乎都差不多，区别不是很大。目前我的找工作经历就简短的介绍到这里了，如果感兴趣的话，可以加群：528776268   期待志同道合的你。</p><h3 id="自己面试面经"><a href="#自己面试面经" class="headerlink" title="自己面试面经"></a>自己面试面经</h3><h4 id="亚信"><a href="#亚信" class="headerlink" title="亚信"></a>亚信</h4><p>地址：<a href="http://www.54tianzhisheng.cn/2017/08/04/yaxin/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/08/04/yaxin/</a></p><p>1）自我介绍（说到一个亮点：长期坚持写博客，面试官觉得这个习惯很好，算加分项吧）</p><p>2）看到简历项目中用到 Solr，详细的问了下 Solr（自己介绍了下 Solr 的使用场景和建立索引等东西）</p><p>3）项目里面写了一个 “ 敏感词和 JS 标签过滤防 XSS 攻击”，面试官让我讲了下这个 XSS 攻击，并且是怎样实现的</p><p>4）项目里写了支持 Markdown，问是不是自己写的解析代码，（回答不是，自己引用的是 GitHub上的一个开源项目解析的）</p><p>5）想问我前端的知识，我回复到：自己偏后端开发，前端只是了解，然后面试官就不问了</p><p>6）问我考不考研？</p><p>7）觉得杭州怎么样？是打算就呆在杭州还是把杭州作为一个跳板？</p><p>8）有啥小目标？以后是打算继续技术方向，还是先技术后管理（还开玩笑的说：是不是赚他几个亿，当时我笑了笑）</p><p>9）有啥兴趣爱好？</p><p><strong>总结</strong>：面试问的问题不算多，主要是通过简历上项目所涉及的东西提问的，如果自己不太会的切记不要写上去。面试主要考察你回答问题来判断你的逻辑是否很清楚。</p><h4 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h4><p>地址：<a href="http://www.54tianzhisheng.cn/2017/08/04/iqiyi/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/08/04/iqiyi/</a></p><h5 id="笔试（半个小时）"><a href="#笔试（半个小时）" class="headerlink" title="笔试（半个小时）"></a>笔试（半个小时）</h5><p>题目：（记得一些）</p><p>1、重载重写的区别？</p><p>2、转发和重定向的区别？</p><p>3、画下 HashMap 的结构图？HashMap 、 HashTable 和 ConcurrentHashMap 的区别？</p><p>4、statement 和 preparedstatement 区别？</p><p>5、JSP 中一个 <c:value> 中取值与直接取值的区别？会有什么安全问题？</c:value></p><p>6、实现一个线程安全的单例模式</p><p>7、一个写 sql 语句的题目</p><p>8、自己实现一个 List，（主要实现 add等常用方法）</p><p>9、Spring 中 IOC 和 AOP 的理解？</p><p>10、两个对象的 hashcode 相同，是否对象相同？equal() 相同呢？</p><p>11、@RequestBody 和 @ResponseBody 区别？</p><p>12、JVM 一个错误，什么情况下会发生？</p><p>13、常用的 Linux 命令？</p><h5 id="第一轮面试（80-分钟）"><a href="#第一轮面试（80-分钟）" class="headerlink" title="第一轮面试（80 分钟）"></a>第一轮面试（80 分钟）</h5><p>1、自我介绍</p><p>2、介绍你最熟悉的一个项目</p><p>3、讲下这个 XSS 攻击</p><p>4、HashMap 的结构？HashMap 、 HashTable 和 ConcurrentHashMap 的区别？</p><p>5、HashMap 中怎么解决冲突的？（要我详细讲下）</p><p>6、ConcurrentHashMap 和 HashTable 中线程安全的区别？为啥建议用 ConcurrentHashMap ？能把 ConcurrentHashMap  里面的实现详细的讲下吗？</p><p>7、Session 和 Cookie 的区别？</p><p>8、你项目中登录是怎样做的，用的 Cookie 和 Session？</p><p>9、讲讲你对 Spring 中的 IOC 和 AOP 的理解？</p><p>10、问了好几个注解的作用？</p><p>11、statement 和 preparedstatement 区别？</p><p>12、$ 和 # 的区别？以及这两个在哪些地方用？</p><p>13、前面项目介绍了数据是爬虫爬取过来的，那你讲讲你的爬虫是多线程的吧？</p><p>14、讲讲 Python 中的多线程和 Java 中的多线程区别？</p><p>15、自己刚好前几天在看线程池，立马就把面试官带到我熟悉的线程池，和面试官讲了下 JDK 自带的四种线程池、ThreadPoolExecutor 类中的最重要的构造器里面的七个参数，然后再讲了下线程任务进入线程池和核心线程数、缓冲队列、最大线程数量比较。</p><p>16、线程同步，你了解哪几种方式？</p><p>17、讲下 Synchronized？</p><p>18、讲下 RecentLock 可重入锁？ 什么是可重入锁？为什么要设计可重入锁？</p><p>19、讲下 Volatile 吧？他是怎样做到同步的？</p><p>20、Volatile 为什么不支持原子性？举个例子</p><p>21、Atomic 怎么设计的？（没看过源码，当时回答错了，后来才发现里面全部用 final 修饰的属性和方法）</p><p>22、问几个前端的标签吧？（问了一个不会，直接说明我偏后端，前端只是了解，后面就不问了）</p><p>23、SpringBoot 的了解？</p><p>24、Linux 常用命令？</p><p>25、JVM 里的几个问题？</p><p>26、事务的特性？</p><p>27、隔离级别？</p><p>28、网络状态码？以 2、3、4、5 开头的代表什么意思。</p><p>29、并发和并行的区别？</p><p>30、你有什么问题想问我的？</p><p>一面面完后面试官和说这份试卷是用来考 1~3 年开发工作经验的，让我准备一下，接下来的二面。</p><h5 id="第二轮面试（半个小时）"><a href="#第二轮面试（半个小时）" class="headerlink" title="第二轮面试（半个小时）"></a>第二轮面试（半个小时）</h5><p>1、一上来就问怎么简历名字都没有，我指了简历第一行的我的名字，还特意大写了，然后就问学校是不是在上海，我回答在南昌（感觉被鄙视了一波，后面我在回答问题的时候面试官就一直在玩手机，估计后面对我的印象就不是很好了）</p><p>2、自我介绍</p><p>3、说一说数据库建表吧（从范式讲）</p><p>4、讲讲多态？（这个我答出来了，可是面试官竟然说不是这样吧，可能面试官没听请，后面还说我是不是平时写多态比较少，感觉这个也让面试官对我印象减分）</p><p>5、将两个数转换（不借助第三个参数）</p><p>6、手写个插入排序吧（写完了和面试官讲了下执行流程）</p><p>7、讲讲你对 Spring 中的 IOC 和 AOP 的理解？</p><p>8、问了几个常用的 Linux 命令？</p><p>9、也问到多线程？和一面一样把自己最近看的线程池也讲了一遍</p><p>10、学 Java 多久了？</p><p>11、你有什么想问的？</p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>面试题目大概就是这么多了，有些问题自己也忘记了，面试题目顺序不一定是按照上面所写的。再次感谢爱奇艺的第一面面试官了，要不是他帮忙内推的，我可能还没有机会收到面试机会。自己接到爱奇艺面试邀请电话是星期一晚上快7点中的，之后加了面试官微信约好了星期四面试的（时间准备较短，之前没系统的复习过）。星期四一大早（5点就起床了），然后就收拾了下，去等公交车，转了两次车，然后再做地铁去爱奇艺公司的，总共路上花费时间四个多小时。总的来说，这次面试准备的时间不是很充裕，所以准备的个人觉得不是很好，通过这次的面试，发现面试还是比较注重基础和深度的，我也知道了自己的一些弱处，还需要在哪里加强，面试技巧上也要掌握些。为后面的其他公司继续做好充足的准备。加油！！！</p><h4 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h4><p>地址：<a href="http://www.54tianzhisheng.cn/2017/08/04/alibaba/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/08/04/alibaba/</a></p><p>（菜鸟网络部门）（49 分钟）</p><p>2017.08.02   晚上9点21打电话过来，预约明天什么时候有空面试，约好第二天下午两点。</p><p>2017.08.03   下午两点10分打过来了。</p><p>说看了我的<a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">博客</a>和 <a href="https://github.com/zhisheng17" target="_blank" rel="noopener">GitHub</a>，觉得我学的还行，知识广度都还不错，但是还是要问问具体情况，为什么没看到你春招的记录，什么原因没投阿里？非得说一个原因，那就是：我自己太菜了，不敢投。</p><p>1、先自我介绍</p><p>2、什么是多态？哪里体现了多态的概念？</p><p>3、HashMap 源码分析，把里面的东西问了个遍？最后问是不是线程安全？引出 ConcurrentHashMap</p><p>4、ConcurrentHashMap 源码分析</p><p>5、类加载，双亲委托机制</p><p>6、Java内存模型（一开始说的不是他想要的，主要想问我堆和栈的细节）</p><p>7、垃圾回收算法</p><p>8、线程池，自己之前看过，所以说的比较多，最后面试官说了句：看你对线程池了解还是很深了</p><p>9、事务的四种特性</p><p>10、什么是死锁？</p><p>11、乐观锁和悲观锁的策略</p><p>12、高可用网站的设计（有什么技术实现）</p><p>13、低耦合高内聚</p><p>14、设计模式了解不？你用过哪几种，为什么用，单例模式帮我们做什么东西？有什么好处？</p><p>15、你参与什么项目中成长比较快？学到了什么东西，以前是没有学过的？</p><p>16、项目中遇到的最大困难是怎样的？是怎么解决的？</p><p>17、智力题（两根不均匀的香，点一头烧完要一个小时，怎么确定15分钟）</p><p>18、你有什么问题想要问我的？</p><p>19、问了菜鸟网络他们部门主要做什么？</p><p>20、对我这次面试做个评价：看了你<a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">博客</a>和 <a href="https://github.com/zhisheng17" target="_blank" rel="noopener">GitHub</a>，知道你对学习的热情还是很高的，花了不少功夫，后面有通知！</p><p><strong>总结</strong>：面试总的来说，第一次电话面试，感觉好紧张，好多问题自己会点，但是其中的细节没弄清楚，自己准备的也不够充分。面试官很友好，看到我紧张，也安慰我说不要紧，不管以后出去面试啥的，不需要紧张，公司问的问题可能很广，你只需要把你知道的说出来就行，不会的直接说不会就行。之前一直不敢投阿里，因为自己准备的完全不够充分，但是在朋友磊哥的帮助下，还是试了下，不管结果怎么样，经历过总比没有的好。</p><p>后面说有通知，结果并没有，只看到官网的投递按钮变灰了。在掘金上一个朋友（我隔壁学校的），当时看我挂了说要不要让他租一起的隔壁邻居再内推下淘宝，我想想还是算了，自己目前能力真的是有限，达不到进阿里的要求！不过还是要感谢那个哥们，人真的超级好，虽然我们未曾谋面，但是有机会的话，我一定会请你吃饭的。</p><h4 id="哔哩哔哩"><a href="#哔哩哔哩" class="headerlink" title="哔哩哔哩"></a>哔哩哔哩</h4><p>首先直接根据简历项目开问，自我介绍都没有。</p><p>1、登录从前端到后端整个过程描述一遍？越详细越好，说到密码加密，网络传输，后台验证用户名和密码，Cookie 设置等。具体问我密码加密是前台还是后台加密，说了在后台加密？面试官说，那你做这个项目有什么意思？密码传输都是明文的，默认 HTTP 传递是明文传输，当时被面试官带进前台加密还是后台加密的沟里去了，没想到用 HTTPS ，后来后来的路上查了些资料才知道的，面试过程中他很想我说前台加密，但是前台加密算法那代码就摆在那里，很容易就给破解了吧，也没给点提示说 HTTPS，我只好投降</p><p>2、写一个查询的 sql 语句</p><p>3、线程同步的方法？Synchronized、Volatile、（面试官好像觉得 Volatile 不可以做到同步，我和他说了半天的 Volatile 原理 ，他竟然不认同，我开始怀疑他的实力了）、ThreadLocal、Atomic。</p><p>说到这些了，我当时竟然没把他带进我我给他挖的坑里去（线程池，之前好好研究过呢，可惜了）</p><p>4、Spring IOC 和 AOP 的理解？叫我写 AOP 的代码，我没写</p><p>5、JDK 动态代理和 Cglib 代理区别？</p><p>5、你觉得项目里面你觉得哪些技术比较好？我指了两个，然后他也没有问下去。</p><p>6、解释下 XSS 攻击</p><p>7、Spring 和 SpringBoot 的区别？</p><p>8、JVM 垃圾回收算法？分代中为什么要分三层？</p><p>9、OOM 是什么？什么情况会发生？</p><p>10、你觉得你有啥优点？</p><p>然后就叫我等一会，一会有人事来通知我，结果过了一会人事叫我可以回去等通知了。</p><p><strong>总结</strong>：到公司的时候已经一点多钟了，面试直接在一个很多人的地方（吃饭的地方）直接面的，周围还有人再吃饭，场景有点尴尬，面试过程感觉很随意，想到什么问题就问什么，完全没有衔接，问到的有些地方感觉面试官自己都不清楚，还怀疑我所说的，另外就是问题比较刁钻，总体技术也就那样吧！</p><h4 id="目前所在公司"><a href="#目前所在公司" class="headerlink" title="目前所在公司"></a>目前所在公司</h4><p>当时是我现在的老大（架构师）面的，先是电话面试过一次，问的问题也比较难，不过最后还是觉得我基础还是不错的。最后叫我去公司面试下，来到公司面试问的问题那就更难了，几乎好多都回答不出来，但是简单的说了下思路，最后再叫主任面试了下，问的问题就很简单了，最后就是  HR 面了，主要说了下工资问题和什么时候能报道！这几次面试的问题当时由于时间比较紧，也没去整理，现在也记不清楚了！目前自己已经工作了快一个月了，给的项目也完全是新东西，对我的挑战也很大，有时自己也确实不怎么知道，不过我老大很耐心的教我，对我也很不错，这也是我打算留在这里的原因，碰到个好老大不易！必须好好珍惜！</p><h3 id="实习感悟"><a href="#实习感悟" class="headerlink" title="实习感悟"></a>实习感悟</h3><p>进公司是架构运维组中的 Java 实习开发，目前实习已经快一个月了，说实话，实习后才发现一天真的很忙，写下这篇征文也是在周末整理大晚上写的。刚进公司就给了一个 Consul 的服务发现与注册和健康检查的项目，里面涉及的东西有 Consul、Docker、Nginx、Lua、ElasticSearch 还有几个很轻量级的框架，对我来说几乎都是新东西，确实需要时间去了解，再优化和改里面的 bug 的过程中，幸好我老大和我理了几次思路，才让我对整个项目有所进展，后续继续是在优化这项目（可能以后这个项目的所有东西都是我来做）。在上海，住的地方离公司有一定的距离，上班几乎要一个小时，每天花在上班路上的时间很多，这也导致我每天感觉很忙。公司上班时间比较弹性，无打卡，虽说公司不加班，但是每天自己都不怎么会按点下班，自己也想在实习阶段多学点东西！这段时间也是最关键的时间，碰到个问题，要花好久时间才能解决，也有可能未必解决得了，有时觉得自己啥都不会，这么点东西都做不好，有点否定自己。这也确实是自己的技术知识栈缺乏，和自己学的 SSM、Spring Boot 这些都不相关，也不怎么写业务逻辑代码。所以感觉很痛苦，不像自己以前写的代码那样顺畅，当然可能是自己以前自己写的项目太 low 了。</p><p>看到掘金-凯伦征文中写到：</p><blockquote><p><strong>公司其实并不期望刚刚进来的你，能够创造多少价值。新人是要成长的，在成长期难免会遇到各种各样的小问题，这可能是大多数人的必经之路，因为你所看到的同事，他们都比你在工作领域待的时间更久，有更多的经验，可以把他们作为目标，但不要把他们作为现在自己的标准，那样会压力太大。</strong></p></blockquote><p>感觉这段话对我现在很受用！ <strong>加油，好好挺过这个阶段，别轻易说放弃！</strong></p><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p>大学，我不怎么喜欢玩游戏，自己也还算不怎么堕落吧，看了以下的一些书籍，算是对我后面写博客、找工作也有很大的帮助。如果你是大神，请忽略，如果你还是还在大学，和我一样不想把时间浪费在游戏上，可以看看我推荐的一些书籍，有想讨论的请在评论下留下你的评论或者加上面给的群号。</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>1、《Java 核心技术》卷一 、卷二              两本书，算是入门比较好的书籍了</p><p>2、《疯狂 Java 讲义》                                很厚的一本书，里面的内容也是很注重基础了</p><p>3、《Java 并发编程的艺术》——  方腾飞 、魏鹏、程晓明著        方腾飞 是并发编程网的创始人，里面的文章确实还不错，可以多看看里面的文章，收获绝对很大。</p><p>4、《 Java多线程编程核心技术》——  高洪岩著   这本书也算是入门多线程编程的不错书籍，我之前还写了一篇读书笔记呢，<a href="http://www.54tianzhisheng.cn/2017/06/04/Java-Thread/" target="_blank" rel="noopener">《Java 多线程编程核心技术》学习笔记及总结</a>  , 大家如果不想看书的可以去看我的笔记。</p><p>5、《Java 并发编程实战》 这本书讲的有点难懂啊，不过确实也是一本很好的书，以上三本书籍如果都弄懂了，我觉得你并发编程这块可能大概就 OK 了，然后再去看看线程池的源码，了解下线程池，我觉得那就更棒了。不想看的话，请看我的博客：<a href="http://www.54tianzhisheng.cn/2017/07/29/ThreadPool/" target="_blank" rel="noopener">Java 线程池艺术探索</a>  我个人觉得还是写的很不错，那些大厂面试也几乎都会问线程池的东西，然后大概内容也就是我这博客写的</p><p>6、《Effective Java》中文版 第二版       算是 Java 的进阶书籍了，面试好多问题也是从这出来的</p><p>7、《深入理解 Java 虚拟机——JVM高级特性与最佳实践》第二版     这算是国内讲 JVM 最清楚的书了吧，目前还是只看了一遍，后面继续啃，大厂面试几乎也是都会考 JVM 的，阿里面 JVM 特别多，想进阿里的同学请一定要买这本书去看。</p><p>8、《深入分析Java  Web技术内幕  修订版》许令波著   里面知识很广，每一章都是一个不同的知识，可见作者的优秀，不愧是阿里大神。</p><p>9、《大型网站系统与 Java 中间件实践》—— 曽宪杰 著    作者是前淘宝技术总监，见证了淘宝网的发展，里面的讲的内容也是很好，看完能让自己也站在高处去思考问题。</p><p>10、《大型网站技术架构 —— 核心原理与案例分析》 —— 李智慧 著   最好和上面那本书籍一起看，效果更好，两本看完了，提升思想的高度！</p><p>11、《疯狂Java.突破程序员基本功的16课》 李刚 著       书中很注重 Java 的一些细节，讲的很深入，但是书中的错别字特多，可以看看我的读书笔记：<a href="http://www.54tianzhisheng.cn/2017/05/31/Java-16-lession/" target="_blank" rel="noopener">《疯狂 Java 突破程序员基本功的 16 课》读书笔记</a></p><p>12、《Spring 实战》   Spring 入门书籍</p><p>13、《Spring 揭秘》—— 王福强  著   这本书别提多牛了，出版时期为 2009 年，豆瓣评分为 9.0 分，写的是真棒！把 Spring 的 IOC 和 AOP 特性写的很清楚，把 Spring 的来龙去脉讲的很全。墙裂推荐这本书籍，如果你想看 Spring，作者很牛，资深架构师，很有幸和作者有过一次交流，当时因为自己的一篇博客  <a href="http://www.54tianzhisheng.cn/2017/03/27/Pyspider%E6%A1%86%E6%9E%B6%20%E2%80%94%E2%80%94%20Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E4%B9%8B%E7%88%AC%E5%8F%96%20V2EX%20%E7%BD%91%E7%AB%99%E5%B8%96%E5%AD%90/" target="_blank" rel="noopener">Pyspider框架 —— Python爬虫实战之爬取 V2EX 网站帖子</a>，竟然找到我想叫我去实习，可惜了，当时差点就跟着他混了。作者还有一本书  《Spring Boot 揭秘》。</p><p>14、《Spring 技术内幕》—— 深入解析 Spring 架构与设计原理     讲解 Spring 源码，深入了内部机制，个人觉得还是不错的。</p><p>15、Spring 官方的英文文档          这个别提了，很好，能看英文尽量看英文</p><p>16、《跟开涛学 Spring 3》  《跟开涛学 Spring MVC》  京东大神，膜</p><p>17、《看透springMvc源代码分析与实践》    算是把 Spring MVC 源码讲的很好的了</p><p>见我的笔记：</p><p><a href="http://www.54tianzhisheng.cn/2017/07/09/servlet/" target="_blank" rel="noopener">1、通过源码详解 Servlet</a></p><p><a href="http://www.54tianzhisheng.cn/2017/07/14/Spring-MVC01/" target="_blank" rel="noopener">2 、看透 Spring MVC 源代码分析与实践 —— 网站基础知识</a></p><p><a href="http://www.54tianzhisheng.cn/2017/07/14/Spring-MVC02/" target="_blank" rel="noopener">3 、看透 Spring MVC 源代码分析与实践 —— 俯视 Spring MVC</a></p><p><a href="http://www.54tianzhisheng.cn/2017/07/21/Spring-MVC03/" target="_blank" rel="noopener">4 、看透 Spring MVC 源代码分析与实践 —— Spring MVC 组件分析</a></p><p>18、《Spring Boot 实战》</p><p>19、Spring Boot 官方 Reference Guide        网上好多写 SpringBoot 的博客，几乎和这个差不多。</p><p>20、《JavaEE开发的颠覆者: Spring Boot实战》</p><p>21、MyBatis 当然是官方的文档最好了，而且还是中文的。</p><p>自己也写过几篇文章，帮助过很多人入门，传送门：</p><p>1、<a href="http://www.54tianzhisheng.cn/2017/03/28/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E4%B8%80" target="_blank" rel="noopener">通过项目逐步深入了解Mybatis（一）</a>/)</p><p>2、<a href="http://www.54tianzhisheng.cn/2017/03/28/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E4%BA%8C" target="_blank" rel="noopener">通过项目逐步深入了解Mybatis（二）</a>/)</p><p>3、<a href="http://www.54tianzhisheng.cn/2017/03/28/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E4%B8%89" target="_blank" rel="noopener">通过项目逐步深入了解Mybatis（三）</a>/)</p><p>4、<a href="http://www.54tianzhisheng.cn/2017/03/28/%E9%80%9A%E8%BF%87%E9%A1%B9%E7%9B%AE%E9%80%90%E6%AD%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Mybatis(%E5%9B%9B" target="_blank" rel="noopener">通过项目逐步深入了解Mybatis（四）</a>/)</p><p>22、《深入理解 Java 内存模型》—— 程晓明 著      我觉得每个 Java 程序员都应该了解下 Java 的内存模型，该书籍我看的是电子版的，不多，但是讲的却很清楚，把重排序、顺序一致性、Volatile、锁、final等写的很清楚。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>《鸟哥的Linux私房菜 基础学习篇(第三版)  》</p><p>鸟哥的Linux私房菜：服务器架设篇(第3版)    鸟哥的书</p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>《计算机网络第六版——谢希仁 编》</p><p>《计算机网络自顶向下方法》</p><h4 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h4><p>《代码揭秘：从C／C.的角度探秘计算机系统 —— 左飞》</p><p>《深入理解计算机系统》</p><p>《计算机科学导论_佛罗赞》</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>《高性能MySQL》</p><p>《Mysql技术内幕InnoDB存储引擎》</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>这门语言语法很简单，上手快，不过我目前好久没用了，都忘得差不多了。当时是看的廖雪峰的 Python 博客</p><p>自己也用 Python 做爬虫写过几篇博客，不过有些是在前人的基础上写的。感谢那些栽树的人！</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>Git   ： 廖雪峰的 Git 教程</p><p>IDEA：<a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial" target="_blank" rel="noopener">IntelliJ IDEA 简体中文专题教程</a></p><p>Maven：《Maven实战》</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>《如何高效学习-斯科特杨》   教你怎样高效学习的</p><p>《软技能：代码之外的生存指南》    程序员除了写代码，还得懂点其他的软技能。</p><p>《提问的智慧“中文版”》</p><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">《How-To-Ask-Questions-The-Smart-Way》</a>   作为程序员的你，一定要学会咋提问，不然别人都不想鸟你。</p><h3 id="优秀网站推荐"><a href="#优秀网站推荐" class="headerlink" title="优秀网站推荐"></a>优秀网站推荐</h3><p>1、GitHub     别和我说不知道</p><p>2、InfoQ        文章很不错</p><p>3、CSDN    经常看博客专家的博客，里面大牛很多，传送门：<a href="http://blog.csdn.net/tzs_1041218129" target="_blank" rel="noopener">zhisheng</a></p><p>4、知乎         多关注些大牛，看他们吹逼</p><p>5、掘金        自己也在上面写专栏，粉丝已经超过一万了，传送门 ：<a href="https://juejin.im/user/57510b82128fe10056ca70fc" target="_blank" rel="noopener">zhisheng</a></p><p>6、并发编程网    前面已经介绍</p><p>7、developerworks     上面的博客也很好</p><p>8、博客园        里面应该大牛也很多，不过自己没在上面写过博客</p><p>9、微信公众号    关注了很多人，有些人的文章确实很好，平时也经常看。</p><p>10、牛客网        刷笔试题不错的地方，里面大牛超多，怀念叶神和左神讲课的时候，还有很有爱的牛妹。</p><h3 id="优秀博客推荐"><a href="#优秀博客推荐" class="headerlink" title="优秀博客推荐"></a>优秀博客推荐</h3><p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰</a>  Git 和 Python 入门文章就是从他博客看的</p><p><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a></p><p><a href="https://coolshell.cn/" target="_blank" rel="noopener">酷壳-陈皓</a></p><p><a href="https://www.zhihu.com/people/rednaxelafx/answers" target="_blank" rel="noopener">RednaxelaFX</a>   R大，牛逼的不得了</p><p><a href="http://calvin1978.blogcn.com/" target="_blank" rel="noopener">江南白衣</a>      老司机</p><p><a href="http://stormzhang.com/" target="_blank" rel="noopener">stormzhang</a>     人称帅逼张，微信公众号写的不错</p><p><a href="http://lovestblog.cn/" target="_blank" rel="noopener">你假笨</a>    阿里搞 JVM 的，很厉害</p><p><a href="http://www.jianshu.com/u/90ab66c248e6" target="_blank" rel="noopener">占小狼</a></p><p><a href="http://www.bysocket.com/" target="_blank" rel="noopener">泥瓦匠BYSocket</a></p><p><a href="http://cuiqingcai.com/" target="_blank" rel="noopener">崔庆才</a>   写了好多 Python 爬虫相关的文章</p><p><a href="http://www.ityouknow.com/" target="_blank" rel="noopener">纯洁的微笑</a>    SpringBoot 系列不错，其他的文章自己看了感觉是自己喜欢的那种文笔</p><p><a href="http://blog.didispace.com/" target="_blank" rel="noopener">程序猿DD</a></p><p><a href="http://itmuch.com/" target="_blank" rel="noopener">周立</a></p><p><a href="http://vip.iocoder.cn/" target="_blank" rel="noopener">芋道源码的博客</a>     好多系列的源码分析</p><p><a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">zhisheng</a>       这个是我不要脸，竟然把自己博客地址的写上去了</p><h3 id="求职资料放送"><a href="#求职资料放送" class="headerlink" title="求职资料放送"></a>求职资料放送</h3><p>自己在准备找工作那段时间，系统的复习了下大学所学的知识，期间在网上参考了很多不错的博客，并收集下来了，个人觉得还是不错的，因为这是包含了自己的心血，所以一直没怎么送出来，只给过我的几个同学，还有就是一些学习视频和实战项目视频。借着这次征文的机会，我想送给那些有缘人，希望你或许是那种在求职道路上正在艰难走着的人；或许是大一大二的学弟学妹们却想好好学习，有个奋斗的目标，不堪在大学堕落的；或许是工作一两年后感觉基础还比较薄弱的。要资料的时候期望你能简单的介绍下自己，期望你！联系方式请看文章最下面。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>送一句话，<strong>越努力，越幸运，祝早日成为大神！</strong></p><p>这些地方可以找到我：</p><ul><li>blog:  <a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/</a></li><li>GitHub: <a href="https://github.com/zhisheng17" target="_blank" rel="noopener">https://github.com/zhisheng17</a></li><li>QQ 群：528776268</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/shanghai.jpeg-1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO 系列教程</title>
    <link href="http://yoursite.com/2018/01/21/Java%20NIO%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/21/Java NIO 系列教程/</id>
    <published>2018-01-21T10:29:55.000Z</published>
    <updated>2018-01-21T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。</p><p>Java NIO提供了与标准IO不同的IO工作方式：</p><ul><li><p><strong>Channels and Buffers（通道和缓冲区）</strong>：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</p></li><li><p><strong>Asynchronous IO（异步IO）</strong>：Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。</p></li><li><p><strong>Selectors（选择器）</strong>：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。</p></li></ul><a id="more"></a><p><strong>下面就来详细介绍Java NIO的相关知识。</strong></p><h3 id="1、Java-NIO-概述"><a href="#1、Java-NIO-概述" class="headerlink" title="1、Java NIO 概述"></a>1、Java NIO 概述</h3><p>Java NIO 由以下几个核心部分组成：</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>虽然 Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和 Selector 构成了核心的 API。其它组件，如 Pipe 和 FileLock，只不过是与三个核心组件共同使用的工具类。因此，在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。</p><h4 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h4><p>基本上，所有的 IO 在NIO 中都从一个 Channel 开始。Channel 有点象流。 数据可以从 Channel 读到 Buffer 中，也可以从 Buffer 写到 Channel 中。这里有个图示：</p><p><img src="http://ifeve.com/wp-content/uploads/2013/06/overview-channels-buffers1.png" alt=""></p><p>Channel 和 Buffer 有好几种类型。下面是 JAVA NIO 中的一些主要 Channel 的实现：</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>正如你所看到的，这些通道涵盖了 UDP 和 TCP 网络 IO，以及文件 IO。</p><p>与这些类一起的有一些有趣的接口，但为简单起见，我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。</p><p>以下是 Java NIO 里关键的 Buffer 实现：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>这些 Buffer 覆盖了你能通过 IO 发送的基本数据类型：byte, short, int, long, float, double 和 char。</p><p>Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件， 我也不打算在概述中说明。</p><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector 允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用 Selector 就会很方便。例如，在一个聊天服务器中。</p><p>这是在一个单线程中使用一个 Selector 处理3个 Channel 的图示：</p><p><img src="http://ifeve.com/wp-content/uploads/2013/06/overview-selectors.png" alt=""></p><p>要使用 Selector，得向 Selector 注册 Channel，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p><hr><h3 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h3><p>Java NIO 的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。</li></ul><p>正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：</p><p><img src="http://ifeve.com/wp-content/uploads/2013/06/overview-channels-buffers.png" alt=""></p><h4 id="Channel-的实现"><a href="#Channel-的实现" class="headerlink" title="Channel 的实现"></a>Channel 的实现</h4><p>这些是 Java NIO 中最重要的通道的实现：</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li><li>FileChannel 从文件中读写数据。</li></ul><p>DatagramChannel 能通过 UDP 读写网络中的数据。</p><p>SocketChannel 能通过 TCP 读写网络中的数据。</p><p>ServerSocketChannel 可以监听新进来的 TCP 连接，像 Web 服务器那样。对每一个新进来的连接都会创建一个 SocketChannel。</p><h4 id="基本的-Channel-示例"><a href="#基本的-Channel-示例" class="headerlink" title="基本的 Channel 示例"></a>基本的 Channel 示例</h4><p>下面是一个使用 FileChannel 读取数据到 Buffer 中的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">while(buf.hasRemaining())&#123;</span><br><span class="line">System.out.print((char) buf.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf.clear();</span><br><span class="line">bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure><p>注意 buf.flip() 的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据。下一节会深入讲解Buffer的更多细节。</p><hr><h3 id="3、Buffer"><a href="#3、Buffer" class="headerlink" title="3、Buffer"></a>3、Buffer</h3><p>Java NIO 中的 Buffer 用于和 NIO 通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。</p><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p><h4 id="Buffer-的基本用法"><a href="#Buffer-的基本用法" class="headerlink" title="Buffer 的基本用法"></a>Buffer 的基本用法</h4><p>使用 Buffer 读写数据一般遵循以下四个步骤：</p><ul><li>写入数据到 Buffer</li><li>调用 flip() 方法</li><li>从 Buffer 中读取数据</li><li>调用 clear() 方法或者 compact() 方法</li></ul><p>当向 buffer 写入数据时，buffer 会记录下写了多少数据。一旦要读取数据，需要先通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 buffer 的所有数据。</p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact() 方法只会清除已经读过的数据，任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p><p>下面是一个使用Buffer的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line">//create buffer with capacity of 48 bytes</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">int bytesRead = inChannel.read(buf); //read into buffer.</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line"></span><br><span class="line">  buf.flip();  //make buffer ready for read</span><br><span class="line"></span><br><span class="line">  while(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((char) buf.get()); // read 1 byte at a time</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.clear(); //make buffer ready for writing</span><br><span class="line">  bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure><h4 id="Buffer-的-capacity、-position-和-limit"><a href="#Buffer-的-capacity、-position-和-limit" class="headerlink" title="Buffer 的 capacity、 position 和 limit"></a>Buffer 的 capacity、 position 和 limit</h4><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p><p>为了理解 Buffer 的工作原理，需要熟悉它的三个属性：</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>position 和 limit 的含义取决于 Buffer 处在读模式还是写模式。不管 Buffer 处在什么模式，capacity 的含义总是一样的。</p><p>这里有一个关于 capacity，position 和 limit 在读写模式中的说明，详细的解释在插图后面。</p><p><img src="http://ifeve.com/wp-content/uploads/2013/06/buffers-modes.png" alt=""></p><p><strong>capacity</strong></p><p>作为一个内存块，Buffer 有一个固定的大小值，也叫“capacity”.你只能往里写 capacity 个byte、long，char 等类型。一旦 Buffer 满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p><p><strong>position</strong></p><p>当你写数据到 Buffer 中时，position 表示当前的位置。初始的 position 值为 0。当一个 byte、long 等数据写到 Buffer 后， position 会向前移动到下一个可插入数据的 Buffer 单元。position  最大可为 capacity – 1.</p><p>当读取数据时，也是从某个特定位置读。当将 Buffer 从写模式切换到读模式，position 会被重置为 0. 当从 Buffer 的 position 处读取数据时，position 向前移动到下一个可读的位置。</p><p><strong>limit</strong></p><p>在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。 写模式下，limit 等于Buffer 的 capacity。</p><p>当切换 Buffer 到读模式时， limit 表示你最多能读到多少数据。因此，当切换 Buffer 到读模式时，limit 会被设置成写模式下的 position 值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是 position）</p><h4 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h4><p>Java NIO 有以下Buffer类型</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>如你所见，这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float 或 double类型来操作缓冲区中的字节。</p><p>MappedByteBuffer 有些特别，在涉及它的专门章节中再讲。</p><h4 id="Buffer-的分配"><a href="#Buffer-的分配" class="headerlink" title="Buffer 的分配"></a>Buffer 的分配</h4><p>要想获得一个 Buffer 对象首先要进行分配。 每一个 Buffer 类都有一个 allocate 方法。下面是一个分配48字节 capacity 的 ByteBuffer 的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br></pre></td></tr></table></figure><p>这是分配一个可存储1024个字符的 CharBuffer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(1024);</span><br></pre></td></tr></table></figure><h4 id="向-Buffer-中写数据"><a href="#向-Buffer-中写数据" class="headerlink" title="向 Buffer 中写数据"></a>向 Buffer 中写数据</h4><p>写数据到 Buffer 有两种方式：</p><ul><li>从 Channel 写到 Buffer。</li><li>通过 Buffer 的 put() 方法写到 Buffer 里。</li></ul><p>从 Channel 写到 Buffer 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead = inChannel.read(buf); //read into buffer.</span><br></pre></td></tr></table></figure><p>通过put方法写Buffer的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(127);</span><br></pre></td></tr></table></figure><p>put 方法有很多版本，允许你以不同的方式把数据写入到 Buffer 中。例如， 写到一个指定的位置，或者把一个字节数组写入到 Buffer。 更多Buffer实现的细节参考JavaDoc。</p><p><strong>flip() 方法</strong></p><p>flip() 方法将 Buffer 从写模式切换到读模式。调用 flip() 方法会将 position 设回 0，并将 limit 设置成之前 position 的值。</p><p>换句话说，position 现在用于标记读的位置，limit 表示之前写进了多少个 byte、char等 —— 现在能读取多少个byte、char等。</p><h4 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h4><p>从Buffer中读取数据有两种方式：</p><ul><li>从Buffer读取数据到Channel。</li><li>使用get()方法从Buffer中读取数据。</li></ul><p>从Buffer读取数据到Channel的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//read from buffer into channel.</span><br><span class="line">int bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure><p>使用get()方法从Buffer中读取数据的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte aByte = buf.get();</span><br></pre></td></tr></table></figure><p>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。更多Buffer实现的细节参考JavaDoc。</p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><p>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p><h4 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear()与compact()方法"></a>clear()与compact()方法</h4><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。</p><p>如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p><p>如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p><p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p><h4 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h4><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line">//call buffer.get() a couple of times, e.g. during parsing.</span><br><span class="line">buffer.reset();  //set position back to mark.</span><br></pre></td></tr></table></figure><h4 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h4><p>可以使用equals()和compareTo()方法两个Buffer。</p><p><strong>equals()</strong></p><p>当满足下列条件时，表示两个Buffer相等：</p><ul><li>有相同的类型（byte、char、int等）。</li><li>Buffer中剩余的byte、char等的个数相等。</li><li>Buffer中所有剩余的byte、char等都相同。</li></ul><p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p><p><strong>compareTo()方法</strong></p><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p><ul><li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li><li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li></ul><p>（译注：剩余元素是从 position到limit之间的元素）</p><hr><h3 id="4、Scatter-Gather"><a href="#4、Scatter-Gather" class="headerlink" title="4、Scatter/Gather"></a>4、Scatter/Gather</h3><p>Java NIO 开始支持 scatter/gather，scatter/gather 用于描述从 Channel（译者注：Channel 在中文经常翻译为通道）中读取或者写入到 Channel 的操作。</p><p>分散（scatter）从 Channel 中读取是指在读操作时将读取的数据写入多个 buffer 中。因此，Channel 将从 Channel 中读取的数据“分散（scatter）”到多个Buffer中。</p><p>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。</p><p>scatter / gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p><h4 id="Scattering-Reads"><a href="#Scattering-Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h4><p>Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述：</p><p><img src="http://ifeve.com/wp-content/uploads/2013/06/scatter.png" alt=""></p><p>代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(128);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure><p>注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。</p><p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。</p><h4 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h4><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述：</p><p><img src="http://ifeve.com/wp-content/uploads/2013/06/gather.png" alt=""></p><p>代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(128);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">//write data into buffers</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p>buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。</p><hr><h3 id="5、通道之间的数据传输"><a href="#5、通道之间的数据传输" class="headerlink" title="5、通道之间的数据传输"></a>5、通道之间的数据传输</h3><p>在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel（译者注：channel中文常译作通道）传输到另外一个channel。</p><h4 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h4><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。</p><p>下面是一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line">long position = 0;</span><br><span class="line">long count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure><p>方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。</p><p>此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p><h4 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h4><p>transferTo()方法将数据从FileChannel传输到其他的channel中。</p><p>下面是一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line">long position = 0;</span><br><span class="line">long count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure><p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。</p><p>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p><hr><h3 id="6、Selector"><a href="#6、Selector" class="headerlink" title="6、Selector"></a>6、Selector</h3><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p><h4 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector?"></a>为什么使用Selector?</h4><p>仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。</p><p>但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。</p><p>下面是单线程使用一个Selector处理3个channel的示例图：</p><p><img src="http://ifeve.com/wp-content/uploads/2013/06/overview-selectors.png" alt=""></p><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>通过调用Selector.open()方法创建一个Selector，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h4 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h4><p>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(false);</span><br><span class="line">SelectionKey key = channel.register(selector,</span><br><span class="line">Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li>Connect</li><li>Accept</li><li>Read</li><li>Write</li></ul><p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p><p>这四种事件用SelectionKey的四个常量来表示：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>在下面还会继续提到interest集合。</p><h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p>在上一小节中，当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li></ul><p>附加的对象（可选）<br>下面我会描述这些属性。</p><h5 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h5><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line">boolean isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line">boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line">boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line">boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。</p><h5 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h5><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><h5 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h5><p>从SelectionKey访问Channel和Selector很简单。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><h4 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><h4 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h4><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>下面是select()方法：</p><ul><li>int select()</li><li>int select(long timeout)</li><li>int selectNow()</li></ul><p>select()阻塞到至少有一个通道在你注册的事件上就绪了。</p><p>select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。</p><p>selectNow()不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。</p><p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p><h5 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h5><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p><p>当像Selector注册Channel时，Channel.register()方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p><p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">while(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    if(key.isAcceptable()) &#123;</span><br><span class="line">        // a connection was accepted by a ServerSocketChannel.</span><br><span class="line">    &#125; else if (key.isConnectable()) &#123;</span><br><span class="line">        // a connection was established with a remote server.</span><br><span class="line">    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">        // a channel is ready for reading</span><br><span class="line">    &#125; else if (key.isWritable()) &#123;</span><br><span class="line">        // a channel is ready for writing</span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</p><p>注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。</p><h5 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h5><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p><p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p><h5 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h5><p>用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p><h4 id="完整的示例"><a href="#完整的示例" class="headerlink" title="完整的示例"></a>完整的示例</h4><p>这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(false);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">while(true) &#123;</span><br><span class="line">  int readyChannels = selector.select();</span><br><span class="line">  if(readyChannels == 0) continue;</span><br><span class="line">  Set selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">  while(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    if(key.isAcceptable()) &#123;</span><br><span class="line">        // a connection was accepted by a ServerSocketChannel.</span><br><span class="line">    &#125; else if (key.isConnectable()) &#123;</span><br><span class="line">        // a connection was established with a remote server.</span><br><span class="line">    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">        // a channel is ready for reading</span><br><span class="line">    &#125; else if (key.isWritable()) &#123;</span><br><span class="line">        // a channel is ready for writing</span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、FileChannel"><a href="#7、FileChannel" class="headerlink" title="7、FileChannel"></a>7、FileChannel</h3><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</p><p>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p><h4 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h4><p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure><h4 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h4><p>调用多个read()方法之一从FileChannel中读取数据。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。</p><p>然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p><h4 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h4><p>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p><h4 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h4><p>用完FileChannel后必须将其关闭。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure></p><h4 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h4><p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。</p><p>也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p><p>这里有两个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long pos = channel.position();</span><br><span class="line">channel.position(pos +123);</span><br></pre></td></tr></table></figure></p><p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。</p><p>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</p><h4 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h4><p>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long fileSize = channel.size();</span><br></pre></td></tr></table></figure></p><h4 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h4><p>可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(1024);</span><br></pre></td></tr></table></figure></p><p>这个例子截取文件的前1024个字节。</p><h4 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h4><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p><p>force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。</p><p>下面的例子同时将文件数据和元数据强制写到磁盘上：</p><p>查看源代码打印帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(true);</span><br></pre></td></tr></table></figure></p><hr><h3 id="8、SocketChannel"><a href="#8、SocketChannel" class="headerlink" title="8、SocketChannel"></a>8、SocketChannel</h3><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：</p><p>打开一个SocketChannel并连接到互联网上的某台服务器。<br>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</p><h4 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h4><p>下面是SocketChannel的打开方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));</span><br></pre></td></tr></table></figure><p>关闭 SocketChannel</p><p>当用完SocketChannel之后调用SocketChannel.close()关闭SocketChannel：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure><h4 id="从-SocketChannel-读取数据"><a href="#从-SocketChannel-读取数据" class="headerlink" title="从 SocketChannel 读取数据"></a>从 SocketChannel 读取数据</h4><p>要从SocketChannel中读取数据，调用一个read()的方法之一。以下是例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。</p><p>然后，调用SocketChannel.read()。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</p><h4 id="写入-SocketChannel"><a href="#写入-SocketChannel" class="headerlink" title="写入 SocketChannel"></a>写入 SocketChannel</h4><p>写数据到SocketChannel用的是SocketChannel.write()方法，该方法以一个Buffer作为参数。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。</p><h4 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h4><p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。</p><h5 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h5><p>如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));</span><br><span class="line"></span><br><span class="line">while(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    //wait, or do something else...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h5><p>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了，这里就不赘述了。</p><h5 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h5><p>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p><h4 id="非阻塞模式与选择器"><a href="#非阻塞模式与选择器" class="headerlink" title="非阻塞模式与选择器"></a>非阻塞模式与选择器</h4><p>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。Selector与SocketChannel的搭配使用会在后面详讲。</p><hr><h3 id="9、ServerSocketChannel"><a href="#9、ServerSocketChannel" class="headerlink" title="9、ServerSocketChannel"></a>9、ServerSocketChannel</h3><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在 java.nio.channels包中。</p><p>这里有个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(9999));</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    //do something with socketChannel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h4><p>通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel.如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure><h4 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h4><p>通过调用ServerSocketChannel.close() 方法来关闭ServerSocketChannel. 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure><h4 id="监听新进来的连接"><a href="#监听新进来的连接" class="headerlink" title="监听新进来的连接"></a>监听新进来的连接</h4><p>通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。</p><p>通常不会仅仅只监听一个连接,在while循环中调用 accept()方法. 如下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    //do something with socketChannel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然,也可以在while循环中使用除了true以外的其它退出准则。</p><h4 id="非阻塞模式-1"><a href="#非阻塞模式-1" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h4><p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(9999));</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    if(socketChannel != null)&#123;</span><br><span class="line">        //do something with socketChannel...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、Java-NIO-DatagramChannel"><a href="#10、Java-NIO-DatagramChannel" class="headerlink" title="10、Java NIO DatagramChannel"></a>10、Java NIO DatagramChannel</h3><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p><h4 id="打开-DatagramChannel"><a href="#打开-DatagramChannel" class="headerlink" title="打开 DatagramChannel"></a>打开 DatagramChannel</h4><p>下面是 DatagramChannel 的打开方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(new InetSocketAddress(9999));</span><br></pre></td></tr></table></figure><p>这个例子打开的 DatagramChannel可以在UDP端口9999上接收数据包。</p><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><p>通过receive()方法从DatagramChannel接收数据，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure><p>receive()方法会将接收到的数据包内容复制到指定的Buffer. 如果Buffer容不下收到的数据，多出的数据将被丢弃。</p><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p>通过send()方法从DatagramChannel发送数据，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">int bytesSent = channel.send(buf, new InetSocketAddress(&quot;jenkov.com&quot;, 80));</span><br></pre></td></tr></table></figure><p>这个例子发送一串字符到”jenkov.com”服务器的UDP端口80。 因为服务端并没有监控这个端口，所以什么也不会发生。也不会通知你发出的数据包是否已收到，因为UDP在数据传送方面没有任何保证。</p><h4 id="连接到特定的地址"><a href="#连接到特定的地址" class="headerlink" title="连接到特定的地址"></a>连接到特定的地址</h4><p>可以将DatagramChannel“连接”到网络中的特定地址的。由于UDP是无连接的，连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ，让其只能从特定地址收发数据。</p><p>这里有个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.connect(new InetSocketAddress(&quot;jenkov.com&quot;, 80));</span><br></pre></td></tr></table></figure><p>当连接后，也可以使用read()和write()方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead = channel.read(buf);</span><br><span class="line">int bytesWritten = channel.write(but);</span><br></pre></td></tr></table></figure><hr><h3 id="11、Pipe"><a href="#11、Pipe" class="headerlink" title="11、Pipe"></a>11、Pipe</h3><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p><p>这里是Pipe原理的图示：</p><p><img src="http://ifeve.com/wp-content/uploads/2013/06/pipe.bmp" alt=""></p><h4 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h4><p>通过Pipe.open()方法打开管道。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe pipe = Pipe.open();</span><br></pre></td></tr></table></figure><h4 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h4><p>要向管道写数据，需要访问sink通道。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br></pre></td></tr></table></figure><p>通过调用SinkChannel的write()方法，将数据写入SinkChannel,像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h4><p>从读取管道的数据，需要访问source通道，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure><p>调用source通道的read()方法来读取数据，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">int bytesRead = sourceChannel.read(buf);</span><br></pre></td></tr></table></figure><p>read()方法返回的int值会告诉我们多少字节被读进了缓冲区。</p><hr><h3 id="12、Java-NIO与IO的对比"><a href="#12、Java-NIO与IO的对比" class="headerlink" title="12、Java NIO与IO的对比"></a>12、Java NIO与IO的对比</h3><p>当学习了Java NIO和IO的API后，一个问题马上涌入脑海：</p><p>我应该何时使用IO，何时使用NIO呢？在本文中，我会尽量清晰地解析Java NIO和IO的差异、它们的使用场景，以及它们如何影响您的代码设计。</p><h4 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h4><p>下表总结了Java NIO和IO之间的主要差别，我会更详细地描述表中每部分的差异。</p><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>Stream oriented</td><td>Buffer oriented</td></tr><tr><td>Blocking IO</td><td>Non blocking IO</td></tr><tr><td>无</td><td>Selectors</td></tr></tbody></table><h4 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a>面向流与面向缓冲</h4><p>Java NIO和IO之间第一个<strong>最大</strong>的区别是，IO是面向流的，NIO是面向缓冲区的。</p><p> Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</p><p>Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><h4 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h4><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p><p>Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h4 id="选择器（Selectors）"><a href="#选择器（Selectors）" class="headerlink" title="选择器（Selectors）"></a>选择器（Selectors）</h4><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p><h4 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a>NIO和IO如何影响应用程序的设计</h4><p>无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面：</p><ul><li>对NIO或IO类的API调用。</li><li>数据处理。</li><li>用来处理数据的线程数。</li></ul><h4 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h4><p>当然，使用NIO的API调用时看起来与使用IO时有所不同，但这并不意外，因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理。</p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>使用纯粹的NIO设计相较IO设计，数据处理也受到影响。</p><p>在IO设计中，我们从InputStream或 Reader逐字节读取数据。假设你正在处理一基于行的文本数据流，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: Anna</span><br><span class="line">Age: 25</span><br><span class="line">Email: anna@mailserver.com</span><br><span class="line">Phone: 1234567890</span><br></pre></td></tr></table></figure><p>该文本行的流可以这样处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = … ; // get the InputStream from the client socket</span><br><span class="line">BufferedReader reader = new BufferedReader(new InputStreamReader(input));</span><br><span class="line"></span><br><span class="line">String nameLine   = reader.readLine();</span><br><span class="line">String ageLine    = reader.readLine();</span><br><span class="line">String emailLine  = reader.readLine();</span><br><span class="line">String phoneLine  = reader.readLine();</span><br></pre></td></tr></table></figure><p>请注意处理状态由程序执行多久决定。换句话说，一旦reader.readLine()方法返回，你就知道肯定文本行就已读完， readline()阻塞直到整行读完，这就是原因。你也知道此行包含名称；同样，第二个readline()调用返回的时候，你知道这行包含年龄等。 正如你可以看到，该处理程序仅在有新数据读入时运行，并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据（大多如此）。下图也说明了这条原则：</p><p><img src="http://dl2.iteye.com/upload/attachment/0096/5635/d816b6e7-0b89-3cbf-bc24-dc7e1bb971de.png" alt="从一个阻塞的流中读数据"></p><p>上图：从一个阻塞的流中读数据</p><p>而一个NIO的实现会有所不同，下面是一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">int bytesRead = inChannel.read(buffer);</span><br></pre></td></tr></table></figure><p>注意第二行，从通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。<br>假设第一次 read(buffer)调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，在此之前，对数据的任何处理毫无意义。</p><p>所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = inChannel.read(buffer);</span><br><span class="line">while(! bufferFull(bytesRead) ) &#123;</span><br><span class="line">bytesRead = inChannel.read(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bufferFull()方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。</p><p>bufferFull()方法扫描缓冲区，但必须保持在bufferFull（）方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。</p><p>如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”：</p><p><img src="http://dl2.iteye.com/upload/attachment/0096/5637/e97ec9e9-62d4-3375-80a6-d4238d6a0664.png" alt=""></p><p>上图：从一个通道里读数据，直到所有的数据都读到缓冲区里</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</p><p>如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。一个线程多个连接的设计方案如下图所示：</p><p><img src="http://dl2.iteye.com/upload/attachment/0096/5639/8c8b13c9-0d38-3599-99d3-e0d1aa90589d.png" alt=""></p><p>上图：单线程管理多个连接</p><p>如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：</p><p><img src="http://dl2.iteye.com/upload/attachment/0096/5641/72c44e71-8219-3989-a787-b67ced3c7ab1.png" alt=""></p><p>上图：一个典型的IO服务器设计：一个连接通过一个线程处理</p><hr><p>注明：文章转载自 <a href="http://ifeve.com/tag/nio/" target="_blank" rel="noopener"><strong>NIO|并发编程网</strong></a>，二次转载请务必注明原出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。&lt;/p&gt;
&lt;p&gt;Java NIO提供了与标准IO不同的IO工作方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Channels and Buffers（通道和缓冲区）&lt;/strong&gt;：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Asynchronous IO（异步IO）&lt;/strong&gt;：Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Selectors（选择器）&lt;/strong&gt;：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
</feed>

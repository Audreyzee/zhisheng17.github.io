<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhisheng的博客</title>
  
  <subtitle>坑要一个个填，路要一步步走！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-04T07:39:56.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhisheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小马哥 《Java 微服务实践 - Spring Cloud 系列》强烈推荐</title>
    <link href="http://yoursite.com/2018/03/04/springcloud-vedio/"/>
    <id>http://yoursite.com/2018/03/04/springcloud-vedio/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-03-04T07:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp0tsq2q8vj30dc07idg8.jpg" alt="u=1933229855,2353978820&amp;fm=27&amp;gp=0"></p><h3 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h3><p>Spring Cloud 系列课程致力于以实战的方式覆盖所有功能特性，结合小马哥十余年的学习方法和工作经验，体会作者设计意图。结合源码加深理解，最终达到形成系统性的知识和技术体系的目的。</p><a id="more"></a><h3 id="讲师介绍"><a href="#讲师介绍" class="headerlink" title="讲师介绍"></a>讲师介绍</h3><blockquote><p><strong>小马哥</strong>，一线互联网公司技术专家，十余年 Java EE 从业经验，架构师、微服务布道师。目前主要负责微服务技术实施、架构衍进、基础设施构建等。重点关注云计算、微服务以及软件架构等领域。通过 SUN Java（SCJP、SCWCD、SCBCD）以及 Oracle OCA 等的认证。</p></blockquote><h3 id="视频列表"><a href="#视频列表" class="headerlink" title="视频列表"></a>视频列表</h3><p>1、<a href="https://segmentfault.com/l/1500000011384570" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（一）云原生应用</a></p><p>2、<a href="https://segmentfault.com/l/1500000011385195" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（二）配置客户端</a></p><p>3、<a href="https://segmentfault.com/l/1500000011385904" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（三）配置服务器</a></p><p>4、<a href="https://segmentfault.com/l/1500000011386051" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（四）服务发现/注册</a></p><p>5、<a href="https://segmentfault.com/l/1500000011386082" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（五）高可用服务治理</a></p><p>6、<a href="https://segmentfault.com/l/1500000011386110" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（六）负载均衡</a></p><p>7、<a href="https://segmentfault.com/l/1500000011386180" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（七）Ribbon 源码</a></p><p>8、<a href="https://segmentfault.com/l/1500000011386237" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（八）服务短路</a></p><p>9、<a href="https://segmentfault.com/l/1500000011386273" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（九）Hystrix源码</a></p><p>10、<a href="https://segmentfault.com/l/1500000011386274" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十）服务调用</a></p><p>11、<a href="https://segmentfault.com/l/1500000011386451" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十一）服务网关</a></p><p>12、<a href="https://segmentfault.com/l/1500000011386642" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十二）消息驱动整合</a></p><p>13、<a href="https://segmentfault.com/l/1500000011386655" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十三）Binder实现</a></p><p>14、<a href="https://segmentfault.com/l/1500000011386685" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十四）消息总线</a></p><p>15、<a href="https://segmentfault.com/l/1500000011386721" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十五）分布式应用跟踪</a></p><p>16、<a href="https://segmentfault.com/l/1500000011386751" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十六）系列回顾</a></p><h3 id="购买链接"><a href="#购买链接" class="headerlink" title="购买链接"></a>购买链接</h3><p>你可以使用下面链接购买（有优惠的哦）</p><p><strong><a href="https://segmentfault.com/ls/1650000011386794?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011386794?r=bPrFW3</a></strong></p><p>或者你也可以扫描下面的二维码购买（同样也有优惠的哦）</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp0td2936xj308c0aujsd.jpg" alt="sc视频"></p><h3 id="课程评价"><a href="#课程评价" class="headerlink" title="课程评价"></a>课程评价</h3><blockquote><p>1、小马哥讲的很好，实践和原理一起结合讲，理解的很深刻。<br>期待小马哥的下一个高并发的系列讲座，还有那本万众瞩目的新书<br>2、<br>这些系列课程怎么说呢，就我来说其实学的不是知识，是学习方法。小马哥厉害的，给个赞。<br>3、满满的赞，社会套路太多，须加强学习，期待下期与小马哥相逢<br>4、基本是都是守者直播时间，跟着 Spring Boot 系列和 Spring Cloud 系列的课程，小马哥讲得很有启发性。讲一种技术的从哪里来，解决了什么问题，以及优缺点。讲源码又不仅限制于源码。总的来说值得花时间来学习和讨论的。值得推荐，五星好评。<br>5、可以的，解答问题很耐心。从你这学到了浏览JSR等之类的规范，在用一些框架的时候发现国外的，很多都实现了JSR，比如spring batch，而国内的话，个人觉得这方面稍微差了点，这方面我们还要努力，加油！</p></blockquote><p>以上评价摘自 segmentfault</p><h3 id="相关课程"><a href="#相关课程" class="headerlink" title="相关课程"></a>相关课程</h3><p><strong>Java 微服务实践 - Spring Boot 系列</strong></p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011063780?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011063780?r=bPrFW3</a></strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0td375okj308c0augml.jpg" alt="sb视频"></p><p>另外：还有这个 <strong>Java 微服务实践 - Spring Boot / Spring Cloud</strong>，算是两个的合集了，合买的话优惠更大。</p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011387052?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011387052?r=bPrFW3</a></strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp0td1fomnj308c0au75b.jpg" alt="sb-sc合集"></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1k9vd8j3076076mxo.jpg" alt="C6LG3mGa12"></p><p>建了个不错的微信群，如果有感兴趣的可以加我微信，然后拉你进群交流。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1jn6s4j30qi0z10x1.jpg" alt="1520091522031"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fp0tsq2q8vj30dc07idg8.jpg&quot; alt=&quot;u=1933229855,2353978820&amp;amp;fm=27&amp;amp;gp=0&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;视频内容&quot;&gt;&lt;a href=&quot;#视频内容&quot; class=&quot;headerlink&quot; title=&quot;视频内容&quot;&gt;&lt;/a&gt;视频内容&lt;/h3&gt;&lt;p&gt;Spring Cloud 系列课程致力于以实战的方式覆盖所有功能特性，结合小马哥十余年的学习方法和工作经验，体会作者设计意图。结合源码加深理解，最终达到形成系统性的知识和技术体系的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>小马哥 《Java 微服务实践 - Spring Boot 系列》强烈推荐</title>
    <link href="http://yoursite.com/2018/03/04/springboot-vedio/"/>
    <id>http://yoursite.com/2018/03/04/springboot-vedio/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-03-04T07:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp0ts4i1hfj30id08t3yn.jpg" alt="timg"></p><h3 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h3><p>Java 微服务实践 - Spring Boot 为系列讲座，二十节专题直播，时长高达50个小时，包括目前最流行技术，深入源码分析，授人以渔的方式，帮助初学者深入浅出地掌握，为高阶从业人员抛砖引玉。</p><a id="more"></a><h3 id="讲师介绍"><a href="#讲师介绍" class="headerlink" title="讲师介绍"></a>讲师介绍</h3><blockquote><p><strong>小马哥</strong>，一线互联网公司技术专家，十余年 Java EE 从业经验，架构师、微服务布道师。目前主要负责微服务技术实施、架构衍进、基础设施构建等。重点关注云计算、微服务以及软件架构等领域。通过 SUN Java（SCJP、SCWCD、SCBCD）以及 Oracle OCA 等的认证。</p></blockquote><h3 id="视频列表"><a href="#视频列表" class="headerlink" title="视频列表"></a>视频列表</h3><p>1、<a href="https://segmentfault.com/l/1500000009515571" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（一）初体验</a></p><p>2、<a href="https://segmentfault.com/l/1500000009659111" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（二） Web篇（上）</a></p><p>3、<a href="https://segmentfault.com/l/1500000009767025" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（三）Web篇（中）</a></p><p>4、<a href="https://segmentfault.com/l/1500000009830944" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（四）Web篇（下）</a></p><p>5、<a href="https://segmentfault.com/l/1500000009844304" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（五）嵌入式Web容器</a></p><p>6、<a href="https://segmentfault.com/l/1500000009904190" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（六）数据库 JDBC</a></p><p>7、<a href="https://segmentfault.com/l/1500000009952220" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（七）MyBatis</a></p><p>8、<a href="https://segmentfault.com/l/1500000009952527" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（八）JPA</a></p><p>9、<a href="https://segmentfault.com/l/1500000009957330" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（九）NoSQL</a></p><p>10、<a href="https://segmentfault.com/l/1500000009970812" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十）缓存</a></p><p>11、<a href="https://segmentfault.com/l/1500000009971600" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十一）消息</a></p><p>12、<a href="https://segmentfault.com/l/1500000009971716" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十二）验证</a></p><p>13、<a href="https://segmentfault.com/l/1500000009971764" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十三）WebSocket</a></p><p>14、<a href="https://segmentfault.com/l/1500000009978309" target="_blank" rel="noopener"> Java 微服务实践- Spring Boot 系列（十四）WebService</a></p><p>15、<a href="https://segmentfault.com/l/1500000009978481" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十五）安全</a></p><p>16、<a href="https://segmentfault.com/l/1500000009978585" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十六）日志</a></p><p>17、<a href="https://segmentfault.com/l/1500000009978661" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十七）监管</a></p><p>18、<a href="https://segmentfault.com/l/1500000009978729" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十八）配置</a></p><p>19、<a href="https://segmentfault.com/l/1500000009978826" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十九）测试</a></p><p>20、<a href="https://segmentfault.com/l/1500000009978904" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（二十）自定义启动器</a></p><h3 id="购买链接"><a href="#购买链接" class="headerlink" title="购买链接"></a>购买链接</h3><p>你可以使用下面链接购买（有优惠的哦）</p><p><strong><a href="https://segmentfault.com/ls/1650000011063780?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011063780?r=bPrFW3</a></strong></p><p>或者你也可以扫描下面的二维码购买（同样也有优惠的哦）</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t6idjt0j308c0augml.jpg" alt="sb视频"></p><h3 id="课程评价"><a href="#课程评价" class="headerlink" title="课程评价"></a>课程评价</h3><blockquote><p>1、小马哥讲的好详细，以前似是而非的东东，现在都懂了<br>2、学到了怎么使用，也学到了怎么自定义校验，知其然也知其所以然<br>3、6666 起飞了 websocket 之前看了写 这次更加深入和标准化 感谢小马哥带来的干货<br>4、深入浅出，思路清晰。<br>5、深入浅出啊。非常好，而且如果有问题，不管简单还是难的，都从不同的角度和层次来解答了。学到的东西非常多。谢谢。</p></blockquote><p>以上评价摘自 segmentfault</p><h3 id="相关课程"><a href="#相关课程" class="headerlink" title="相关课程"></a>相关课程</h3><p><strong>Java 微服务实践 - Spring Cloud 系列</strong></p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011386794?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011386794?r=bPrFW3</a></strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0tc1p3e1j308c0aujsd.jpg" alt="sc视频"></p><p>另外：还有这个 <strong>Java 微服务实践 - Spring Boot / Spring Cloud</strong>，算是两个的合集了，合买的话优惠更大。</p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011387052?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011387052?r=bPrFW3</a></strong></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp0tc1df8vj308c0au75b.jpg" alt="sb-sc合集"></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1k9vd8j3076076mxo.jpg" alt="C6LG3mGa12"></p><p>建了个不错的微信群，如果有感兴趣的可以加我微信，然后拉你进群交流。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1jn6s4j30qi0z10x1.jpg" alt="1520091522031"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fp0ts4i1hfj30id08t3yn.jpg&quot; alt=&quot;timg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;视频内容&quot;&gt;&lt;a href=&quot;#视频内容&quot; class=&quot;headerlink&quot; title=&quot;视频内容&quot;&gt;&lt;/a&gt;视频内容&lt;/h3&gt;&lt;p&gt;Java 微服务实践 - Spring Boot 为系列讲座，二十节专题直播，时长高达50个小时，包括目前最流行技术，深入源码分析，授人以渔的方式，帮助初学者深入浅出地掌握，为高阶从业人员抛砖引玉。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解 Java 内存模型》读书笔记</title>
    <link href="http://yoursite.com/2018/02/28/Java-Memory-Model/"/>
    <id>http://yoursite.com/2018/02/28/Java-Memory-Model/</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2018-03-01T15:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7l5mj64j31hc0zbh9n.jpg" alt="fairyland-canyon-1632749_1920"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>《深入理解 Java 内存模型》程晓明著，该书在以前看过一遍，现在学的东西越多，感觉那块越重要，于是又再细看一遍，于是便有了下面的读书笔记总结。全书页数虽不多，内容讲得挺深的。细看的话，也是挺花时间的，看完收获绝对挺大的。也建议 Java 开发者都去看看。里面主要有 Java 内存模型的基础、重排序、顺序一致性、Volatile 关键字、锁、final。本文参考书中内容。</p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p>如果你想查看这本书可以关注我的公众号: <strong>zhisheng</strong> ，然后里面回复关键字 <strong>JMM</strong> 可以查看我分享的百度云链接。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/</a></p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="并发编程的模型分类"><a href="#并发编程的模型分类" class="headerlink" title="并发编程的模型分类"></a>并发编程的模型分类</h4><p>在并发编程需要处理的两个关键问题是：<strong>线程之间如何通信</strong> 和 <strong>线程之间如何同步</strong>。</p><h5 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h5><p><strong>通信</strong> 是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<strong>共享内存</strong> 和 <strong>消息传递</strong>。</p><p>在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的<strong>公共状态</strong>来<strong>隐式</strong>进行通信。</p><p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的<strong>发送消息</strong>来<strong>显式</strong>进行通信。</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p><strong>同步</strong> 是指程序用于控制不同线程之间操作发生相对顺序的机制。</p><p>在<strong>共享内存</strong>的并发模型里，同步是<strong>显式</strong>进行的。程序员必须显式指定某个方法或某段代码需要在线程之间<strong>互斥执行</strong>。</p><p>在<strong>消息传递</strong>的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是<strong>隐式</strong>进行的。</p><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><h4 id="Java-内存模型的抽象"><a href="#Java-内存模型的抽象" class="headerlink" title="Java 内存模型的抽象"></a>Java 内存模型的抽象</h4><p>在 Java 中，所有实例域、静态域 和 数组元素存储在堆内存中，堆内存在线程之间共享。局部变量、方法定义参数 和 异常处理器参数 不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（JMM）控制。JMM 决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程与主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每一个线程都有一个自己私有的本地内存，本地内存中存储了该变量以读／写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。</p><p>JMM 抽象示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l9q3hsj30zi0rq41t.jpg" alt="jmm"></p><p>从上图来看，如果线程 A 和线程 B 要通信的话，要如下两个步骤：</p><p>1、线程 A 需要将本地内存 A 中的共享变量副本刷新到主内存去</p><p>2、线程 B 去主内存读取线程 A 之前已更新过的共享变量</p><p>步骤示意图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7lh7qm2j30wo0ocq58.jpg" alt="tongxin"></p><p>举个例子：</p><p>本地内存 A 和 B 有主内存共享变量 X 的副本。假设一开始时，这三个内存中 X 的值都是 0。线程 A 正执行时，把更新后的 X 值（假设为 1）临时存放在自己的本地内存 A 中。当线程 A 和 B 需要通信时，线程 A 首先会把自己本地内存 A 中修改后的 X 值刷新到主内存去，此时主内存中的 X 值变为了 1。随后，线程 B 到主内存中读取线程 A 更新后的共享变量 X 的值，此时线程 B 的本地内存的 X 值也变成了 1。</p><p>整体来看，这两个步骤实质上是线程 A 再向线程 B 发送消息，而这个通信过程必须经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。</p><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三类：</p><p>1、<strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><p>2、<strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><p>3、<strong>内存系统的重排序</strong>。由于处理器使用缓存和读／写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>从 Java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7l4iv44j313e07wmyw.jpg" alt="sort-again"></p><p>上面的这些重排序都可能导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h4 id="处理器重排序"><a href="#处理器重排序" class="headerlink" title="处理器重排序"></a>处理器重排序</h4><p>现代的处理器使用<strong>写缓冲区</strong>来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！</p><p>举个例子：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l6udu0j30uc0c8zls.jpg" alt="example1"></p><p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0。具体的原因如下图所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7lftsaxj30wg0mcwgz.jpg" alt="exam1-ans"></p><p>处理器 A 和 B 同时把共享变量写入在写缓冲区中（A1、B1），然后再从内存中读取另一个共享变量（A2、B2），最后才把自己写缓冲区中保存的脏数据刷新到内存中（A3、B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p><p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1 -&gt; A2，但内存操作实际发生的顺序却是：A2 -&gt; A1。此时，处理器 A 的内存操作顺序被重排序了。</p><p>这里的关键是，由于<strong>写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致</strong>。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。</p><h4 id="内存屏障指令"><a href="#内存屏障指令" class="headerlink" title="内存屏障指令"></a>内存屏障指令</h4><p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入<strong>内存屏障指令</strong>来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th style="text-align:center">指令示例</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td style="text-align:center">Load1; LoadLoad; Load2</td><td style="text-align:center">确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td style="text-align:center">Store1; StoreStore; Store2</td><td style="text-align:center">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td style="text-align:center">Load1; LoadStore; Store2</td><td style="text-align:center">确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td style="text-align:center">Store1; StoreLoad; Load2</td><td style="text-align:center">确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。<strong>StoreLoadBarriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令</strong>。</td></tr></tbody></table><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>JSR-133 内存模型使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果<strong>一个操作执行的结果需要对另一个操作可见</strong>，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p><p>与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器的解锁，happens-before 于随后对这个监视器的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果  A happens-before B，且 B happens-before C，那么 A happens-before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p><p>happens-before 与 JMM 的关系如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l7e9zij312s0titdo.jpg" alt="happens-before-jmm"></p><p>如上图所示，一个 happens-before 规则对应于一个或多个编译器和处理器重排序规则。</p><h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">代码示例</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">写后读</td><td style="text-align:center">a = 1;   b = a;</td><td style="text-align:center">写一个变量之后，再读这个位置。</td></tr><tr><td style="text-align:center">写后写</td><td style="text-align:center">a = 1;  a = 2;</td><td style="text-align:center">写一个变量之后，再写这个变量。</td></tr><tr><td style="text-align:center">读后写</td><td style="text-align:center">a = b;  b = 1;</td><td style="text-align:center">读一个变量之后，再写这个变量。</td></tr></tbody></table><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><h4 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h4><p>as-if-serial 语义的意思指：<strong>不管怎么重排序</strong>（编译器和处理器为了提高并行度），（单线程）<strong>程序的执行结果不能被改变</strong>。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p><p>为了遵守 as-if-serial 编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是如果操作之间没有数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;     //A</span><br><span class="line">double r  = 1.0;       //B</span><br><span class="line">double area = pi * r * r;     //C</span><br></pre></td></tr></table></figure><p>上面三个操作的数据依赖关系如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l7q6paj30fa0aoq33.jpg" alt="abc"></p><p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l97fx2j30zu0cwdh1.jpg" alt="2018-02-27_16-52-44"></p><p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens-before 的定义我们可以看出，JMM 同样遵从这一目标。</p><h4 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h4><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;<span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;<span class="comment">//3</span></span><br><span class="line">      <span class="keyword">int</span> i = a * a;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于操作 1 和 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。</p><p>1、当操作 1 和操作 2 重排序时，可能会产生什么效果？</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lcgkgej30tw0ki3zd.jpg" alt="sort12"></p><p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p><p>2、当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l4zjfkj30zy0owq4r.jpg" alt="sort34"></p><p>在程序中，操作 3 和操作 4 存在<strong>控制依赖关系</strong>。当代码中存在控制依赖性时，<strong>会影响指令序列执行的并行度</strong>。为此，编译器和处理器会采用<strong>猜测</strong>（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a * a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p><p>从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><h4 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h4><p>顺序一致性内存模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行。</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ul><p>顺序一致性内存模型为程序员提供的视图如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7l6dyuaj30sk0mumyg.jpg" alt="2018-02-27_17-55-09"></p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。从上面的示意图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。</p><p>举个例子：</p><p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1 -&gt; A2 -&gt; A3。B 线程也有三个操作，它们在程序中的顺序是：B1 -&gt; B2 -&gt; B3。</p><p>假设这两个线程使用监视器锁来正确同步：A 线程的三个操作执行后释放监视器锁，随后 B 线程获取同一个监视器锁。那么程序在顺序一致性模型中的执行效果将如下图所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7ldkj04j31440paaee.jpg" alt="2018-02-27_18-01-51"></p><p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lefk10j316c0nytd8.jpg" alt="2018-02-27_18-04-20"></p><p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1 -&gt; A1 -&gt; A2 -&gt; B2 -&gt; A3 -&gt; B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><p>但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p><h4 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h4><p>下面我们对前面的示例程序用锁来同步，看看正确同步的程序如何具有顺序一致性。</p><p>请看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;<span class="comment">//获取锁</span></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">  &#125;<span class="comment">//释放锁</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例代码中，假设 A 线程执行 write() 方法后，B 线程执行 reade() 方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7ld04ffj312s0tq432.jpg" alt="2018-02-27_22-01-59"></p><p>在顺序一致性模型中，所有操作完全按程序的顺序执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><p>从这里我们可以看到 JMM 在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p><h4 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h4><p>未同步程序在 JMM 中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有下面几个差异：</p><ol><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM  不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。</li><li><strong>JMM 不保证对 64 位的 long 型和 double 型变量的读/写操作具有原子性</strong>，而<strong>顺序一致性模型保证对所有的内存读/写操作都具有原子</strong> 。</li></ol><p>第三个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过<strong>总线事务</strong>来完成的。总线事务包括读事务和写事务。读事务从内存传送数据到处理器，写事务从处理器传递数据到内存，每个事务会读／写内存中一个或多个物理上连续的字。总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I／O 设备执行内存的读／写。</p><p>总线的工作机制：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7levu1fj30zm0rgmzu.jpg" alt="2018-02-27_22-53-53"></p><p>如上图所示，假设处理器 A、B、和 C  同时向总线发起总线事务，这时总线仲裁会对竞争作出裁决，假设总线在仲裁后判定处理器 A 在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A 的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D 向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p><p>总线的这些工作机制可以<strong>把所有处理器对内存的访问以串行化的方式来执行</strong>；<strong>在任意时间点，最多只能有一个处理器能访问内存</strong>。这个特性<strong>确保了单个总线事务之中的内存读/写操作具有原子性</strong>。</p><p>在一些 32 位的处理器上，如果要求对 64 位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的写操作拆分为两个 32 位的写操作来执行。这两个 32 位的写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的写将不具有原子性。</p><p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l88o2aj312i0l8jt0.jpg" alt="2018-02-27_23-06-59"></p><p>如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64 位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被分配到单个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B 将看到仅仅被处理器 A “写了一半“的无效值。</p><p>注意，在 JSR -133 之前的旧内存模型中，一个 64 位 long/ double 型变量的<strong>读/写</strong>操作可以被拆分为两个 32 位的读/写操作来执行。从 JSR -133 内存模型开始（即从JDK5开始），仅仅只允许把一个 64 位 long/ double 型变量的<strong>写</strong>操作拆分为两个 32 位的写操作来执行，<strong>任意的读操作在JSR -133中都必须具有原子性</strong>（即任意读操作必须要在单个读事务中执行）。</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h4 id="Volatile-特性"><a href="#Volatile-特性" class="headerlink" title="Volatile 特性"></a>Volatile 特性</h4><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> a = <span class="number">1L</span>; <span class="comment">// 使用 volatile 声明 64 位的 long 型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        a = l;                  <span class="comment">//单个 volatile 变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;               <span class="comment">//单个 volatile 变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncreament</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;                    <span class="comment">// 复合（多个） volatile 变量的读 /写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">1L</span>; <span class="comment">// 64 位的 long 型普通变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;<span class="comment">//对单个普通变量的写用同一个锁同步</span></span><br><span class="line">        a = l;                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="comment">//对单个普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> a;           </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncreament</span><span class="params">()</span> </span>&#123;<span class="comment">//普通方法调用</span></span><br><span class="line">      <span class="keyword">long</span> temp = get();<span class="comment">//调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>;<span class="comment">//普通写操作</span></span><br><span class="line">      set(temp);<span class="comment">//调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面示例程序所示，对一个 volatile 变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个锁来同步，它们之间的执行效果相同。</p><p>锁的 happens-before 规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着<strong>对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入</strong>。</p><p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile变量，对该变量的读写就将具有原子性。<strong>如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性</strong>。</p><p>简而言之，volatile 变量自身具有下列特性：</p><ul><li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li><li>原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li></ul><h4 id="volatile-写-读的内存定义"><a href="#volatile-写-读的内存定义" class="headerlink" title="volatile 写-读的内存定义"></a>volatile 写-读的内存定义</h4><ul><li>当<strong>写</strong>一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li><li>当<strong>读</strong>一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ul><p>假设上面的程序 flag 变量用 volatile 修饰</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7lak6kvj30xc0qc76l.jpg" alt="2018-02-28_10-13-39"></p><h4 id="volatile-内存语义的实现"><a href="#volatile-内存语义的实现" class="headerlink" title="volatile 内存语义的实现"></a>volatile 内存语义的实现</h4><p>下面是 JMM 针对编译器制定的 volatile 重排序规则表：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lg83wdj313u0ckmz8.jpg" alt="2018-02-28_10-26-43"></p><p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>下面是基于保守策略的 JMM 内存屏障插入策略：</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>下面是保守策略下，volatile 写操作 插入内存屏障后生成的指令序列示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7la65xnj31100lc76r.jpg" alt="2018-02-28_10-31-14"></p><p>下面是在保守策略下，volatile 读操作 插入内存屏障后生成的指令序列示意图：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fow7l35uyuj310w0myju1.jpg" alt="2018-02-28_10-38-12"></p><p>上述 volatile 写操作和 volatile 读操作的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h4><p>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</p><p>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。</p><h4 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h4><p>借助 ReentrantLock 来讲解，PS： 后面专门讲下这块（ReentrantLock、Synchronized、公平锁、非公平锁、AQS等），可以看看大明哥的博客：<a href="">http://cmsblogs.com/?p=2210</a></p><h4 id="concurrent-包的实现"><a href="#concurrent-包的实现" class="headerlink" title="concurrent 包的实现"></a>concurrent 包的实现</h4><p>如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为 volatile；</li><li>然后，使用 CAS 的原子条件更新来实现线程之间的同步；</li><li>同时，配合以 volatile 的读/写和 CAS 所具有的 volatile 读和写的内存语义来实现线程之间的通信。</li></ol><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而 concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l42rbpj31160qa77a.jpg" alt="2018-02-28_14-58-32"></p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p><ol><li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li></ol><h4 id="写-final-域的重排序规则"><a href="#写-final-域的重排序规则" class="headerlink" title="写 final 域的重排序规则"></a>写 final 域的重排序规则</h4><p>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p><ul><li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li><li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li></ul><h4 id="读-final-域的重排序规则"><a href="#读-final-域的重排序规则" class="headerlink" title="读 final 域的重排序规则"></a>读 final 域的重排序规则</h4><p>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</p><h4 id="final-域是引用类型"><a href="#final-域是引用类型" class="headerlink" title="final 域是引用类型"></a>final 域是引用类型</h4><p>对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p><p>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="JMM，处理器内存模型与顺序一致性内存模型之间的关系"><a href="#JMM，处理器内存模型与顺序一致性内存模型之间的关系" class="headerlink" title="JMM，处理器内存模型与顺序一致性内存模型之间的关系"></a>JMM，处理器内存模型与顺序一致性内存模型之间的关系</h4><p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l8rgjej30ys0r6n05.jpg" alt="2018-02-28_15-34-39"></p><h4 id="JMM-的设计示意图"><a href="#JMM-的设计示意图" class="headerlink" title="JMM 的设计示意图"></a>JMM 的设计示意图</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7lb5c5kj310y0z4q7w.jpg" alt="jmm-"></p><h4 id="JMM-的内存可见性保证"><a href="#JMM-的内存可见性保证" class="headerlink" title="JMM 的内存可见性保证"></a>JMM 的内存可见性保证</h4><p>Java 程序的内存可见性保证按程序类型可以分为下列三类：</p><p>1.单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p><p>2.正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p><p>3.未同步/未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</p><p>下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lgmupij311m0sqtcg.jpg" alt="2018-02-28_15-43-10"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fow7l5mj64j31hc0zbh9n.jpg&quot; alt=&quot;fairyland-canyon-1632749_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;《深入理解 Java 内存模型》程晓明著，该书在以前看过一遍，现在学的东西越多，感觉那块越重要，于是又再细看一遍，于是便有了下面的读书笔记总结。全书页数虽不多，内容讲得挺深的。细看的话，也是挺花时间的，看完收获绝对挺大的。也建议 Java 开发者都去看看。里面主要有 Java 内存模型的基础、重排序、顺序一致性、Volatile 关键字、锁、final。本文参考书中内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JMM" scheme="http://yoursite.com/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 简单的消息示例</title>
    <link href="http://yoursite.com/2018/02/07/rocketmq-example/"/>
    <id>http://yoursite.com/2018/02/07/rocketmq-example/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-02-06T15:22:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fo6h2isc2lj31hc0vhaqg.jpg" alt="father-and-son-2258681_1920"></p><p>使用 RocketMQ 以三种方式发送消息：可靠的同步，可靠的异步和单向传输。<br><a id="more"></a></p><h3 id="可靠的同步传输"><a href="#可靠的同步传输" class="headerlink" title="可靠的同步传输"></a>可靠的同步传输</h3><p>应用：可靠的同步传输广泛应用于重要通知消息，短信通知，短信营销系统等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可靠的异步传输"><a href="#可靠的异步传输" class="headerlink" title="可靠的异步传输"></a>可靠的异步传输</h3><p>应用：异步传输一般用于响应时间敏感的业务场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向传输"><a href="#单向传输" class="headerlink" title="单向传输"></a>单向传输</h3><p>应用：单向传输用于需要中等可靠性的情况，例如日志收集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是 RocketMQ 的三种发送消息的方式。</p><p>转发请注明地址：<a href="http://www.54tianzhisheng.cn/2018/02/07/rocketmq-example/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/07/rocketmq-example/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fo6h2isc2lj31hc0vhaqg.jpg&quot; alt=&quot;father-and-son-2258681_1920&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 RocketMQ 以三种方式发送消息：可靠的同步，可靠的异步和单向传输。&lt;br&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot RocketMQ 整合使用和监控</title>
    <link href="http://yoursite.com/2018/02/07/SpringBoot-RocketMQ/"/>
    <id>http://yoursite.com/2018/02/07/SpringBoot-RocketMQ/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-02-11T08:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqfuapwj31hc0zhtro.jpg" alt="photoshop-2845779_1920"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>通过前面两篇文章可以简单的了解 RocketMQ 和 安装 RocketMQ ，今天就将 SpringBoot 和 RocketMQ 整合起来使用。<br><a id="more"></a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">SpringBoot ActiveMQ 整合使用</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合进阶版</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">RocketMQ 初探</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/" target="_blank" rel="noopener">RocketMQ 安装及快速入门</a></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/</a></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在 IDEA 创建一个 SpringBoot 项目，项目结构如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vq6ufg3j30pe0yoacc.jpg" alt="rocketmq01"></p><h4 id="pom-文件"><a href="#pom-文件" class="headerlink" title="pom 文件"></a>pom 文件</h4><p>引入 RocketMQ 的一些相关依赖，最后的 pom 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>rocketmq<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot RocketMQ<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>application.properties 中如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 消费者的组名</span><br><span class="line">apache.rocketmq.consumer.PushConsumer=PushConsumer</span><br><span class="line"># 生产者的组名</span><br><span class="line">apache.rocketmq.producer.producerGroup=Producer</span><br><span class="line"># NameServer地址</span><br><span class="line">apache.rocketmq.namesrvAddr=localhost:9876</span><br></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rocketmq.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.producer.producerGroup&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String producerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产者的组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(producerGroup);</span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        producer.setNamesrvAddr(namesrvAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Producer对象在使用之前必须要调用start初始化，初始化一次即可</span></span><br><span class="line"><span class="comment">             * 注意：切记不可以在每次发送消息时，都调用start方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            producer.start();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//创建一个消息实例，包含 topic、tag 和 消息体</span></span><br><span class="line">             <span class="comment">//如下：topic 为 "TopicTest"，tag 为 "push"</span></span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, <span class="string">"push"</span>, <span class="string">"发送消息----zhisheng-----"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">            StopWatch stop = <span class="keyword">new</span> StopWatch();</span><br><span class="line">            stop.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                SendResult result = producer.send(message);</span><br><span class="line">                System.out.println(<span class="string">"发送响应：MsgId:"</span> + result.getMsgId() + <span class="string">"，发送状态:"</span> + result.getSendStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            stop.stop();</span><br><span class="line">            System.out.println(<span class="string">"----------------发送一万条消息耗时："</span> + stop.getTotalTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rocketmq.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.consumer.PushConsumer&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQPushConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//消费者的组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//订阅PushTopic下Tag为push的消息</span></span><br><span class="line">            consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"push"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line">            <span class="comment">//如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line">            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">            consumer.registerMessageListener((MessageListenerConcurrently) (list, context) -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt messageExt : list) &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"messageExt: "</span> + messageExt);<span class="comment">//输出消息内容</span></span><br><span class="line"></span><br><span class="line">                        String messageBody = <span class="keyword">new</span> String(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"消费响应：msgId : "</span> + messageExt.getMsgId() + <span class="string">",  msgBody : "</span> + messageBody);<span class="comment">//输出消息内容</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER; <span class="comment">//稍后再试</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS; <span class="comment">//消费成功</span></span><br><span class="line">            &#125;);</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rocketmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketmqApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(RocketmqApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>代码已经都写好了，接下来我们需要将与 RocketMQ 有关的启动起来。</p><h4 id="启动-Name-Server"><a href="#启动-Name-Server" class="headerlink" title="启动 Name Server"></a>启动 Name Server</h4><p>在前面文章中已经写过怎么启动，<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/#%E5%90%AF%E5%8A%A8-NameServer" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/#%E5%90%AF%E5%8A%A8-NameServer</a></p><p>进入到目录 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd distribution/target/apache-rocketmq</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log //通过日志查看是否启动成功</span><br></pre></td></tr></table></figure><h4 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log//通过日志查看是否启动成功</span><br></pre></td></tr></table></figure><p>然后运行启动类，运行效果如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vqiq0jvj31kw0x1x6m.jpg" alt="2018-02-07_22-21-14"></p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>RocketMQ有一个对其扩展的开源项目 ocketmq-console ，如今也提交给了 Apache ，地址在：<a href="">https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console</a> ，官方也给出了其支持的功能的中文文档：<a href="">https://github.com/apache/rocketmq-externals/blob/master/rocketmq-console/doc/1_0_0/UserGuide_CN.md</a> ， 那么该如何安装？</p><h4 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h4><p>1、获取 Docker 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><p>2、运行，注意将你自己的 NameServer 地址替换下面的 127.0.0.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; -p 8080:8080 -t styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><h4 id="非-Docker-安装"><a href="#非-Docker-安装" class="headerlink" title="非 Docker 安装"></a>非 Docker 安装</h4><p>我们 git clone 一份代码到本地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/rocketmq-externals.git</span><br><span class="line"></span><br><span class="line">cd rocketmq-externals/rocketmq-console/</span><br></pre></td></tr></table></figure><p>需要 jdk 1.7 以上。  执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br><span class="line"></span><br><span class="line">java -jar target/rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、如果你下载依赖缓慢，你可以重新设置 maven 的 mirror 为阿里云的镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、如果你使用的 RocketMQ 版本小于 3.5.8，如果您使用 rocketmq &lt; 3.5.8，请在启动 rocketmq-console-ng 时添加 <code>-Dcom.rocketmq.sendMessageWithVIPChannel = false</code>（或者您可以在 ops 页面中更改它）</p><p>3、更改 resource / application.properties 中的 rocketmq.config.namesrvAddr（或者可以在ops页面中更改它）</p><h3 id="错误解决方法"><a href="#错误解决方法" class="headerlink" title="错误解决方法"></a>错误解决方法</h3><p>1、Docker 启动项目报错</p><p><code>org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;null&gt; failed</code></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vqhpxcrj31kw0qc4ln.jpg" alt="2018-02-07_23-28-51"></p><p>将 Docker 启动命令改成如下以后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e &quot;JAVA_OPTS=-Drocketmq.config.namesrvAddr=127.0.0.1:9876 -Drocketmq.config.isVIPChannel=false&quot; -p 8080:8080 -t styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><p>报错信息改变了，新的报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR op=global_exception_handler_print_error</span><br><span class="line"></span><br><span class="line">org.apache.rocketmq.console.exception.ServiceException: This date have&apos;t data!</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fo8vql4zvij31kw0vz1kx.jpg" alt="2018-02-08_00-23-15"></p><p>看到网上有人也遇到这个问题，他们都通过自己的方式解决了，但是方法我都试了，不适合我。不得不说，阿里，你能再用心点吗？既然把 RocketMQ 捐给 Apache 了，这些文档啥的都必须更新啊，不要还滞后着呢，不然少不了被吐槽！</p><p> 搞了很久这种方法没成功，暂时放弃！mmp</p><p>2、非 Docker 安装，只好把源码编译打包了。</p><p>1) 注意需要修改如下图中的配置：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vq7xv71j31kw0nktmi.jpg" alt="2018-02-08_10-26-03"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.config.namesrvAddr=localhost:9876//注意替换你自己的ip</span><br><span class="line"></span><br><span class="line">#如果你 rocketmq 版本小于 3.5.8 才需设置 `rocketmq.config.isVIPChannel` 为 false，默认是 true, 这个可以在源码中可以看到的</span><br><span class="line">rocketmq.config.isVIPChannel=</span><br></pre></td></tr></table></figure><p>2) 执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>编译成功：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqk3r9ej31kw0tsh2z.jpg" alt="2018-02-08_10-41-35"></p><p>可以看到已经打好了 jar 包：</p><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure><p>成功，不报错了，开心😄，访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqdzp1kj31kw0vyqap.jpg" alt="2018-02-08_11-06-26"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqlthfqj31e20liwgz.jpg" alt="2018-02-08_11-08-01"></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vqgsrl8j31kw09pjur.jpg" alt="2018-02-08_11-09-16"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fo8vqaazsyj31kw0p8qce.jpg" alt="2018-02-08_11-09-31"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqbosxvj31kw0vowp0.jpg" alt="2018-02-08_11-09-47"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqet48yj31kw0bsmzk.jpg" alt="2018-02-08_11-10-03"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vq8q3v9j31kw0dfn0m.jpg" alt="2018-02-08_11-10-22"></p><p>整个监控大概就是这些了。</p><p>然后我运行之前的 SpringBoot 整合项目，查看监控信息如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqcyj00j31kw0up46m.jpg" alt="2018-02-08_11-22-11"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整篇文章讲述了 SpringBoot 与 RocketMQ 整合和 RocketMQ 监控平台的搭建。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>1、<a href="">http://www.ymq.io/2018/02/02/spring-boot-rocketmq-example/#%E6%96%B0%E5%8A%A0%E9%A1%B9%E7%9B%AE</a></p><p>2、GitHub 官方 README</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqfuapwj31hc0zhtro.jpg&quot; alt=&quot;photoshop-2845779_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;通过前面两篇文章可以简单的了解 RocketMQ 和 安装 RocketMQ ，今天就将 SpringBoot 和 RocketMQ 整合起来使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 安装及快速入门</title>
    <link href="http://yoursite.com/2018/02/06/RocketMQ-install/"/>
    <id>http://yoursite.com/2018/02/06/RocketMQ-install/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-02-07T14:01:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo5pxy3w8oj31hc0u0b29.jpg" alt="tree-3097419_1920"></p><p>如果你对 RocketMQ 还没了解，建议先看下上一篇文章：<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">RocketMQ 初探</a></p><a id="more"></a><h3 id="安装条件"><a href="#安装条件" class="headerlink" title="安装条件"></a>安装条件</h3><ol><li>64位操作系统，建议使用 Linux / Unix / Mac;</li><li>64位JDK 1.8+;</li><li>Maven 3.2.x</li></ol><h3 id="下载和构建"><a href="#下载和构建" class="headerlink" title="下载和构建"></a>下载和构建</h3><p>从 <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-source-release.zip" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-source-release.zip</a> 下载 4.2.0 的源码版本，执行以下命令来解压4.2.0源码版本并构建二进制文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unzip rocketmq-all-4.2.0-source-release.zip</span><br><span class="line"></span><br><span class="line">cd rocketmq-all-4.2.0/</span><br><span class="line"></span><br><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br></pre></td></tr></table></figure><p>构建成功如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo7ukit9wbj31kw14o7l8.jpg" alt="2018-02-07_14-04-25"></p><p>进入到目录 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd distribution/target/apache-rocketmq</span><br></pre></td></tr></table></figure><h3 id="启动-NameServer"><a href="#启动-NameServer" class="headerlink" title="启动 NameServer"></a>启动 NameServer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><p>结果如下就代表启动成功了：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fo5pxzbap2j31kw0h413p.jpg" alt="rocketmq01"></p><h3 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><p>结果如下就代表启动成功了：从日志中可以看到 broker 注册到了 nameserver 上了（localhost:9876）</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo5pxt2wavj31kw0jeqi0.jpg" alt="rocketmq02"></p><h3 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h3><p>在发送/接收消息之前，我们需要告诉客户名称服务器的位置。RocketMQ 提供了多种方法来实现这一点。为了简单起见，我们使用环境变量<code>NAMESRV_ADDR</code></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo5py0e7lgj31kw0d47j2.jpg" alt="rocketmq03"></p><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo5pxwox08j31kw0rib29.jpg" alt="rocketmq04"></p><h3 id="关闭服务器"><a href="#关闭服务器" class="headerlink" title="关闭服务器"></a>关闭服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqshutdown broker//停止 broker</span><br><span class="line"></span><br><span class="line">sh bin/mqshutdown namesrv//停止 nameserver</span><br></pre></td></tr></table></figure><p> 关闭成功后如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fo5pxsgyywj31kw0b5dov.jpg" alt="rocketmq05"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>上面几个启动和关闭 name server 和 broker 的就不再说了，</p><ul><li>查看集群情况  <code>./mqadmin clusterList -n 127.0.0.1:9876</code></li><li>查看 broker 状态   <code>./mqadmin brokerStatus -n 127.0.0.1:9876 -b 172.20.1.138:10911</code>   (注意换成你的 broker 地址)</li><li>查看 topic 列表    <code>./mqadmin topicList -n 127.0.0.1:9876</code></li><li>查看 topic 状态    <code>./mqadmin topicStatus -n 127.0.0.1:9876 -t  MyTopic</code>  (换成你想查询的 topic)</li><li>查看 topic 路由    <code>./mqadmin topicRoute  -n 127.0.0.1:9876 -t  MyTopic</code></li></ul><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是 RocketMQ 的安装及快速入门案例。</p><p>转发请注明地址：<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fo5pxy3w8oj31hc0u0b29.jpg&quot; alt=&quot;tree-3097419_1920&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你对 RocketMQ 还没了解，建议先看下上一篇文章：&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RocketMQ 初探&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 初探</title>
    <link href="http://yoursite.com/2018/02/05/RocketMQ/"/>
    <id>http://yoursite.com/2018/02/05/RocketMQ/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-02-05T09:58:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbrj17mj31hc0zj7hb.jpg" alt="gooafoss-1840758_1920"></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>RocketMQ 是阿里开源的消息中间件，前不久捐献给了 Apache 。正如<a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">官网</a>介绍如下：它是一个开源的分布式消息传递和流式数据平台。</p><a id="more"></a><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbtu01lj31kw0jbjzw.jpg" alt="rocketmq01"></p><p>特点如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo4vbvbgisj31kw0yw7c9.jpg" alt="rocketmq02"></p><h3 id="产品发展历史"><a href="#产品发展历史" class="headerlink" title="产品发展历史"></a>产品发展历史</h3><p>大约经历了三个主要版本迭代</p><p><strong>一、Metaq（Metamorphosis）1.x</strong></p><p>由开源社区killme2008维护，开源社区非常活跃。</p><p><strong>二、Metaq 2.x</strong></p><p>于2012年10月份上线，在淘宝内部被广泛使用。</p><p><strong>三、RocketMQ 3.x</strong></p><p>基于公司内部开源共建原则，RocketMQ 项目只维护核心功能，且去除了所有其他运行时依赖，核心功能最简化。每个 BU 的个性化需求都在 RocketMQ 项目之上进行深度定制。RocketMQ 向其他 BU 提供的仅仅是 Jar 包，例如要定制一个 Broker，那么只需要依赖 rocketmq-broker 这个 jar 包即可，可通过 API 进行交互，如果定制 client，则依赖 rocketmq-client 这个 jar 包，对其提供的 api 进行再封装。</p><p>在 RocketMQ 项目基础上衍生的项目如下</p><ul><li><p>com.taobao.metaq v3.0 = RocketMQ + 淘宝个性化需求</p><p>为<strong>淘宝</strong>应用提供消息服务</p></li><li><p>com.alipay.zpullmsg v1.0 =RocketMQ + 支付宝个性化需求</p><p>为<strong>支付宝</strong>应用提供消息服务</p></li><li><p>com.alibaba.commonmq v1.0 = Notify + RocketMQ + B2B个性化需求</p><p>为 <strong>B2B</strong> 应用提供消息服务</p></li></ul><p><strong>四、RocketMQ 3.x</strong></p><p>目前它的最新版本是 4.2 版本。</p><h3 id="概念专业术语"><a href="#概念专业术语" class="headerlink" title="概念专业术语"></a>概念专业术语</h3><p><strong>Producer</strong></p><p>消息生产者，负责产生消息，一般由业务系统负责产生消息。</p><p><strong>Consumer</strong></p><p>消息消费者，负责消费消息，一般是后台系统负责异步消费。</p><p><strong>Push Consumer</strong></p><p>Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法。</p><p><strong>Pull Consumer</strong></p><p>Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。</p><p><strong>Producer Group</strong></p><p>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</p><p><strong>Consumer Group</strong></p><p>一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</p><p><strong>Broker</strong></p><p>消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbs0dn7j30r30c23zl.jpg" alt="rmq-basic-arc"></p><p>从这架构图中可以看到它主要由四部分组成：Producer（生产者）、NameServer、Broker、Consumer（消费者）。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者支持分布式部署。分布式生产者通过多种负载均衡模式向 Broker 集群发送消息。发送过程支持快速失败并具有低延迟。</p><h4 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h4><p>它提供轻量级服务发现和路由，每个 Name Server 记录完整的路由信息，提供相应的读写服务，支持快速存储扩展。主要包括两个功能：</p><ul><li>代理管理，  <strong>NameServer</strong> 接受来自 Broker 集群的注册，并提供检测代理是否存在的心跳机制。</li><li>路由管理，每个 NameServer 将保存有关代理群集的全部路由信息以及客户端查询的<strong>队列</strong>信息。</li></ul><p>我们知道，RocketMQ客户端（生产者/消费者）将从NameServer查询队列路由信息，但客户端如何找到NameServer地址？</p><p>将NameServer地址列表提供给客户端有四种方法：</p><ul><li>编程方式，就像<code>producer.setNamesrvAddr(&quot;ip:port&quot;)</code>。</li><li>Java选项，使用<code>rocketmq.namesrv.addr</code>。</li><li>环境变量，使用<code>NAMESRV_ADDR</code>。</li><li>HTTP 端点。</li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>Broker 通过提供轻量级的 Topic 和 Queue 机制来照顾消息存储。它们支持 Push 和 Pull 模式，包含容错机制（2个拷贝或者3个拷贝），并且提供了强大的峰值填充和以原始时间顺序累计数千亿条消息的能力。此外，broker 还提供灾难恢复，丰富的指标统计数据和警报机制，而传统的消息传递系统都缺乏这些机制。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fo4vbpoxtej30r30dsdgs.jpg" alt="rmq-basic-component"></p><p>如上图：Broker 服务器重要的子模块：</p><ul><li>远程处理模块是 broker 的入口，处理来自客户的请求。</li><li>Client manager，管理客户（生产者/消费者）并维护消费者的主题订阅。</li><li>Store Service，提供简单的 API 来存储或查询物理磁盘中的消息。</li><li>HA 服务，提供主代理和从代理之间的数据同步功能。</li><li>索引服务，通过指定键为消息建立索引，并提供快速的消息查询。</li></ul><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>消费者也支持 Push 和 Pull 模型中的分布式部署。它还支持群集消费和消息广播。它提供了实时的消息订阅机制，可以满足大多数消费者的需求。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是对 RocketMQ 的简单点了解，参考了官网介绍。</p><p>转载请注明地址：<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbrj17mj31hc0zj7hb.jpg&quot; alt=&quot;gooafoss-1840758_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;RocketMQ 是阿里开源的消息中间件，前不久捐献给了 Apache 。正如&lt;a href=&quot;http://rocketmq.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;介绍如下：它是一个开源的分布式消息传递和流式数据平台。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot RabbitMQ 整合进阶版</title>
    <link href="http://yoursite.com/2018/01/28/RabbitMQ/"/>
    <id>http://yoursite.com/2018/01/28/RabbitMQ/</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2018-01-26T18:11:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnu3cojj9rj31hc0u079o.jpg" alt="sea-2561397_1920"></p><h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>RabbitMQ 是消息中间件的一种, 消息中间件即分布式系统中完成消息的发送和接收的基础软件. 这些软件有很多, 包括 ActiveMQ ( apache 公司的), RocketMQ (阿里巴巴公司的, 现已经转让给 apache), 还有性能极高的 Kafka。</p><a id="more"></a><p>消息中间件的工作过程可以用<strong>生产者消费者模型</strong>来表示. 即生产者不断的向消息队列发送信息, 而消费者从消息队列中消费信息. 具体过程如下:</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnuk4o5optj30pz07xdg7.jpg" alt="972319-20170311160512014-1914425149"></p><p>从上图可看出, 对于消息队列来说, 生产者,消息队列,消费者 是最重要的三个概念。生产者发消息到消息队列中去,  消费者监听指定的消息队列, 并且当消息队列收到消息之后, 接收消息队列传来的消息, 并且给予相应的处理. 消息队列常用于分布式系统之间互相信息的传递.</p><h3 id="RabbitMQ-工作原理"><a href="#RabbitMQ-工作原理" class="headerlink" title="RabbitMQ 工作原理"></a>RabbitMQ 工作原理</h3><p>对于 RabbitMQ 来说, 除了这三个基本模块以外, 还添加了一个模块, 即交换机(Exchange). 它使得生产者和消息队列之间产生了隔离, 生产者将消息发送给交换机,而交换机则根据调度策略把相应的消息转发给对应的消息队列. 那么 RabitMQ 的工作流程如下所示:</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fnuk4ohjbmj30dd08zjrw.jpg" alt="972319-20170311161512951-1006030113"></p><p>说一下交换机: 交换机的主要作用是接收相应的消息并且绑定到指定的队列. 交换机有四种类型, 分别为Direct, topic, headers, Fanout.</p><p>Direct 是 RabbitMQ 默认的交换机模式,也是最简单的模式.即创建消息队列的时候,指定一个 BindingKey. 当发送者发送消息的时候, 指定对应的 Key. 当 Key 和消息队列的 BindingKey 一致的时候,消息将会被发送到该消息队列中.</p><p>topic 转发信息主要是依据通配符, 队列和交换机的绑定主要是依据一种模式(通配符+字符串), 而当发送消息的时候, 只有指定的 Key 和该模式相匹配的时候, 消息才会被发送到该消息队列中.</p><p>headers 也是根据一个规则进行匹配, 在消息队列和交换机绑定的时候会指定一组键值对规则, 而发送消息的时候也会指定一组键值对规则, 当两组键值对规则相匹配的时候, 消息会被发送到匹配的消息队列中.</p><p>Fanout 是路由广播的形式, 将会把消息发给绑定它的全部队列, 即便设置了 key, 也会被忽略.</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/</a></p><h3 id="SpringBoot-整合-RabbitMQ（Topic-转发模式）"><a href="#SpringBoot-整合-RabbitMQ（Topic-转发模式）" class="headerlink" title="SpringBoot 整合 RabbitMQ（Topic 转发模式）"></a>SpringBoot 整合 RabbitMQ（Topic 转发模式）</h3><p>在上一篇文章中，我们也将 SpringBoot 和 RabbitMQ 整合过，不过那是使用 Direct 模式，文章地址是：<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">SpringBoot ActiveMQ 整合使用</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a></p><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>接下来，我要带大家继续整合（Topic 转发模式）：</p><p>1、配置文件和 pom.xml 这些还都是一样的，我们不用再修改</p><p>2、启动类中创建 Queue 和 Exchange，并把 Queue 按照相应的规则绑定到交换机Queue 上。代码如下图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc-queue-zhisheng"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"rpc-exchange-zhisheng"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(Queue queue, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">"rpc-zhisheng"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建一个 Queue 和 Exchange ，然后绑定。</p><p>注意：上面代码中的 with(“rpc-zhisheng”)  这个 “zhisheng” 是 routingkey，RabbitMQ 将会根据这个参数去寻找有没有匹配此规则的队列，如果有，则会把消息发送给它，如果不止有一个，则会把消息分发给所有匹配的队列。</p><p>3、消息发送类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TopicExchange exchange;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange.getName(), <span class="string">"rpc-zhisheng"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是发送消息的代码，“rpc-zhisheng” 就是上面我们设置的 routingkey。</p><p>4、消息接收端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc-queue-zhisheng"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、启动类中注入 发送消息类，然后调用 send 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitMQClient client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  client.send(<span class="string">"  zhisheng, ---------  send "</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  stopWatch.stop();</span><br><span class="line">  System.out.println(<span class="string">"总共耗时："</span> +      stopWatch.getTotalTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此 SpringBoot 项目，则可以发现结果如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fnu3cn8zwjj31kw0y9kfi.jpg" alt="Snip20180126_2"></p><p>这里测试的是匹配一个消息队列的情况，感兴趣的可以测试下匹配多个消息队列的。</p><h3 id="SpringBoot-整合-RabbitMQ-Fanout-Exchange-形式"><a href="#SpringBoot-整合-RabbitMQ-Fanout-Exchange-形式" class="headerlink" title="SpringBoot 整合 RabbitMQ( Fanout Exchange 形式)"></a>SpringBoot 整合 RabbitMQ( Fanout Exchange 形式)</h3><p>Fanout Exchange 形式又叫广播形式。</p><p>任何发送到 Fanout Exchange 的消息都会被转发到与该 Exchange 绑定(Binding)的所有 Queue 上。</p><ul><li>这种模式需要提前将 Exchange 与 Queue 进行绑定，一个 Exchange 可以绑定多个 Queue，一个 Queue 可以同多个 Exchange 进行绑定</li><li>这种模式不需要 RoutingKey</li><li>如果接受到消息的 Exchange 没有与任何 Queue 绑定，则消息会被抛弃。</li></ul><p>1、消息发送类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"fanout-exchange"</span>, <span class="string">""</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以不设置 routingkey 了。</p><p>2、启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhisheng.rabbitmq.rpc.client.RabbitMQClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqRpcApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitMQClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.send2(<span class="string">"zhisheng ++++++++++ send2 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(RabbitmqRpcApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc.queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"queue2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc.queue2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"queue3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc.queue3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanout-exchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(@Qualifier(<span class="string">"queue"</span>)</span> Queue queue, FanoutExchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding2</span><span class="params">(@Qualifier(<span class="string">"queue2"</span>)</span> Queue queue, FanoutExchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding3</span><span class="params">(@Qualifier(<span class="string">"queue3"</span>)</span> Queue queue, FanoutExchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title">messageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类中我创建三个 Queue： <code>rpc.queue</code>,  <code>rpc.queue2</code> , <code>rpc.queue3</code></p><p>也创建一个 FanoutExchange，并把这三个 Queue 绑定在同一个交换机 <code>fanout-exchange</code> 上面</p><p>注意：这个 <code>fanout-exchange</code> 交换机不知为啥，我自己在应用程序里创建，运行程序会出错，下面讲讲我是怎么解决的。</p><p>我是从 RabbitMQ 管理界面直接添加个 exchange 的。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fnu3co30lkj31hy1bun4z.jpg" alt="Snip20180126_3"></p><p>3、消息接收类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc.queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc.queue2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive2 ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc.queue3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive3</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive3 ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听每个 Queue，并有一个方法输出对应接收到的消息。</p><p>4、运行项目</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fnu3cmf22dj31kw0zoh6u.jpg" alt="Snip20180126_4"></p><p>结果如上，每个队列都打印出自己收到的结果，同时我们看看这三个 Queue 是不是绑定到 Exchange 上呢？</p><p>可以看到三个 Queue 都绑定在 Exchange 上了。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnu3clys6lj31kw1ajjy9.jpg" alt="Snip20180126_5"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RabbitMQ 与 SpringBoot 整合就到这里为止了，后面如果有时间会深度研究 RabbitMQ 的。</p><p>还请继续关注我的博客：<a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1fnu3cojj9rj31hc0u079o.jpg&quot; alt=&quot;sea-2561397_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;消息中间件&quot;&gt;&lt;a href=&quot;#消息中间件&quot; class=&quot;headerlink&quot; title=&quot;消息中间件&quot;&gt;&lt;/a&gt;消息中间件&lt;/h3&gt;&lt;p&gt;RabbitMQ 是消息中间件的一种, 消息中间件即分布式系统中完成消息的发送和接收的基础软件. 这些软件有很多, 包括 ActiveMQ ( apache 公司的), RocketMQ (阿里巴巴公司的, 现已经转让给 apache), 还有性能极高的 Kafka。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot ActiveMQ 整合使用</title>
    <link href="http://yoursite.com/2018/01/27/SpringBoot-ActiveMQ/"/>
    <id>http://yoursite.com/2018/01/27/SpringBoot-ActiveMQ/</id>
    <published>2018-01-26T16:00:00.000Z</published>
    <updated>2018-01-25T03:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fns53btbl0j31hc0zldyz.jpg" alt="busan-night-scene-1747130_1920"></p><h3 id="介绍-ActiveMQ"><a href="#介绍-ActiveMQ" class="headerlink" title="介绍 ActiveMQ"></a>介绍 ActiveMQ</h3><p>它是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ  是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的J2EE应用中间仍然扮演着特殊的地位。—— 摘自百度百科，偷了个懒。</p><a id="more"></a><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><h3 id="安装-ActiveMQ"><a href="#安装-ActiveMQ" class="headerlink" title="安装 ActiveMQ"></a>安装 ActiveMQ</h3><p>同之前一样，直接在 Docker 里面玩吧。命令也是一行解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8161:8161 -p 61616:61616 -e ACTIVEMQ_ADMIN_LOGIN=admin -e ACTIVEMQ_ADMIN_PASSWORD=admin --name activemq webcenter/activemq</span><br></pre></td></tr></table></figure><p>简单解释下：</p><ul><li>8186: 表示 ActiveMQ 控制台端口号，它和 RabbitMQ 一样都是有控制台的，可以登陆控制台进行操作的</li><li>61616 ： 表示 ActiveMQ 所监听的 TCP 端口号，应用程序可通过该端口号与 ActiveMQ 建立 TCP 连接</li><li>CTIVEMQ_ADMIN_LOGIN ：登陆控制台的用户名</li><li>ACTIVEMQ_ADMIN_PASSWORD ：登陆控制台的密码</li></ul><p>执行后，可在浏览器输入 <a href="http://localhost:8161/" target="_blank" rel="noopener">http://localhost:8161/</a>   查看控制台，</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fns4zm1yqfj31kw0djn3k.jpg" alt="Snip20180124_1"></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fns4zmk78ej31kw0ladq0.jpg" alt="Snip20180124_2"></p><p>解释下上面图片中控制台这些按钮的基本信息：</p><ul><li>Home：查看 ActiveMQ 的常见信息</li><li>Queues：查看 ActiveMQ 的队列信息</li><li>Topics：查看 ActiveMQ 的主题信息</li><li>Subscribers：查看主题的订阅者信息</li><li>Connections：查看 ActiveMQ 客户端的连接信息</li><li>Network：查看 ActiveMQ 的网络信息</li><li>Scheduled：查看 ActiveMQ 的定时任务</li><li>Send：用于通过表单方式向队列或者主题发送具体的消息</li></ul><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>IDEA 创建 SpringBoot 项目，因为 SpringBoot 已经内置了对 ActiveMQ 的支持，所以直接引入依赖 <code>spring-boot-starter-activemq</code> 就行。整体项目结构如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fns4zkpkhvj30os0tkwg8.jpg" alt="Snip20180124_3"></p><p>1、<strong>pom.xml 文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>activemq<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot ActiveMQ<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、<strong>配置文件</strong>  application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.broker-url=tcp://localhost:61616</span><br><span class="line">spring.activemq.user=admin</span><br><span class="line">spring.activemq.password=admin</span><br></pre></td></tr></table></figure><p>3、<strong>发送消息类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.activemq.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        jmsTemplate.convertAndSend(<span class="string">"zhisheng"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，和 RabbitMQ 类似，不多说了。</p><p>4、<strong>消息接收类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.activemq.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.annotation.JmsListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"zhisheng"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的 message 是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<strong>注意</strong></p><p>这个队列是不需要我们提前定义好的，它和 RabbitMQ 不一样，它会在我们需要的时候动态的创建。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.activemq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhisheng.activemq.client.ActiveMQClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivemqApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    ActiveMQClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            client.send(<span class="string">"发送消息----zhisheng-----"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(<span class="string">"发送消息耗时: "</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ActivemqApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送一万条消息运行后需要的时间挺久的：73180 ms</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fns4zlmbg7j31kw0wutop.jpg" alt="Snip20180124_4"></p><p>比 RabbitMQ 发送 10000 条消息耗时 215 ms 不知道高出多少倍了，可见其性能并不高的。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1fns53btbl0j31hc0zldyz.jpg&quot; alt=&quot;busan-night-scene-1747130_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍-ActiveMQ&quot;&gt;&lt;a href=&quot;#介绍-ActiveMQ&quot; class=&quot;headerlink&quot; title=&quot;介绍 ActiveMQ&quot;&gt;&lt;/a&gt;介绍 ActiveMQ&lt;/h3&gt;&lt;p&gt;它是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ  是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的J2EE应用中间仍然扮演着特殊的地位。—— 摘自百度百科，偷了个懒。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot  RabbitMQ 整合使用</title>
    <link href="http://yoursite.com/2018/01/26/SpringBoot-RabbitMQ/"/>
    <id>http://yoursite.com/2018/01/26/SpringBoot-RabbitMQ/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-01-26T03:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/6DFKcmCgC7.png-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>上次写了篇文章，<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">《SpringBoot Kafka 整合使用》</a>，阅读量还挺高的，于是想想还是把其他几种 MQ 也和 SpringBoot 整合使用下。</p><a id="more"></a><p>下面是四种比较流行的 MQ ：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fnrqdwnlsej30fw07274m.jpg" alt="rabbitmq-1"></p><p>后面都写写和 SpringBoot 整合的文章。</p><h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><p>由于换 Mac 了，所以一些环境就直接在 Mac 搞，但是像安装 RabbitMQ 这些又会把自己电脑系统给搞的太乱，所以能在 Docker 里面安装就安装在 Docker，这次 RabbitMQ 我也直接在 Docker 里安装。</p><p>启动 Docker for Mac，如果没安装过的请看我上一篇文章：<a href="http://www.54tianzhisheng.cn/2018/01/25/Docker-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/25/Docker-install/</a></p><p>当然你也可以在自己的 Linux 服务器或者虚拟机里启动安装 RabbitMQ 。</p><p>Docker 安装的话很简单，因为 RabbitMQ 官方已经提供了自己的 Docker 容器，只需要一行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p 15672:15672  -p  5672:5672  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin --name rabbitmq rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>该镜像拥有一个基于 web 的控制台和 Http API。Http API 可以在地址看到如何使用：<code>http://localhost:15672/api/</code></p><p>讲解下上面命令行：</p><ul><li>15672 ：表示 RabbitMQ 控制台端口号，可以在浏览器中通过控制台来执行 RabbitMQ 的相关操作。</li><li>5672 : 表示 RabbitMQ 所监听的 TCP 端口号，应用程序可通过该端口与 RabbitMQ 建立 TCP 连接，并完成后续的异步消息通信</li><li>RABBITMQ_DEFAULT_USER：用于设置登陆控制台的用户名，这里我设置 admin</li><li>RABBITMQ_DEFAULT_PASS：用于设置登陆控制台的密码，这里我设置 admin</li></ul><p>容器启动成功后，可以在浏览器输入地址：<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a>  访问控制台</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqdzkxzoj30js0980t7.jpg" alt="rabbitmq-2"></p><p>登陆后：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqohaja0j31kw0vr0z3.jpg" alt="rabbitmq-3"></p><p>简单描述下上图中中控制台的列表的作用：</p><ul><li>Overview ：用于查看 RabbitMQ 的一些基本信息（消息队列、消息发送速率、节点、端口和上下文信息等）</li><li>Connections：用于查看 RabbitMQ 客户端的连接信息</li><li>Channels：用户查看 RabbitMQ 的通道信息</li><li>Exchange：用于查看 RabbitMQ 交换机</li><li>Queues：用于查看 RabbitMQ 的队列</li><li>Admin：用于管理用户，可增加用户</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在 IDEA 中创建一个 SpringBoot 项目结构：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqp4fi3cj30pk12qtcc.jpg" alt="Snip20180124_5"></p><p>SpringBoot 框架中已经内置了对 RabbitMQ 的支持，如果你看过官方文档的话，就可以看到的，我们需要把依赖 spring-boot-starter-amqp 引入就行。</p><p>1、 <strong>pom.xml</strong> 引入依赖后如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rabbitmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>rabbitmq<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot RabbitMQ<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、<strong>application.properties</strong>  配置修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.addresses=localhost:5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=admin</span><br></pre></td></tr></table></figure><p>3、<strong>消息发送类</strong> RabbitMQClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"zhisheng"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，发送消息代码就实现了。</p><p>这里关键的代码为 rabbitTemplate.convertAndSend() 方法，<code>zhisheng</code> 这个是路由规则（routingKey），它的值表明将消息发送到指定的队列 <code>zhisheng</code> 中去，这里跟了下源码，发现 convertAndSend() 方法最后调用的方法其实是一个 doSend() 方法。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fnrqpy395kj31kw0wkn75.jpg" alt="Snip20180124_7"></p><p>4、<strong>消息接收类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"zhisheng"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的 message 是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，这里就有个 <code>RabbitListener</code> 一直在监听着队列 <code>zhisheng</code> 。</p><p>当然这个队列是必须要我们自己在应用程序中创建好，它不会像我之前写的文章 <a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">《SpringBoot Kafka 整合使用》</a>  中的 Kafka 一样，Kafka 它会在用到队列的时候动态的创建，不需要我们提前创建好。</p><p>那么在 RabbitMQ 中该如何创建队列呢？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqqcykkoj31kw0roajh.jpg" alt="Snip20180124_8"></p><p>如上图所示：这样我们就创建好了一个 <code>zhisheng</code> 的队列，当程序开始运行时，消息接收类会持续监听队列 <code>zhisheng</code> 中即将到来的消息。</p><p>5、<strong>运行项目</strong></p><p>需要在启动类中注入发送消息的类，并且提供 init 方法，在 init 方法中调用发送消息类的 send()  方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rabbitMQClient.send(<span class="string">"发送消息----zhisheng-----"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：init() 方法带有 @PostConstruct 注解，被 @PostConstruct 修饰的方法会在构造函数之后执行。</p><p>启动项目就可以发现控制台已经接收到消息了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqqqr9zlj31kw10qdv6.jpg" alt="Snip20180124_9"></p><p>6、<strong>单线程测试性能</strong></p><p>看到上面图片中注释掉的代码没？那就是用来测试消息发送的性能的，我发送 10000 条消息看看总共耗时多少。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnrqr3c0wnj31kw0tctgm.jpg" alt="Snip20180124_10"></p><p>10000 条消息发送耗时：215ms。   这是在单线程下，下次可以和其他的 MQ 测试对比下，并且也可以在多线程的环境下测试性能。</p><p>同时从控制台可以看到发送的速率：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnrqrd94g6j31kw0s1tim.jpg" alt="Snip20180124_11"></p><p>7、<strong>多线程测试性能</strong></p><p>开了10 个线程，每个线程发送 10000 条消息。</p><p>init  方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> threads = <span class="number">10</span>;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(threads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(threads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    start.await();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10000</span>; i1++) &#123;</span><br><span class="line">                        rabbitMQClient.send(<span class="string">"发送消息----zhisheng-----"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    end.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        start.countDown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            end.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(<span class="string">"发送消息耗时："</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>耗时：4063ms</p><p>控制台显示如下图：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnrqrt6ngfj31kw0ul47b.jpg" alt="Snip20180124_12"></p><p>8、<strong>注意</strong></p><p>这里测试发送的消息直接是 String 类型的，你也可以测试下 Bean 类，这需要注意需要序列化。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/6DFKcmCgC7.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;上次写了篇文章，&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《SpringBoot Kafka 整合使用》&lt;/a&gt;，阅读量还挺高的，于是想想还是把其他几种 MQ 也和 SpringBoot 整合使用下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装 Docker 及常用命令</title>
    <link href="http://yoursite.com/2018/01/25/Docker-install/"/>
    <id>http://yoursite.com/2018/01/25/Docker-install/</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2018-01-24T09:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/mALkf4CKA2.png-1" alt="mark"></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>微服务 + 容器，完美的一对！必须得好好学习学习。</p><a id="more"></a><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>Mac 下 Docker 的安装真心建议跟着官方的文档走一遍，官网已经讲的很详细了。</p><p><a href="https://docs.docker.com/docker-for-mac/install/#what-to-know-before-you-install" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/install/#what-to-know-before-you-install</a></p><h3 id="使用-Docker-for-Mac"><a href="#使用-Docker-for-Mac" class="headerlink" title="使用 Docker for Mac"></a>使用 Docker for Mac</h3><p><a href="https://docs.docker.com/docker-for-mac/#check-versions-of-docker-engine-compose-and-machine" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/#check-versions-of-docker-engine-compose-and-machine</a></p><h3 id="配置-Docker-加速器"><a href="#配置-Docker-加速器" class="headerlink" title="配置 Docker 加速器"></a>配置 Docker 加速器</h3><p>Docker 加速器是什么，我需要使用吗？</p><p>使用 Docker 的时候，需要经常从官方获取镜像，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重影响使用 Docker 的体验。因此 DaoCloud 推出了加速器工具解决这个难题，通过智能路由和缓存机制，极大提升了国内网络访问 Docker Hub 的速度，目前已经拥有了广泛的用户群体，并得到了 Docker 官方的大力推荐。如果您是在国内的网络环境使用 Docker，那么 Docker 加速器一定能帮助到您。</p><p>注册 <a href="">daocloud</a>，然后在 mac 标签页复制加速器 url。</p><p><img src="https://upload-images.jianshu.io/upload_images/5225109-54fdf15443d355fd.png?imageMogr2/auto-orient/" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5225109-8dd1076f952fda33.png?imageMogr2/auto-orient/" alt=""></p><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>跟着下面的文章进行敲一遍，熟悉下 Docker 整个的使用。</p><p><a href="https://www.jianshu.com/p/cf6e7248b6c7" target="_blank" rel="noopener">https://www.jianshu.com/p/cf6e7248b6c7</a></p><h3 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h3><p>下面列出些自己常用的命令，目的就是记录下来，以后忘记了，再拿来跟着敲就行！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t &lt;image_name/continar_id&gt; /bin/bash  启动容器并启动bash（交互方式）</span><br><span class="line"></span><br><span class="line">docker run -d -it  image_name   启动容器以后台方式运行(更通用的方式）</span><br><span class="line"></span><br><span class="line">docker ps   列出当前所有正在运行的container</span><br><span class="line"></span><br><span class="line">docker ps -a  列出所有的container</span><br><span class="line"></span><br><span class="line">docker ps -l   列出最近一次启动的container</span><br><span class="line"></span><br><span class="line">docker images  列出本地所有的镜像</span><br><span class="line"></span><br><span class="line">docker rmi imagesID   删除指定的镜像id</span><br><span class="line"></span><br><span class="line">docker rm CONTAINER ID   删除指定的CONTAINER id</span><br><span class="line"></span><br><span class="line">docker diff 镜像名    查看容器的修改部分</span><br><span class="line"></span><br><span class="line">docker kill CONTAINER ID   杀掉正在运行的容器</span><br><span class="line"></span><br><span class="line">docker logs 容器ID/name   可以查看到容器主程序的输出</span><br><span class="line"></span><br><span class="line">docker pull image_name    下载image</span><br><span class="line"></span><br><span class="line">docker push image_name   发布docker镜像</span><br><span class="line"></span><br><span class="line">docker version   查看docker版本</span><br><span class="line"></span><br><span class="line">docker info   查看docker系统的信息</span><br><span class="line"></span><br><span class="line">docker inspect 容器的id 可以查看更详细的关于某一个容器的信息</span><br><span class="line"></span><br><span class="line">docker run -d  image-name   后台运行镜像</span><br><span class="line"></span><br><span class="line">docker search 镜像名    查找公共的可用镜像</span><br><span class="line"></span><br><span class="line">docker stop 容器名/容器 ID      终止运行的容器</span><br><span class="line"></span><br><span class="line">docker restart 容器名/容器 ID    重启容器</span><br><span class="line"></span><br><span class="line">docker commit  提交，创建个新镜像</span><br><span class="line"></span><br><span class="line">docker build [OPTIONS] PATH | URL | -   利用 Dockerfile 创建新镜像</span><br></pre></td></tr></table></figure><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明地址：<a href="http://www.54tianzhisheng.cn/2018/01/25/Docker-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/25/Docker-install/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/mALkf4CKA2.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;微服务 + 容器，完美的一对！必须得好好学习学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MacBook Pro 初体验</title>
    <link href="http://yoursite.com/2018/01/24/mac/"/>
    <id>http://yoursite.com/2018/01/24/mac/</id>
    <published>2018-01-23T16:00:00.000Z</published>
    <updated>2018-01-23T16:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/kFhlh5gA23.png-1" alt="mark"></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><a id="more"></a><p>在 Mac 到手之前就在各种群里看到人说 Mac 多好用，也有很多人鼓吹过 Mac 的好处，最后也坚定我的年前目标了 —— 就是买台 Mac，之前请原谅我这个穷鬼，买不起，现在买了 Mac 后更加得体谅我这个穷鬼了，毕竟在上海这个城市，靠着实习工资买这种奢侈品，不容易啊😄 。废话不多说，如果愿意支持我的，请在文章底部扫描二维码，在此先谢谢了。</p><h3 id="如何挑选？"><a href="#如何挑选？" class="headerlink" title="如何挑选？"></a>如何挑选？</h3><p>MacBook 主要分两系列：MacBook Air 和 MacBook Pro。</p><p>Air 的话个人感觉配置不高，如果是开发还是建议买 Pro 系列的。如今买的话，可能还会分 2015 款、2016 款、2017 款。每款中又分 内存大小（8/16g）、硬盘大小（128/256/512g）、CPU、处理器（i5/i7）、是否有TouchBar、显卡等。不同配置对应电脑的型号也是不一样的。下面直接上一张在我的特殊渠道里的报价表截图吧。（想了解的可以找我）</p><p><img src="http://ohfk1r827.bkt.clouddn.com/mac-1.jpg-1" alt="mac-1"></p><p>光这型号，不懂的人还真不会挑。</p><p>不得不说，苹果电脑真尼玛难挑啊，如果你是土豪，那不用挑了，直接上最高价钱的吧。</p><p>然后可以从配置中发现 2016 款和 2017 款变化真心不大，在同等配置下，2017 款几乎比 2016 款价格高个 3000 来块。</p><p>然后就是 512 G 硬盘比 256 G 也几乎贵个 2000 多。</p><p>16G 那是必须的上啊，标配了，8G 就不说了，太小了。</p><p>含 TouchBar，虽然确实用处不大，不过调音两还是不错的。高配都有 TouchBar 的。</p><p>出于 <strong>qiong</strong> ，我买了 2016 款，配置是：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/mac-2.jpg-1" alt="mac-2"></p><p>不过现在 2016 款好像停产了。</p><h3 id="到手"><a href="#到手" class="headerlink" title="到手"></a>到手</h3><p>2018.01.11 下午六点快递送到的，很开心。晚上拿回家拆箱，第一件事情就是检查序列号啊，上面的图片打码掉的就是序列号，这个序列号在电脑机身、系统、外牛皮癣盒都有的，可以在官网查询这个序列号，获得电脑的激活日期和剩余保修时间的。再就是查询电脑的电池循环次数了，我的是一次，一般好像是几次之内都是符合的。证明之前没被别人用过，这个数字我也忘记了。</p><h3 id="熟悉系统"><a href="#熟悉系统" class="headerlink" title="熟悉系统"></a>熟悉系统</h3><p>Mac 系统是类 Unix 系统，其实我觉得到和 Ubuntu 系统挺像的，既有图形化界面，也可以命令行操作。熟悉过 Linux 的应该上手很快的。</p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>可以在 Appstore 里面下载，也可以在一些软件的官网直接下载 mac 版的。安装也挺简单的。如果你不知道有什么软件可以安装，那么我这里给你份 Mac 软件参考列表：<a href="https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md" target="_blank" rel="noopener">https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md</a></p><p>当然了，上面的不一定全，具体用到其他的还是的自己去找对应的软件。</p><p>还有就是好多软件是收费的，在 Mac 上如果要下载的话，还的费点心思去破解，比如 Office、IDEA、Adobe 系列等，当然也不是鼓吹大家去破解，我们自己用用就行，虽说现在没钱支持，但是有钱的话还是支持下。我一个写博客的知道写博客的不容易，那写软件的更不容易了，能支持一两块也挺好的。</p><p>然后就是美化下我们的一些软件，比如我们的终端之类的、尽量使用 Homebrew 安装软件。当然这篇文章不会写这些的，改天专门写篇文章写这个话题。</p><p>还有就是在 Mac 上从新打造一个适合自己的新写作环境（软件、Hexo 写博客环境）。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>体验了 Mac 也有一个多礼拜了，整体效果还是不错的，毕竟花了巨资呢，也算是完成了自己年前的小目标。先 bb 到这里吧。有时间再写点关于 Mac 上的东西，这次写的比较简单，这篇文章也是在 Mac 上写的第一篇文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/kFhlh5gA23.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Admin 使用指南</title>
    <link href="http://yoursite.com/2018/01/17/SpringBoot-Admin/"/>
    <id>http://yoursite.com/2018/01/17/SpringBoot-Admin/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-21T11:25:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/m1b2jfCc9I.png-1" alt="mark"></p><h3 id="什么是-SpringBoot-Admin？"><a href="#什么是-SpringBoot-Admin？" class="headerlink" title="什么是 SpringBoot Admin？"></a>什么是 SpringBoot Admin？</h3><p>Spring Boot Admin 是一个管理和监控你的 Spring Boot 应用程序的应用程序。 这些应用程序通过 Spring Boot Admin Client（通过 HTTP）注册或者使用 Spring Cloud（例如 Eureka）发现。 UI只是 Spring Boot Actuator 端点上的一个 AngularJs 应用程序。<br><a id="more"></a></p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>首先在 IDEA 创建一个 SpringBoot 项目，把它当作 server 端，工程如下：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/hIKaIkCE8a.png-1" alt="mark"></p><p>然后在 pom.xml 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-server-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续在启动类 SpringbootAdminApplication.java 中引入注解 <strong>@EnableAdminServer</strong> ，然后运行项目：</p><p>访问 <a href="http://localhost:8084/" target="_blank" rel="noopener">http://localhost:8084/</a>  即可：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/C55mBbf8LH.png-1" alt="mark"></p><p>此时会发现没有任何应用程序的信息。</p><p>接下来我们新建一个 SpringBoot 项目，把它当作客户端程序，工程如下：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/9EGaFH3Gb7.png-1" alt="mark"></p><p>在 pom.xml 中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 application.yml 中设置：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/3AL0J6I16b.png-1" alt="mark"></p><p>spring.boot.admin.url=http:localhost:8094 用于将当前应用注册到 Spring Boot Admin。</p><p>还可以设置，spring.boot.admin.client.name: （应用程序的名字）不设置的话会有默认的名字</p><p>此时把两个项目运行起来：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/IGEBDm4eJ7.png-1" alt="mark"></p><p>点击图中的 <strong>detail</strong> 按钮：可以看到应用程序的健康值、内存、JVM、GC 等信息。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/GJBjGF512G.png-1" alt="mark"></p><p><strong>metrics</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/gdbj21Fk19.png-1" alt="mark"></p><p><strong>环境</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/eglbcgE9C5.png-1" alt="mark"></p><p><strong>log</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/IkeJkaEGcI.png-1" alt="mark"></p><p><strong>JMX</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/e3Ei3l6ieF.png-1" alt="mark"></p><p><strong>线程</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/ClFekkJKB8.png-1" alt="mark"></p><p><strong>Trace</strong> 追踪信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/J6m9b43F8d.png-1" alt="mark"></p><p>还可以下载 Heapdump 文件。</p><p>刚才首页的应用列表后面有个红色的 ×，我们可以将注册上去的应用移除，但是只要你不把程序停掉，它立马又会注册上去。</p><p>还有就是应用列表的 version 和 info 上面的图中为空，下面看看怎么把它变出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.groupId: @project.groupId@</span><br><span class="line">info.artifactId: @project.artifactId@</span><br><span class="line">info.version: @project.version@</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/3E5hlG7heJ.png-1" alt="mark"></p><p>重新运行客户端程序，刷新页面可以发现：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/A0FBLLK9LE.png-1" alt="mark"></p><p>还可以查询应用程序的事件变化：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/E9LfBJGaB3.png-1" alt="mark"></p><h3 id="客户端应用程序"><a href="#客户端应用程序" class="headerlink" title="客户端应用程序"></a>客户端应用程序</h3><h4 id="JMX-bean管理"><a href="#JMX-bean管理" class="headerlink" title="JMX bean管理"></a>JMX bean管理</h4><p>要在管理界面中与JMX-beans进行交互，您必须在客户端应用程序中包含 Jolokia,</p><p>pom.xml 加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jolokia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jolokia-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启客户端程序后，就可以在这里与 JMX 做交互了：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/g82cD16kBf.png-1" alt="mark"></p><p>还有很多 SpringBoot Admin 客户端配置选项：</p><p><a href="http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-client" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-client</a></p><h3 id="服务端程序"><a href="#服务端程序" class="headerlink" title="服务端程序"></a>服务端程序</h3><p>也有些 SpringBoot Admin 服务端程序配置选项：</p><p><a href="http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-server" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-server</a></p><p>官方文档里面还有些关于服务下线消息通知的知识，想了解的可以查看：</p><p><a href="http://codecentric.github.io/spring-boot-admin/1.5.6/#_notifications" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/1.5.6/#_notifications</a></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="">http://codecentric.github.io/spring-boot-admin/1.5.6/</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明文章原始地址为：<a href="http://www.54tianzhisheng.cn/2018/01/17/SpringBoot-Admin/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/17/SpringBoot-Admin/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/m1b2jfCc9I.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是-SpringBoot-Admin？&quot;&gt;&lt;a href=&quot;#什么是-SpringBoot-Admin？&quot; class=&quot;headerlink&quot; title=&quot;什么是 SpringBoot Admin？&quot;&gt;&lt;/a&gt;什么是 SpringBoot Admin？&lt;/h3&gt;&lt;p&gt;Spring Boot Admin 是一个管理和监控你的 Spring Boot 应用程序的应用程序。 这些应用程序通过 Spring Boot Admin Client（通过 HTTP）注册或者使用 Spring Cloud（例如 Eureka）发现。 UI只是 Spring Boot Actuator 端点上的一个 AngularJs 应用程序。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Lombok 看这篇就够了</title>
    <link href="http://yoursite.com/2018/01/09/lombok/"/>
    <id>http://yoursite.com/2018/01/09/lombok/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2018-01-21T13:10:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/7JfK07cCbh.png-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>自从进公司实习后，项目代码中能用 Lombok 的都用了，毕竟这么好的轮子要充分利用好。也可以减少一些 get/set/toString 方法的编写，虽说 IDEA 的插件可以自动生成 get/set/toString 方法，但是使用 Lombok 可以让代码更简洁。<br><a id="more"></a><br>下面看看如何在 IDEA　中如何安装 Lombok：</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>打开 IDEA 的 Settings 面板，并选择 Plugins 选项，然后点击 “Browse repositories”</p><p>在输入框输入”lombok”，得到搜索结果，点击安装，然后安装提示重启 IDEA，安装成功;</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180106/C33FG37Gk4.png-1" alt="mark"></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在自己的项目里添加 lombok 的编译支持，在 pom 文件里面添加 dependency</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.18&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h3><p>在实体类上引入相关的注解就行：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180106/aCEc8ileJg.png-1" alt="mark"></p><h3 id="有哪些注解？"><a href="#有哪些注解？" class="headerlink" title="有哪些注解？"></a>有哪些注解？</h3><ul><li>@Data</li><li>@Setter</li><li>@Getter</li><li>@Slf4j</li><li>@AllArgsConstructor</li><li>@NoArgsConstructor</li><li>@EqualsAndHashCode</li><li>@NonNull</li><li>@Cleanup</li><li>@ToString</li><li>@RequiredArgsConstructor</li><li>@Value</li><li>@SneakyThrows</li><li>@Synchronized</li></ul><h3 id="注解详解"><a href="#注解详解" class="headerlink" title="注解详解"></a>注解详解</h3><p><strong>@Data</strong></p><p>注解在 <strong>类</strong> 上；提供类所有属性的 get 和 set 方法，此外还提供了equals、canEqual、hashCode、toString 方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/mHj1eak6fJ.png-1" alt="mark"></p><p><strong>@Setter</strong></p><p>注解在 <strong>属性</strong> 上；为单个属性提供 set 方法; 注解在 <strong>类</strong> 上，为该类所有的属性提供 set 方法， 都提供默认构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/lkkff2b6Dc.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/J9mC8FGfc0.png-1" alt="mark"></p><p><strong>@Getter</strong></p><p>注解在 <strong>属性</strong> 上；为单个属性提供 get 方法; 注解在 <strong>类</strong> 上，为该类所有的属性提供 get 方法，都提供默认构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/d0F5h97J5f.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/K0m81cFd6g.png-1" alt="mark"></p><p><strong>@Slf4j</strong></p><p>注解在 <strong>类</strong> 上；为类提供一个 属性名为 log 的日志对象，提供默认构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/BChd89Cbh5.png-1" alt="mark"></p><p><strong>@AllArgsConstructor</strong></p><p>注解在 <strong>类</strong> 上；为类提供一个全参的构造方法，加了这个注解后，类中不提供默认构造方法了。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/4iji9AJ0fE.png-1" alt="mark"></p><p><strong>@NoArgsConstructor</strong></p><p>注解在 <strong>类</strong> 上；为类提供一个无参的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/JcdfmhDAaB.png-1" alt="mark"></p><p><strong>@EqualsAndHashCode</strong></p><p>注解在 <strong>类</strong> 上, 可以生成 equals、canEqual、hashCode 方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/CKHe7EICGd.png-1" alt="mark"></p><p><strong>@NonNull</strong></p><p>注解在 <strong>属性</strong> 上，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，也会有一个默认的无参构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/g6Lh1eh1jm.png-1" alt="mark"></p><p><strong>@Cleanup</strong></p><p>这个注解用在 <strong>变量</strong> 前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的 close() 方法，如果该资源有其它关闭方法，可使用 @Cleanup(“methodName”) 来指定要调用的方法，也会生成默认的构造方法</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/Ba1bDkKb9J.png-1" alt="mark"></p><p><strong>@ToString</strong></p><p>这个注解用在 <strong>类</strong> 上，可以生成所有参数的 toString 方法，还会生成默认的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/7LjglDeH8e.png-1" alt="mark"></p><p><strong>@RequiredArgsConstructor</strong></p><p>这个注解用在 <strong>类</strong> 上，使用类中所有带有 @NonNull 注解的或者带有 final 修饰的成员变量生成对应的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/CBgAF4ei8m.png-1" alt="mark"></p><p><strong>@Value</strong></p><p>这个注解用在 <strong>类</strong> 上，会生成含所有参数的构造方法，get 方法，此外还提供了equals、hashCode、toString 方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/b6KeAg0ABi.png-1" alt="mark"></p><p><strong>@SneakyThrows</strong></p><p>这个注解用在 <strong>方法</strong> 上，可以将方法中的代码用 try-catch 语句包裹起来，捕获异常并在 catch 中用 Lombok.sneakyThrow(e) 把异常抛出，可以使用 @SneakyThrows(Exception.class) 的形式指定抛出哪种异常，也会生成默认的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/IfCKh1FGbh.png-1" alt="mark"></p><p><strong>@Synchronized</strong></p><p>这个注解用在 <strong>类方法</strong> 或者 <strong>实例方法</strong> 上，效果和 synchronized 关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized 关键字的锁对象分别是类的 class 对象和 this 对象，而 @Synchronized 的锁对象分别是 私有静态 final 对象 lock 和 私有 final 对象 lock，当然，也可以自己指定锁对象，此外也提供默认的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/L95jIc7eJi.png-1" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上注解可根据需要一起搭配使用！</p><p><strong>虽说轮子好，但是我们不仅要知其然，也要知其所以然！</strong></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明原创地址：<a href="http://www.54tianzhisheng.cn/2018/01/07/lombok/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/07/lombok/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/7JfK07cCbh.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;自从进公司实习后，项目代码中能用 Lombok 的都用了，毕竟这么好的轮子要充分利用好。也可以减少一些 get/set/toString 方法的编写，虽说 IDEA 的插件可以自动生成 get/set/toString 方法，但是使用 Lombok 可以让代码更简洁。&lt;br&gt;
    
    </summary>
    
    
      <category term="lombok" scheme="http://yoursite.com/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Kafka 整合使用</title>
    <link href="http://yoursite.com/2018/01/05/SpringBoot-Kafka/"/>
    <id>http://yoursite.com/2018/01/05/SpringBoot-Kafka/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-01-21T11:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/DKcBEKHimB.jpg-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>假设你了解过 SpringBoot 和 Kafka。<br><a id="more"></a><br>1、SpringBoot</p><p>如果对 SpringBoot 不了解的话，建议去看看 <a href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">DD 大佬</a> 和 <a href="http://www.ityouknow.com/spring-boot.html" target="_blank" rel="noopener">纯洁的微笑</a> 的系列博客。</p><p>2、Kafka</p><p>Kafka 的话可以看看我前两天写的博客 ： <a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a>   学习的话自己开台虚拟机自己手动搭建环境吧，有条件的买服务器。</p><p>注意：<strong>一定要亲自自己安装实践</strong>，接下来我们将这两个进行整合。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h4 id="项目整体架构："><a href="#项目整体架构：" class="headerlink" title="项目整体架构："></a>项目整体架构：</h4><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/c6jC85Bbk4.png-1" alt="mark"></p><p>使用 IDEA 创建 SpringBoot 项目，这个很简单了，这里不做过多的讲解。</p><p>1、pom 文件代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-learning<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>kafka-learning<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot + kafka<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要引入了  spring-kafka 、lombok 、 gson 依赖。</p><p>2、消息实体类 Message.java  如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">//id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date sendTime;  <span class="comment">//时间戳</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、消息发送类 KafkaSender.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Gson gson = <span class="keyword">new</span> GsonBuilder().create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        message.setId(System.currentTimeMillis());</span><br><span class="line">        message.setMsg(UUID.randomUUID().toString());</span><br><span class="line">        message.setSendTime(<span class="keyword">new</span> Date());</span><br><span class="line">        log.info(<span class="string">"+++++++++++++++++++++  message = &#123;&#125;"</span>, gson.toJson(message));</span><br><span class="line">        kafkaTemplate.send(<span class="string">"zhisheng"</span>, gson.toJson(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，发送消息代码就实现了。</p><p>这里关键的代码为 <code>kafkaTemplate.send()</code>  方法，<code>zhisheng</code> 是 Kafka 里的 topic ，这个 topic 在 Java 程序中是不需要提前在 Kafka 中设置的，因为它会在发送的时候自动创建你设置的 topic， <code>gson.toJson(message)</code>   是消息内容，这里暂时先说这么多了，不详解了，后面有机会继续把里面源码解读写篇博客出来（因为中途碰到坑，老子跟了几遍源码）。</p><p>4、消息接收类  KafkaReceiver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123;<span class="string">"zhisheng"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kafkaMessage.isPresent()) &#123;</span><br><span class="line"></span><br><span class="line">            Object message = kafkaMessage.get();</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"----------------- record ="</span> + record);</span><br><span class="line">            log.info(<span class="string">"------------------ message ="</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端 consumer 接收消息特别简单，直接用 <code>@KafkaListener</code> 注解即可，并在监听中设置监听的 <code>topic</code> ，<code>topics</code> 是一个数组所以是可以绑定多个主题的，上面的代码中修改为 <code>@KafkaListener(topics = {&quot;zhisheng&quot;,&quot;tian&quot;})</code>  就可以同时监听两个 <code>topic</code> 的消息了。需要注意的是：这里的 topic 需要和消息发送类 KafkaSender.java 中设置的 topic 一致。</p><p>5、启动类 KafkaApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(KafkaApplication.class, args);</span><br><span class="line"></span><br><span class="line">        KafkaSender sender = context.getBean(KafkaSender.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//调用消息发送类中的消息发送方法</span></span><br><span class="line">            sender.send();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、配置文件 application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#============== kafka ===================</span><br><span class="line"># 指定kafka 代理地址，可以多个</span><br><span class="line">spring.kafka.bootstrap-servers=192.168.153.135:9092</span><br><span class="line"></span><br><span class="line">#=============== provider  =======================</span><br><span class="line"></span><br><span class="line">spring.kafka.producer.retries=0</span><br><span class="line"># 每次批量发送消息的数量</span><br><span class="line">spring.kafka.producer.batch-size=16384</span><br><span class="line">spring.kafka.producer.buffer-memory=33554432</span><br><span class="line"></span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line"></span><br><span class="line">#=============== consumer  =======================</span><br><span class="line"># 指定默认消费者group id</span><br><span class="line">spring.kafka.consumer.group-id=test-consumer-group</span><br><span class="line"></span><br><span class="line">spring.kafka.consumer.auto-offset-reset=earliest</span><br><span class="line">spring.kafka.consumer.enable-auto-commit=true</span><br><span class="line">spring.kafka.consumer.auto-commit-interval=100</span><br><span class="line"></span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br></pre></td></tr></table></figure><p>spring.kafka.bootstrap-servers 后面设置你安装的 Kafka 的机器 IP 地址和端口号 9092。</p><p>如果你只是简单整合下，其他的几个默认就好了。</p><h3 id="Kafka-设置"><a href="#Kafka-设置" class="headerlink" title="Kafka 设置"></a>Kafka 设置</h3><p>在你安装的 Kafka 目录文件下：</p><h4 id="启动-zk"><a href="#启动-zk" class="headerlink" title="启动 zk"></a>启动 zk</h4><p>使用安装包中的脚本启动单节点 Zookeeper 实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><h4 id="启动-Kafka-服务"><a href="#启动-Kafka-服务" class="headerlink" title="启动 Kafka 服务"></a>启动 Kafka 服务</h4><p>使用 <code>kafka-server-start.sh</code> 启动 kafka 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh  config/server.properties</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/Lc2CiKfIee.png-1" alt="mark"></p><p>启动成功后！</p><p><strong>千万注意</strong>： 记得将你的虚拟机或者服务器关闭防火墙或者开启 Kafka 的端口 9092。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/HBB0LCDdj8.png-1" alt="mark"></p><p>出现这就代表整合成功了！</p><hr><p>我们看下 Kafka 中的 topic 列表就</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/DI6cmll4BC.png-1" alt="mark"></p><p>就会发现刚才我们程序中的 <code>zhisheng</code> 已经自己创建了。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180105/DKcBEKHimB.jpg-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;假设你了解过 SpringBoot 和 Kafka。&lt;br&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>为什么要重新运营以前的公众号呢？</title>
    <link href="http://yoursite.com/2018/01/04/weixin/"/>
    <id>http://yoursite.com/2018/01/04/weixin/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-01-21T11:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/mL5G5acdd4.png-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>老读者可能会发现现在我的公众号已经改名了。（由 “猿blog”  变成  “zhisheng” 了，细心的童鞋会发现不仅名字变了， ID 也变了，但是图片还没改，暂时还没想到好的 logo 图片），下面说说为啥吧！<br><a id="more"></a></p><h3 id="听我瞎-BB"><a href="#听我瞎-BB" class="headerlink" title="听我瞎 BB"></a>听我瞎 BB</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/k1a984Emlc.png-1" alt="mark"></p><p>上图是两年前公众号群发的第一条信息，那时自己还是在学校，如今已经进入了社会，在公司实习了。记得当初开这个公众号的原因是因为几个年轻人有着梦想，打算一起做点东西，当时一腔热血的自己立马就先申请了个公众号，后来 “东西” 倒是没做，反倒是我自己慢慢的在微信公众号分享一些文章，然后那时自己也写博客（算算自己写博客应该快三年了，坚持真不易啊），所以偶尔也把自己的博客分享在微信公众号上。</p><p>但是好景不长，那时的微信公众号排版真尼玛难用的一批，作为一个理工科的男生，本来自己做事一般细心和耐心，无奈，把这么好的一个童鞋都给逼坏了。我现在还是得吐槽下，如今的微信公众号后台排版还是那么差。但是可能因为需求比较多了，所以就有人做出了工具（将 markdown 排版后在将整个样式复制粘贴到微信公众号后台），这样一篇排版还算不错的博客就出来了。</p><p>自己早就知道了这么个工具，以前看 DD 的博客的时候就发现了这个工具，但是很久没更新的微信公众号，自己也不怎么想再管理。</p><p>有人就要问了？那为啥现在又要开始跟新了呢？</p><p>我只想说：“贱人就是矫情！！！又想瞎折腾下。”，反正自己的博客也在不断的更新，偶尔顺带把文章同步到微信公众号其实也是可以的。在学校的时候时间比较多，那时真的是时间比较多，后悔没好好坚持运营下来。现在工作了，自己工作之外的时间较少，除了学习，偶尔写写博客，娱乐时间比较少，都是大学时宅的。</p><p>前段时间被人 “忽悠” 说继续更新公众号，那时刚好也快 2018 年了，自己也想给自己定几个目标，在元旦的那天，想想还是继续更新微信公众号吧，所以你也看得到最近我的更新了，可能最近的更新比较有规律，因为这些文章大部分是之前就已经写好了的，已经发过在我的博客里了。估计把这些文章更新完后，就不会每天都更新我自己的文章了。</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>说下微信公众号的定位吧：</p><p>1、我的技术博客应该都会同步在这里的。</p><p>2、分享自己平时的随笔文章。（比如这篇。。。）</p><p>3、除了技术文章，当然还有平时自己的 奇淫技巧 （包括但不限于写作方式、推荐好用的软件等）</p><p>4、分享自己觉得不错的文章（别人的，尽量征得同意，一定会备注原创地址的）</p><p>5、如果你也写博客，但是阅读量很小的话，可以考虑自荐。（注：文章我可能会审批，必须要觉得不错的文章）</p><p>6、分享一些学习视频和书籍</p><p>7、后期可能会搞工作内推</p><p>。。。</p><p>暂时只想到这些了</p><h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h3><p>因为工作了，所以时间少，运营这微信公众号可能需要花费我不少工作之外的时间。</p><p>如果可以的话，我希望能找到一个能帮我分担点的朋友。</p><p>注：<strong>无偿的，如果介意的话，下面就不用再看了。</strong></p><hr><p>说点简单的要求吧：</p><p>1、细心、耐心的 boy  or  girl 都行</p><p>2、起码要知道点编程方面的知识</p><p>3、能坚持下来</p><p>4、对新技术有敏感的嗅觉</p><p>5、最后一点就是你要有点时间了，希望不耽误你学习</p><p>再说下能给你带来的 <strong>好处</strong> 吧：</p><p>1、肯定能增加你的运营能力（再去互联网公司投运营岗位会有优势的）</p><p>2、本人一开始会亲自教授该怎么做，所以没经验的朋友不用担心</p><p>3、可以增加和大牛勾搭的机会，你们懂的。。</p><p>4、本人可以亲自传授经验（编程和生活点滴经验）</p><p><strong>如果你有意愿的话，请加我 QQ ： 1041218129  聊聊吧</strong></p><hr><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180103/mL5G5acdd4.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;老读者可能会发现现在我的公众号已经改名了。（由 “猿blog”  变成  “zhisheng” 了，细心的童鞋会发现不仅名字变了， ID 也变了，但是图片还没改，暂时还没想到好的 logo 图片），下面说说为啥吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 安装及快速入门</title>
    <link href="http://yoursite.com/2018/01/04/Kafka/"/>
    <id>http://yoursite.com/2018/01/04/Kafka/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-01-21T11:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/2K14BekelF.jpg-1" alt="mark"></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>官网：<a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a></p><p>Apache Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。<br><a id="more"></a><br>Apache Kafka与传统消息系统相比，有以下不同：</p><ul><li><p>它被设计为一个分布式系统，易于向外扩展；</p></li><li><p>它同时为发布和订阅提供高吞吐量；</p></li><li><p>它支持多订阅者，当失败时能自动平衡消费者；</p></li><li><p>它将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。</p></li></ul><h3 id="安装-kafka"><a href="#安装-kafka" class="headerlink" title="安装 kafka"></a>安装 kafka</h3><p>下载地址：<a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">https://kafka.apache.org/downloads</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.shuosc.org/apache/kafka/1.0.0/kafka_2.11-1.0.0.tgz</span><br></pre></td></tr></table></figure><p>解压：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kafka_2.11-1.0.0.tgz</span><br><span class="line"></span><br><span class="line">cd /usr/local/kafka_2.11-1.0.0/</span><br></pre></td></tr></table></figure></p><p>修改 kafka-server 的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/kafka/config/server.properties</span><br></pre></td></tr></table></figure><p>修改其中的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">broker.id=1</span><br><span class="line">log.dir=/data/kafka/logs-1</span><br></pre></td></tr></table></figure><h3 id="功能验证："><a href="#功能验证：" class="headerlink" title="功能验证："></a>功能验证：</h3><h4 id="1、启动-zk"><a href="#1、启动-zk" class="headerlink" title="1、启动 zk"></a>1、启动 zk</h4><p>使用安装包中的脚本启动单节点 Zookeeper 实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><h4 id="2、启动Kafka-服务"><a href="#2、启动Kafka-服务" class="headerlink" title="2、启动Kafka 服务"></a>2、启动Kafka 服务</h4><p>使用 <code>kafka-server-start.sh</code> 启动 kafka 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh  config/server.properties</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/Lc2CiKfIee.png-1" alt="mark"></p><h4 id="3、创建-topic"><a href="#3、创建-topic" class="headerlink" title="3、创建 topic"></a>3、创建 topic</h4><p>使用 <code>kafka-topics.sh</code> 创建单分区单副本的 topic test：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure><p>查看 topic 列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p>查询创建的 topic 列表报错：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/c3K5D805eI.png-1" alt="mark"></p><p>解决方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>将 host 里的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         ip6-localhost ip6-localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure><p>方法参考：<a href="https://stackoverflow.com/questions/28109669/zookeeper-unable-to-open-socket-to-localhost-000000012181" target="_blank" rel="noopener">zookeeper unable to open socket to localhost/0:0:0:0:0:0:0:1:2181</a></p><p>再次查询就不报错了。</p><h4 id="4、产生消息"><a href="#4、产生消息" class="headerlink" title="4、产生消息"></a>4、产生消息</h4><p>使用 <code>kafka-console-producer.sh</code> 发送消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/4F1EAgdmI1.png-1" alt="mark"></p><h4 id="5、消费消息"><a href="#5、消费消息" class="headerlink" title="5、消费消息"></a>5、消费消息</h4><p>使用 <code>kafka-console-consumer.sh</code> 接收消息并在终端打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning</span><br></pre></td></tr></table></figure><p>打开个新的命令窗口执行上面命令即可查看信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/c8mg8jJFki.png-1" alt="mark"></p><h4 id="6、查看描述-topics-信息"><a href="#6、查看描述-topics-信息" class="headerlink" title="6、查看描述 topics 信息"></a>6、查看描述 topics 信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Topic:testPartitionCount:1ReplicationFactor:1Configs:</span><br><span class="line">Topic: testPartition: 0Leader: 1Replicas: 1Isr: 1</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/6JlmHdLcI5.png-1" alt="mark"></p><p>第一行给出了所有分区的摘要，每个附加行给出了关于一个分区的信息。 由于我们只有一个分区，所以只有一行。</p><p>“Leader”: 是负责给定分区的所有读取和写入的节点。 每个节点将成为分区随机选择部分的领导者。</p><p>“Replicas”: 是复制此分区日志的节点列表，无论它们是否是领导者，或者即使他们当前处于活动状态。</p><p>“Isr”: 是一组“同步”副本。这是复制品列表的子集，当前活着并被引导到领导者。</p><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p>Kafka 支持两种模式的集群搭建：可以在单机上运行多个 broker 实例来实现集群，也可在多台机器上搭建集群，下面介绍下如何实现单机多 broker 实例集群，其实很简单，只需要如下配置即可。</p><h4 id="单机多broker-集群配置"><a href="#单机多broker-集群配置" class="headerlink" title="单机多broker 集群配置"></a>单机多broker 集群配置</h4><p>利用单节点部署多个 broker。 不同的 broker 设置不同的 id，监听端口及日志目录。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp config/server.properties config/server-2.properties</span><br><span class="line"></span><br><span class="line">cp config/server.properties config/server-3.properties</span><br><span class="line"></span><br><span class="line">vim config/server-2.properties</span><br><span class="line"></span><br><span class="line">vim config/server-3.properties</span><br></pre></td></tr></table></figure><p>修改 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">broker.id=2</span><br><span class="line"></span><br><span class="line">listeners = PLAINTEXT://your.host.name:9093</span><br><span class="line"></span><br><span class="line">log.dir=/data/kafka/logs-2</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">broker.id=3</span><br><span class="line"></span><br><span class="line">listeners = PLAINTEXT://your.host.name:9094</span><br><span class="line"></span><br><span class="line">log.dir=/data/kafka/logs-3</span><br></pre></td></tr></table></figure><p>启动Kafka服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server-2.properties &amp;</span><br><span class="line"></span><br><span class="line">bin/kafka-server-start.sh config/server-3.properties &amp;</span><br></pre></td></tr></table></figure><p>至此，单机多broker实例的集群配置完毕。</p><h4 id="多机多-broker-集群配置"><a href="#多机多-broker-集群配置" class="headerlink" title="多机多 broker 集群配置"></a>多机多 broker 集群配置</h4><p>分别在多个节点按上述方式安装 Kafka，配置启动多个 Zookeeper 实例。</p><p>假设三台机器 IP 地址是 ： 192.168.153.135， 192.168.153.136， 192.168.153.137</p><p>分别配置多个机器上的 Kafka 服务，设置不同的 broker id，zookeeper.connect 设置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config/server.properties</span><br></pre></td></tr></table></figure><p>里面的 <code>zookeeper.connect</code></p><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.connect=192.168.153.135:2181,192.168.153.136:2181,192.168.153.137:2181</span><br></pre></td></tr></table></figure><h3 id="使用-Kafka-Connect-来导入-导出数据"><a href="#使用-Kafka-Connect-来导入-导出数据" class="headerlink" title="使用 Kafka Connect 来导入/导出数据"></a>使用 Kafka Connect 来导入/导出数据</h3><p>从控制台写入数据并将其写回控制台是一个方便的起点，但您可能想要使用其他来源的数据或将数据从 Kafka 导出到其他系统。对于许多系统，您可以使用 Kafka Connect 来导入或导出数据，而不必编写自定义集成代码。</p><p>Kafka Connect 是 Kafka 包含的一个工具，可以将数据导入和导出到 Kafka。它是一个可扩展的工具，运行 连接器，实现与外部系统交互的自定义逻辑。在这个快速入门中，我们将看到如何使用简单的连接器运行 Kafka Connect，这些连接器将数据从文件导入到 Kafka topic，并将数据从 Kafka topic 导出到文件。</p><p>首先，我们将通过创建一些种子数据开始测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;zhisheng\ntian&quot; &gt; test.txt</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/79EG4ilBAH.png-1" alt="mark"></p><p>接下来，我们将启动两个以独立模式运行的连接器，这意味着它们将在单个本地专用进程中运行。我们提供三个配置文件作为参数。首先是 Kafka Connect 过程的配置，包含常见的配置，例如要连接的 Kafka 代理以及数据的序列化格式。其余的配置文件都指定一个要创建的连接器。这些文件包括唯一的连接器名称，要实例化的连接器类以及连接器所需的任何其他配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/connect-standalone.sh  config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</span><br></pre></td></tr></table></figure><p>Kafka 附带的这些示例配置文件使用您之前启动的默认本地群集配置，并创建两个连接器：第一个是源连接器，用于读取输入文件中的行，并将每个连接生成为 Kafka topic，第二个为连接器它从 Kafka topic 读取消息，并在输出文件中产生每行消息。</p><p>在启动过程中，您会看到一些日志消息，其中一些指示连接器正在实例化。Kafka Connect 进程启动后，源连接器应该开始读取 test.txt topic connect-test，并将其生成 topic ，并且接收器连接器应该开始读取 topic 中的消息 connect-test 并将其写入文件 test.sink.txt。我们可以通过检查输出文件的内容来验证通过整个管道传输的数据：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/Jh18BCJcb6.png-1" alt="mark"></p><p>数据存储在 Kafka topic 中 connect-test，因此我们也可以运行控制台使用者来查看 topic 中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic connect-test --from-beginning</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/LBC5fF1LK6.png-1" alt="mark"></p><p>连接器继续处理数据，所以我们可以将数据添加到文件中，并看到它在管道中移动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo zhishengtian&gt;&gt; test.txt</span><br><span class="line">echo zhishengtian2&gt;&gt; test.txt</span><br><span class="line">echo zhishengtian3&gt;&gt; test.txt</span><br><span class="line">echo zhishengtian4&gt;&gt; test.txt</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/0DH6K1dkBA.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/6JLE96B87K.png-1" alt="mark"></p><h3 id="使用-Kafka-流来处理数据"><a href="#使用-Kafka-流来处理数据" class="headerlink" title="使用 Kafka 流来处理数据"></a>使用 Kafka 流来处理数据</h3><p>Kafka Streams 是用于构建关键任务实时应用程序和微服务的客户端库，输入和/或输出数据存储在 Kafka 集群中。Kafka Streams 结合了在客户端编写和部署标准 Java 和 Scala 应用程序的简单性以及 Kafka 服务器端集群技术的优势，使这些应用程序具有高度可伸缩性，弹性，容错性，分布式等特性。</p><p>可参考官网入门案例：<a href="http://kafka.apache.org/10/documentation/streams/quickstart" target="_blank" rel="noopener">http://kafka.apache.org/10/documentation/streams/quickstart</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1、<a href="https://www.mtyun.com/library/how-to-install-kafka-on-centos7" target="_blank" rel="noopener">在CentOS 7上安装Kafka</a></p><p>2、<a href="http://kafka.apache.org/10/documentation/streams/quickstart" target="_blank" rel="noopener">http://kafka.apache.org/10/documentation/streams/quickstart</a></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/04/Kafka/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180104/2K14BekelF.jpg-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;官网：&lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://kafka.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Apache Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。&lt;br&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下安装 Consul</title>
    <link href="http://yoursite.com/2017/12/27/consul-install/"/>
    <id>http://yoursite.com/2017/12/27/consul-install/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-01-21T11:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171227/Da4dGccaEd.jpg-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>从刚工作就开始接触 Consul，中途自己也有两个项目和 Consul 有关，后面有机会再讲讲，网上关于这个的资料还比较少。因为明天有 Consul 的技术分享，所以自己今天下午在官网看了下相关的介绍。<br><a id="more"></a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,  由 HashiCorp 公司用 Go 语言开发,  基于 Mozilla Public License 2.0 的协议进行开源。Consul 支持健康检查,  并允许 HTTP 和 DNS 协议调用 API 存储键值对。<br>命令行超级好用的虚拟机管理软件 vgrant 也是 HashiCorp 公司开发的产品。一致性协议采用 Raft 算法,  用来保证服务的高可用， 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制。</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>去官网下载：<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">https://www.consul.io/downloads.html</a></p><p>得到一个 zip 压缩包</p><p>在你想要安装的位置解压就行，只有一个 consul.exe 文件（我的解压位置是：D:\software）</p><p>设置环境变量（在 path 中新增一条）：</p><p>D:\software</p><p>cmd 命令窗口启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -dev</span><br></pre></td></tr></table></figure><p>consul 自带 UI 界面，打开网址：<a href="http://localhost:8500" target="_blank" rel="noopener">http://localhost:8500</a> ，可以看到当前注册的服务界面。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171227/7Alcc9AECH.png-1" alt="mark"></p><h3 id="Consul-优势"><a href="#Consul-优势" class="headerlink" title="Consul 优势"></a>Consul 优势</h3><ul><li>使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft.</li><li>支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等. zookeeper 和 etcd 均不提供多数据中心功能的支持.</li><li>支持健康检查. etcd 不提供此功能.</li><li>支持 http 和 dns 协议接口. zookeeper 的集成较为复杂, etcd 只支持 http 协议.</li><li>官方提供web管理界面, etcd 无此功能.</li></ul><p>综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究.</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><p>本文首发于：<a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">zhisheng的博客</a></p><p>地址为：<a href="http://www.54tianzhisheng.cn/2017/12/27/consul-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/12/27/consul-install/</a>    转载请注明地址！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/171227/Da4dGccaEd.jpg-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;从刚工作就开始接触 Consul，中途自己也有两个项目和 Consul 有关，后面有机会再讲讲，网上关于这个的资料还比较少。因为明天有 Consul 的技术分享，所以自己今天下午在官网看了下相关的介绍。&lt;br&gt;
    
    </summary>
    
    
      <category term="Consul" scheme="http://yoursite.com/tags/Consul/"/>
    
  </entry>
  
  <entry>
    <title>ELK 实时日志分析平台环境搭建</title>
    <link href="http://yoursite.com/2017/12/25/ELK/"/>
    <id>http://yoursite.com/2017/12/25/ELK/</id>
    <published>2017-12-24T16:00:00.000Z</published>
    <updated>2018-01-21T11:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171225/82lhH8E4Hk.jpg-1" alt="mark"></p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>ELK（ElasticSearch, Logstash, Kibana），三者组合在一起搭建实时的日志分析平台，目前好多公司都是这套！<br><a id="more"></a></p><ul><li>Elasticsearch 是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful 风格接口，多数据源，自动搜索负载等。</li><li>Logstash 是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</li><li>Kibana 也是一个开源和免费的工具，它 Kibana 可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</li></ul><h3 id="安装-ES"><a href="#安装-ES" class="headerlink" title="安装 ES"></a>安装 ES</h3><p>。。。这个省略，不 bb 了，以前写过。。。传送门：<a href="http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/</a></p><h3 id="安装-Logstash"><a href="#安装-Logstash" class="headerlink" title="安装 Logstash"></a>安装 Logstash</h3><p>ELK 整套环境搭建版本很关键，最好全统一一个版本，否则出啥问题就不太好找了。这是我见过版本统一最严格的了。而已 ES 版本升了后，其他的都要都要升级，包括其插件。升级代价挺大的，最好一开始就定位好要安装哪个版本！</p><p>在官网下好安装包后传到 Linux 上，这是速度最快的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">在 /usr/local 目录下解压：</span><br><span class="line"></span><br><span class="line">tar -zxvf  logstash-5.5.2.tar.gz</span><br><span class="line"></span><br><span class="line">进入解压后的目录：</span><br><span class="line"></span><br><span class="line">cd /usr/local/logstash-5.5.2/bin</span><br><span class="line"></span><br><span class="line">新增配置文件：</span><br><span class="line"></span><br><span class="line">vim logstash.conf</span><br><span class="line"></span><br><span class="line">增加：</span><br><span class="line"></span><br><span class="line">input&#123;</span><br><span class="line">    file&#123;</span><br><span class="line">      path =&gt; [&quot;/var/log/*.log&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">   elasticsearch&#123;</span><br><span class="line">       hosts =&gt; [&quot;192.168.153.135:9200&quot;]</span><br><span class="line">       index =&gt; &quot;logstash__log&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Logstash 的启动方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 /usr/local/logstash-5.5.2/bin 目录下运行：</span><br><span class="line"></span><br><span class="line">./logstash -f logstash.conf</span><br></pre></td></tr></table></figure><h3 id="安装-Kibana"><a href="#安装-Kibana" class="headerlink" title="安装 Kibana"></a>安装 Kibana</h3><p>同样，官网下好安装包，上传到 Linux。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解压：</span><br><span class="line"></span><br><span class="line">tar -zxvf kibana-5.5.2-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">修改配置文件 kibana-5.5.2/config/kibana.yml 如下：</span><br><span class="line"></span><br><span class="line">Server.host  //配置机器ip/hostname</span><br><span class="line"></span><br><span class="line">Server.name  //此kibana服务的名称</span><br><span class="line"></span><br><span class="line">elasticsearch.url  //es master节点url</span><br></pre></td></tr></table></figure><p>Kibana 启动方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 /usr/local/kibana-5.5.2/bin 目录下运行：</span><br><span class="line"></span><br><span class="line">./kibana</span><br></pre></td></tr></table></figure><p>Web界面访问: <a href="http://ip:5601" target="_blank" rel="noopener">http://ip:5601</a> 此时需要输入用户名和密码登录,默认分别是 elastic 和 changeme</p><h3 id="X-Pack"><a href="#X-Pack" class="headerlink" title="X-Pack"></a>X-Pack</h3><p>X-Pack 是一个 Elastic Stack 的扩展，将安全，警报，监控，报告和图形功能包含在一个易于安装的软件包中。</p><p>ES 和 Kibana 都可安装。</p><p>插件 x-pack-5.5.2.zip  依旧官网下。</p><h4 id="ES-安装-X-Pack"><a href="#ES-安装-X-Pack" class="headerlink" title="ES 安装 X-Pack"></a>ES 安装 X-Pack</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/elasticsearch/bin</span><br><span class="line"></span><br><span class="line">./elasticsearch-plugin install file:///opt/es/x-pack-5.5.2.zip</span><br></pre></td></tr></table></figure><p>如果成功：显示如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 bin]# ./elasticsearch-plugin install file:///opt/es/x-pack-5.5.2.zip</span><br><span class="line">-&gt; Downloading file:///opt/es/x-pack-5.5.2.zip</span><br><span class="line">[=================================================] 100%</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@     WARNING: plugin requires additional permissions     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">* java.io.FilePermission \\.\pipe\* read,write</span><br><span class="line">* java.lang.RuntimePermission accessClassInPackage.com.sun.activation.registries</span><br><span class="line">* java.lang.RuntimePermission getClassLoader</span><br><span class="line">* java.lang.RuntimePermission setContextClassLoader</span><br><span class="line">* java.lang.RuntimePermission setFactory</span><br><span class="line">* java.security.SecurityPermission createPolicy.JavaPolicy</span><br><span class="line">* java.security.SecurityPermission getPolicy</span><br><span class="line">* java.security.SecurityPermission putProviderProperty.BC</span><br><span class="line">* java.security.SecurityPermission setPolicy</span><br><span class="line">* java.util.PropertyPermission * read,write</span><br><span class="line">* java.util.PropertyPermission sun.nio.ch.bugLevel write</span><br><span class="line">* javax.net.ssl.SSLPermission setHostnameVerifier</span><br><span class="line">See http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.html</span><br><span class="line">for descriptions of what these permissions allow and the associated risks.</span><br><span class="line"></span><br><span class="line">Continue with installation? [y/N]y</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@        WARNING: plugin forks a native controller        @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">This plugin launches a native controller that is not subject to the Java</span><br><span class="line">security manager nor to system call filters.</span><br><span class="line"></span><br><span class="line">Continue with installation? [y/N]y</span><br><span class="line">-&gt; Installed x-pack</span><br></pre></td></tr></table></figure><h4 id="Kibana-安装-X-Pack"><a href="#Kibana-安装-X-Pack" class="headerlink" title="Kibana 安装 X-Pack"></a>Kibana 安装 X-Pack</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/kibana-5.5.2/bin</span><br><span class="line"></span><br><span class="line">./kibana-plugin install file:///opt/es/x-pack-5.5.2.zip</span><br></pre></td></tr></table></figure><p>安装成功如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 bin]# ./kibana-plugin install file:///opt/es/x-pack-5.5.2.zip</span><br><span class="line">Attempting to transfer from file:///opt/es/x-pack-5.5.2.zip</span><br><span class="line">Transferring 159867054 bytes....................</span><br><span class="line">Transfer complete</span><br><span class="line">Retrieving metadata from plugin archive</span><br><span class="line">Extracting plugin archive</span><br><span class="line">Extraction complete</span><br><span class="line">Optimizing and caching browser bundles...</span><br><span class="line">Plugin installation complete</span><br></pre></td></tr></table></figure><h4 id="启用-x-pack-安全机制"><a href="#启用-x-pack-安全机制" class="headerlink" title="启用 x-pack 安全机制"></a>启用 x-pack 安全机制</h4><p>分别在 kibana.yml 和 elasticsearch.yml 中加入下行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpack.security.enabled: true</span><br></pre></td></tr></table></figure><p>这样后，你再打开 ES 的 head 界面和 Kibana 管理界面就需要输入账号密码了。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171225/i8ebl0jgLl.png-1" alt="mark"></p><p>上图右边是安装 X-Pack 后的，功能多了几个。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>环境搭建很简单，后面如果有时间的话可以再讲讲在 Kibana 的 Dev Tools 上构建 ES 的 JSON 串来对 ES 进行操作。</p><p>我还写过 ES 相关的文章：</p><p>1、<a href="http://www.54tianzhisheng.cn/2017/09/07/Elasticsearch-analyzers/" target="_blank" rel="noopener">Elasticsearch 默认分词器和中分分词器之间的比较及使用方法</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/09/09/Elasticsearch-install/" target="_blank" rel="noopener">全文搜索引擎 Elasticsearch 集群搭建入门教程</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/10/15/ElasticSearch-cluster-health-metrics/" target="_blank" rel="noopener">ElasticSearch 集群监控</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2017/10/18/ElasticSearch-nodes-metrics/" target="_blank" rel="noopener">ElasticSearch 单个节点监控</a></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><blockquote><p>本文首发于：<a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">zhisheng 的博客</a></p><p>转载请注明地址：<a href="http://www.54tianzhisheng.cn/2017/12/25/ELK/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/12/25/ELK/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/171225/82lhH8E4Hk.jpg-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h3&gt;&lt;p&gt;ELK（ElasticSearch, Logstash, Kibana），三者组合在一起搭建实时的日志分析平台，目前好多公司都是这套！&lt;br&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/tags/ElasticSearch/"/>
    
      <category term="LogStash" scheme="http://yoursite.com/tags/LogStash/"/>
    
      <category term="Kibana" scheme="http://yoursite.com/tags/Kibana/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + yilia 搭建博客可能会遇到的所有疑问</title>
    <link href="http://yoursite.com/2017/12/18/hexo-yilia/"/>
    <id>http://yoursite.com/2017/12/18/hexo-yilia/</id>
    <published>2017-12-17T16:00:00.000Z</published>
    <updated>2018-01-21T11:14:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/BaE3G1imDm.png-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>为什么会再次写这篇博客？请看下图：<br><a id="more"></a></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/b4j29CkGgJ.png-1" alt="mark"></p><p>这是我博客搜索引擎的主要关键字。为什么会有这些关键字呢？</p><p>我猜估计是曾经写了几篇关于搭建博客的文章，被搜索引擎收入了，所以搜索引擎才会将这些流量引导至我的博客，文章如下：</p><p>1、<a href="http://www.54tianzhisheng.cn/2017/03/28/%E5%88%A9%E7%94%A8Github%20Page%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/" target="_blank" rel="noopener">利用Github Page 搭建个人博客网站</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2017/06/13/Hexo-yilia-toc/" target="_blank" rel="noopener">Hexo + yilia 主题实现文章目录</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2017/04/13/Hexo-yilia-changyan/" target="_blank" rel="noopener">Github pages + Hexo 博客 yilia 主题使用畅言评论系统</a></p><p>那还有这么多人搜索这些关键字？说明碰到问题的还有不少，所以才有了这篇文章的诞生！</p><h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><p><strong>1、hexo  yilia 文章目录</strong></p><p>这个我以前写过一篇文章：<a href="http://www.54tianzhisheng.cn/2017/06/13/Hexo-yilia-toc/" target="_blank" rel="noopener">Hexo + yilia 主题实现文章目录</a>    那篇文章写了我那个版本的 yilia 怎么添加文章目录的，但是好像新版本的 yilia 已经自带了这个文章目录功能。所以如果你是使用的新版本的 yilia ，请不要做任何修改！但是前几天有人给我发了个图片，又好像有点区别，如果实在有不同的话，请加群 528776268 找我要我那个主题版本的所有配置文件。再次说明，我前端也不是很擅长，我写那篇文章也是参考其他博客的修改，所以无能为力了。有什么问题，建议直接在 yilia 主题的 GitHub 去找作者聊！</p><p><strong>2、Hexo  yilia  随笔</strong></p><p>随笔如下：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/0kkIFEkcja.png-1" alt="mark"></p><p>对此想说的就是，“随笔”  其实就是文章的一个 tags(标签)，如果你想把文章作为随笔的话，请在文章的首部写个 tags  为 “随笔”   的标签。如下图：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/13539aGJF5.png-1" alt="mark"></p><p>注意：-  后面有个空格。</p><p><strong>3、yilia 主题分类实现</strong></p><p>如果要有多个标签，可以如下图所示：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/lF42EedCJA.png-1" alt="mark"></p><p><strong>4、hexo yilia 设置文章显示长度，不展开全文</strong></p><p>yilia 主题中可以用 <code>&lt;!-- more --&gt;</code>  截取文章的显示长度，如果你想在哪截取文章，就在那行使用该字符。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/2ickeEEFbh.png-1" alt="mark"></p><p><strong>5、yilia 添加阅读量</strong></p><p>我添加的是 “不蒜子” 计数，它可以区分 pv/uv 的统计方式，统计更精准，满足更多需求。有这个需求的可以去查找下博客怎么添加。（网上有很多这方面的博客）</p><p><strong>6、yilia 主题使用 “畅言” 评论系统</strong></p><p>参见我以前的文章：  <a href="http://www.54tianzhisheng.cn/2017/04/13/Hexo-yilia-changyan/" target="_blank" rel="noopener">Github pages + Hexo 博客 yilia 主题使用畅言评论系统</a></p><p><strong>7、hexo yilia 引入音乐</strong></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/fA367Gej62.png-1" alt="mark"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"填写音乐链接地址"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下图，可以在网易云音乐里搜到你想要引入的音乐，然后点击如下的 “生成外链播放器” 即可：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/lLLLBlH1FK.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/ibaCjDEhEa.png-1" alt="mark"></p><p><strong>8、hexo yilia 引入视频</strong></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/1f6gC2mJ1f.png-1" alt="mark"></p><p>hexo  支持 html 语法的，所以可以如上图这样引入视频！</p><p><strong>9、hexo  yilia  相册</strong></p><p>这个抱歉，我自己也没做这方面的功能，暂时不太清楚怎么实现。不过有文章写怎么实现，大家可以搜索下！</p><p><strong>10、hexo  yilia  怎么写文章</strong></p><p>我一般写文章就是先用本地 markdown 编辑器写好后，然后放在 hexo 的 <code>source/_posts</code> 目录下。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171218/0HjLacBcfe.png-1" alt="mark"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>好了，大概就这些问题，我也一一解答了，希望搭建博客的你可以看到这篇文章，让你少走点弯路，如果你也遇到过这些问题，还请你能分享下文章，让更多人避免入坑！</p><p>本文地址是：<a href="http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia" target="_blank" rel="noopener">Hexo + yilia 搭建博客可能会遇到的所有疑问</a>  本文原创，转载请注明原创地址。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><a href="http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/12/18/hexo-yilia</a>  这个链接是让推酷爬虫吞掉的，哈哈！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/171218/BaE3G1imDm.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;为什么会再次写这篇博客？请看下图：&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="yilia" scheme="http://yoursite.com/tags/yilia/"/>
    
  </entry>
  
</feed>
